{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Easily find the code that annoys you the most. #plugins::after { clear:both; } #plugins .admonition { float: left; margin-right: 1em; min-width: 200px; } #plugins p { text-align: center; } #plugins .title { font-size: 3em; font-weight: bold; } B bugbear 21.4.3 S bandit 1.7.0 WPS wemake-python-styleguide 0.15.3","title":"flake8 error codes"},{"location":"flake8-bandit/index.html","text":"","title":"bandit"},{"location":"flake8-bandit/1.7.0/index.html","text":"","title":"1.7.0"},{"location":"S101/","text":"This plugin test checks for the use of the Python assert keyword. It was discovered that some projects used assert to enforce interface constraints. However, assert is removed with compiling to optimised byte code (python -o producing *.pyo files). This caused various protections to be removed. Consider raising a semantically meaningful error or AssertionError instead. Please see https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement for more info on assert . Config Options: You can configure files that skip this check. This is often useful when you use assert statements in test cases. assert_used : skips : [ '*_test.py' , 'test_*.py' ] Example >> Issue: Use of assert detected. The enclosed code will be removed when compiling to optimised byte code. Severity: Low Confidence: High Location: ./examples/assert.py:1 1 assert logged_in 2 display_assets() See Also: - https://bugs.launchpad.net/juniperopenstack/+bug/1456193 - https://bugs.launchpad.net/heat/+bug/1397883 - https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement 0.11.0","title":"Test for use of assert"},{"location":"S102/","text":"This plugin test checks for the use of Python's exec method or keyword. The Python docs succinctly describe why the use of exec is risky. Example >> Issue : Use of exec detected . Severity : Medium Confidence : High Location : . / examples / exec - py2 . py : 2 1 exec ( \" do evil \" ) 2 exec \" do evil \" See Also: - https : // docs . python . org / 2 / reference / simple_stmts . html # exec - https : // docs . python . org / 3 / library / functions . html # exec - https : // www . python . org / dev / peps / pep - 0551 / # background - https : // www . python . org / dev / peps / pep - 0578 / # suggested - audit - hook - locations 0.9.0","title":"Test for the use of exec"},{"location":"S103/","text":"POSIX based operating systems utilize a permissions model to protect access to parts of the file system. This model supports three roles \"owner\", \"group\" and \"world\" each role may have a combination of \"read\", \"write\" or \"execute\" flags sets. Python provides chmod to manipulate POSIX style permissions. This plugin test looks for the use of chmod and will alert when it is used to set particularly permissive control flags. A MEDIUM warning is generated if a file is set to group executable and a HIGH warning is reported if a file is set world writable. Warnings are given with HIGH confidence. Example >> Issue: Probable insecure usage of temp file/directory. Severity: Medium Confidence: Medium Location: ./examples/os-chmod-py2.py:15 14 os.chmod('/etc/hosts', 0o777) 15 os.chmod('/tmp/oh_hai', 0x1ff) 16 os.chmod('/etc/passwd', stat.S_IRWXU) >> Issue: Chmod setting a permissive mask 0777 on file (key_file). Severity: High Confidence: High Location: ./examples/os-chmod-py2.py:17 16 os.chmod('/etc/passwd', stat.S_IRWXU) 17 os.chmod(key_file, 0o777) 18 See Also: - https://security.openstack.org/guidelines/dg_apply-restrictive-file-permissions.html - https://en.wikipedia.org/wiki/File_system_permissions - https://security.openstack.org 0.9.0","title":"Test for setting permissive file permissions"},{"location":"S104/","text":"Binding to all network interfaces can potentially open up a service to traffic on unintended interfaces, that may not be properly documented or secured. This plugin test looks for a string pattern \"0.0.0.0\" that may indicate a hardcoded binding to all network interfaces. Example >> Issue: Possible binding to all interfaces. Severity: Medium Confidence: Medium Location: ./examples/binding.py:4 3 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 4 s.bind(('0.0.0.0', 31137)) 5 s.bind(('192.168.0.1', 8080)) See Also: - https://nvd.nist.gov/vuln/detail/CVE-2018-1281 0.9.0","title":"Test for binding to all interfaces"},{"location":"S105/","text":"The use of hard-coded passwords increases the possibility of password guessing tremendously. This plugin test looks for all string literals and checks the following conditions: assigned to a variable that looks like a password assigned to a dict key that looks like a password used in a comparison with a variable that looks like a password Variables are considered to look like a password if they have match any one of: \"password\" \"pass\" \"passwd\" \"pwd\" \"secret\" \"token\" \"secrete\" Note: this can be noisy and may generate false positives. Config Options: None Example >> Issue : Possible hardcoded password ' (root) ' Severity : Low Confidence : Low Location : . / examples / hardcoded - passwords . py : 5 4 def someFunction2 ( password ) : 5 if password == \" root \" : 6 print ( \" OK, logged in \" ) See Also: - https://www.owasp.org/index.php/Use_of_hard-coded_password 0.9.0","title":"Test for use of hard-coded password strings"},{"location":"S106/","text":"The use of hard-coded passwords increases the possibility of password guessing tremendously. This plugin test looks for all function calls being passed a keyword argument that is a string literal. It checks that the assigned local variable does not look like a password. Variables are considered to look like a password if they have match any one of: \"password\" \"pass\" \"passwd\" \"pwd\" \"secret\" \"token\" \"secrete\" Note: this can be noisy and may generate false positives. Config Options: None Example >> Issue: [B106:hardcoded_password_funcarg] Possible hardcoded password: 'blerg' Severity: Low Confidence: Medium Location: ./examples/hardcoded-passwords.py:16 15 16 doLogin(password=\"blerg\") See Also: - https://www.owasp.org/index.php/Use_of_hard-coded_password 0.9.0","title":"Test for use of hard-coded password function arguments"},{"location":"S107/","text":"The use of hard-coded passwords increases the possibility of password guessing tremendously. This plugin test looks for all function definitions that specify a default string literal for some argument. It checks that the argument does not look like a password. Variables are considered to look like a password if they have match any one of: \"password\" \"pass\" \"passwd\" \"pwd\" \"secret\" \"token\" \"secrete\" Note: this can be noisy and may generate false positives. Config Options: None Example >> Issue: [B107:hardcoded_password_default] Possible hardcoded password: 'Admin' Severity: Low Confidence: Medium Location: ./examples/hardcoded-passwords.py:1 1 def someFunction(user, password=\"Admin\"): 2 print(\"Hi \" + user) See Also: - https://www.owasp.org/index.php/Use_of_hard-coded_password 0.9.0","title":"Test for use of hard-coded password argument defaults"},{"location":"S108/","text":"Safely creating a temporary file or directory means following a number of rules (see the references for more details). This plugin test looks for strings starting with (configurable) commonly used temporary paths, for example: /tmp /var/tmp /dev/shm etc Config Options: This test plugin takes a similarly named config block, hardcoded_tmp_directory . The config block provides a Python list, tmp_dirs , that lists string fragments indicating possible temporary file paths. Any string starting with one of these fragments will report a MEDIUM confidence issue. hardcoded_tmp_directory : tmp_dirs : [ '/tmp' , '/var/tmp' , '/dev/shm' ] Example See Also: - https://security.openstack.org/guidelines/dg_using-temporary-files-securely.html 0.9.0","title":"Test for insecure usage of tmp file/directory"},{"location":"S110/","text":"Errors in Python code bases are typically communicated using Exceptions . An exception object is 'raised' in the event of an error and can be 'caught' at a later point in the program, typically some error handling or logging action will then be performed. However, it is possible to catch an exception and silently ignore it. This is illustrated with the following example try : do_some_stuff () except Exception : pass This pattern is considered bad practice in general, but also represents a potential security issue. A larger than normal volume of errors from a service can indicate an attempt is being made to disrupt or interfere with it. Thus errors should, at the very least, be logged. There are rare situations where it is desirable to suppress errors, but this is typically done with specific exception types, rather than the base Exception class (or no type). To accommodate this, the test may be configured to ignore 'try, except, pass' where the exception is typed. For example, the following would not generate a warning if the configuration option checked_typed_exception is set to False: try : do_some_stuff () except ZeroDivisionError : pass Config Options: try_except_pass : check_typed_exception : True Example >> Issue: Try, Except, Pass detected. Severity: Low Confidence: High Location: ./examples/try_except_pass.py:4 3 a = 1 4 except: 5 pass See Also: - https://security.openstack.org 0.13.0","title":"Test for a pass in the except block"},{"location":"S112/","text":"Errors in Python code bases are typically communicated using Exceptions . An exception object is 'raised' in the event of an error and can be 'caught' at a later point in the program, typically some error handling or logging action will then be performed. However, it is possible to catch an exception and silently ignore it while in a loop. This is illustrated with the following example while keep_going : try : do_some_stuff () except Exception : continue This pattern is considered bad practice in general, but also represents a potential security issue. A larger than normal volume of errors from a service can indicate an attempt is being made to disrupt or interfere with it. Thus errors should, at the very least, be logged. There are rare situations where it is desirable to suppress errors, but this is typically done with specific exception types, rather than the base Exception class (or no type). To accommodate this, the test may be configured to ignore 'try, except, continue' where the exception is typed. For example, the following would not generate a warning if the configuration option checked_typed_exception is set to False: while keep_going : try : do_some_stuff () except ZeroDivisionError : continue Config Options: try_except_continue : check_typed_exception : True Example >> Issue : Try , Except , Continue detected . Severity : Low Confidence : High Location : . / examples / try_except_continue . py : 5 4 a = i 5 except : 6 continue See Also: - https://security.openstack.org 1.0.0","title":"Test for a continue in the except block"},{"location":"S201/","text":"Running Flask applications in debug mode results in the Werkzeug debugger being enabled. This includes a feature that allows arbitrary code execution. Documentation for both Flask and Werkzeug strongly suggests that debug mode should never be enabled on production systems. Operating a production server with debug mode enabled was the probable cause of the Patreon breach in 2015. Example >> Issue: A Flask app appears to be run with debug=True, which exposes the Werkzeug debugger and allows the execution of arbitrary code. Severity: High Confidence: High Location: examples/flask_debug.py:10 9 #bad 10 app.run(debug=True) 11 See Also: http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode http://werkzeug.palletsprojects.com/en/0.15.x/debug/ http://labs.detectify.com/post/130332638391/how-patreon-got-hacked-publicly-exposed-werkzeug 0.15.0","title":"Test for use of flask app with debug set to true"},{"location":"S301/","text":"pickle.loads pickle.load pickle.Unpickler cPickle.loads cPickle.load cPickle.Unpickler dill.loads dill.load dill.Unpickler shelve.open shelve.DbfilenameShelf","title":"Pickle and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue."},{"location":"S302/","text":"marshal.load marshal.loads","title":"Deserialization with the marshal module is possibly dangerous."},{"location":"S303/","text":"hashlib.md5 hashlib.sha1 Crypto.Hash.MD2.new Crypto.Hash.MD4.new Crypto.Hash.MD5.new Crypto.Hash.SHA.new Cryptodome.Hash.MD2.new Cryptodome.Hash.MD4.new Cryptodome.Hash.MD5.new Cryptodome.Hash.SHA.new cryptography.hazmat.primitives.hashes.MD5 cryptography.hazmat.primitives.hashes.SHA1","title":"Use of insecure MD2, MD4, MD5, or SHA1 hash function."},{"location":"S304/","text":"Crypto.Cipher.ARC2.new Crypto.Cipher.ARC4.new Crypto.Cipher.Blowfish.new Crypto.Cipher.DES.new Crypto.Cipher.XOR.new Cryptodome.Cipher.ARC2.new Cryptodome.Cipher.ARC4.new Cryptodome.Cipher.Blowfish.new Cryptodome.Cipher.DES.new Cryptodome.Cipher.XOR.new cryptography.hazmat.primitives.ciphers.algorithms.ARC4 cryptography.hazmat.primitives.ciphers.algorithms.Blowfish cryptography.hazmat.primitives.ciphers.algorithms.IDEA","title":"Use of insecure cipher {name}. Replace with a known secure cipher such as AES."},{"location":"S305/","text":"cryptography.hazmat.primitives.ciphers.modes.ECB","title":"Use of insecure cipher mode {name}."},{"location":"S306/","text":"tempfile.mktemp","title":"Use of insecure and deprecated function (mktemp)."},{"location":"S307/","text":"eval","title":"Use of possibly insecure function - consider using safer ast.literal_eval."},{"location":"S308/","text":"django.utils.safestring.mark_safe","title":"Use of mark_safe() may expose cross-site scripting vulnerabilities and should be reviewed."},{"location":"S309/","text":"httplib.HTTPSConnection http.client.HTTPSConnection six.moves.http_client.HTTPSConnection","title":"Use of HTTPSConnection on older versions of Python prior to 2.7.9 and 3.4.3 do not provide security, see https://wiki.openstack.org/wiki/OSSN/OSSN-0033"},{"location":"S310/","text":"urllib.urlopen urllib.request.urlopen urllib.urlretrieve urllib.request.urlretrieve urllib.URLopener urllib.request.URLopener urllib.FancyURLopener urllib.request.FancyURLopener urllib2.urlopen urllib2.Request six.moves.urllib.request.urlopen six.moves.urllib.request.urlretrieve six.moves.urllib.request.URLopener six.moves.urllib.request.FancyURLopener","title":"Audit url open for permitted schemes. Allowing use of file:/ or custom schemes is often unexpected."},{"location":"S311/","text":"random.random random.randrange random.randint random.choice random.uniform random.triangular","title":"Standard pseudo-random generators are not suitable for security/cryptographic purposes."},{"location":"S312/","text":"telnetlib.*","title":"Telnet-related functions are being called. Telnet is considered insecure. Use SSH or some other encrypted protocol."},{"location":"S313/","text":"xml.etree.cElementTree.parse xml.etree.cElementTree.iterparse xml.etree.cElementTree.fromstring xml.etree.cElementTree.XMLParser","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S314/","text":"xml.etree.ElementTree.parse xml.etree.ElementTree.iterparse xml.etree.ElementTree.fromstring xml.etree.ElementTree.XMLParser","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S315/","text":"xml.sax.expatreader.create_parser","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S316/","text":"xml.dom.expatbuilder.parse xml.dom.expatbuilder.parseString","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S317/","text":"xml.sax.parse xml.sax.parseString xml.sax.make_parser","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S318/","text":"xml.dom.minidom.parse xml.dom.minidom.parseString","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S319/","text":"xml.dom.pulldom.parse xml.dom.pulldom.parseString","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function or make sure defusedxml.defuse_stdlib() is called"},{"location":"S320/","text":"lxml.etree.parse lxml.etree.fromstring lxml.etree.RestrictedElement lxml.etree.GlobalParserTLS lxml.etree.getDefaultParser lxml.etree.check_docinfo","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with its defusedxml equivalent function."},{"location":"S321/","text":"ftplib.*","title":"FTP-related functions are being called. FTP is considered insecure. Use SSH/SFTP/SCP or some other encrypted protocol."},{"location":"S323/","text":"ssl._create_unverified_context","title":"By default, Python will create a secure, verified ssl context for use in such classes as HTTPSConnection. However, it still allows using an insecure context via the _create_unverified_context that reverts to the previous behavior that does not validate certificates or perform hostname checks."},{"location":"S324/","text":"This plugin checks for the usage of the insecure MD4, MD5, or SHA1 hash functions in hashlib.new function. The hashlib.new function provides the ability to construct a new hashing object using the named algorithm. This can be used to create insecure hash functions like MD4 and MD5 if they are passed as algorithm names to this function. This is similar to B303 blacklist check, except that this checks for insecure hash functions created using hashlib.new function. Example >> Issue: [B324:hashlib_new] Use of insecure MD4 or MD5 hash function. Severity: Medium Confidence: High Location: examples/hashlib_new_insecure_funcs.py:3 2 3 md5_hash = hashlib.new('md5', string='test') 4 print(md5_hash) 1.5.0","title":"Test use of insecure md4, md5, or sha1 hash functions in hashlib.new()"},{"location":"S325/","text":"os.tempnam os.tmpnam","title":"Use of os.tempnam() and os.tmpnam() is vulnerable to symlink attacks. Consider using tmpfile() instead."},{"location":"S401/","text":"telnetlib","title":"A telnet-related module is being imported.  Telnet is considered insecure. Use SSH or some other encrypted protocol."},{"location":"S402/","text":"ftplib","title":"A FTP-related module is being imported.  FTP is considered insecure. Use SSH/SFTP/SCP or some other encrypted protocol."},{"location":"S403/","text":"pickle cPickle dill shelve","title":"Consider possible security implications associated with {name} module."},{"location":"S404/","text":"subprocess","title":"Consider possible security implications associated with {name} module."},{"location":"S405/","text":"xml.etree.cElementTree xml.etree.ElementTree","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package, or make sure defusedxml.defuse_stdlib() is called."},{"location":"S406/","text":"xml.sax","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package, or make sure defusedxml.defuse_stdlib() is called."},{"location":"S407/","text":"xml.dom.expatbuilder","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package, or make sure defusedxml.defuse_stdlib() is called."},{"location":"S408/","text":"xml.dom.minidom","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package, or make sure defusedxml.defuse_stdlib() is called."},{"location":"S409/","text":"xml.dom.pulldom","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package, or make sure defusedxml.defuse_stdlib() is called."},{"location":"S410/","text":"lxml","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Replace {name} with the equivalent defusedxml package."},{"location":"S411/","text":"xmlrpclib","title":"Using {name} to parse untrusted XML data is known to be vulnerable to XML attacks. Use defused.xmlrpc.monkey_patch() function to monkey-patch xmlrpclib and mitigate XML vulnerabilities."},{"location":"S412/","text":"wsgiref.handlers.CGIHandler twisted.web.twcgi.CGIScript twisted.web.twcgi.CGIDirectory","title":"Consider possible security implications associated with {name} module."},{"location":"S413/","text":"Crypto.Cipher Crypto.Hash Crypto.IO Crypto.Protocol Crypto.PublicKey Crypto.Random Crypto.Signature Crypto.Util","title":"The pyCrypto library and its module {name} are no longer actively maintained and have been deprecated. Consider using pyca/cryptography library."},{"location":"S501/","text":"Encryption in general is typically critical to the security of many applications. Using TLS can greatly increase security by guaranteeing the identity of the party you are communicating with. This is accomplished by one or both parties presenting trusted certificates during the connection initialization phase of TLS. When request methods are used certificates are validated automatically which is the desired behavior. If certificate validation is explicitly turned off Bandit will return a HIGH severity error. Example >> Issue : [ request_with_no_cert_validation ] Requests call with verify = False disabling SSL certificate checks , security issue . Severity : High Confidence : High Location : examples / requests - ssl - verify - disabled . py : 4 3 requests . get ( 'https://gmail.com' , verify = True ) 4 requests . get ( 'https://gmail.com' , verify = False ) 5 requests . post ( 'https://gmail.com' , verify = True ) See Also: - https://security.openstack.org/guidelines/dg_move-data-securely.html - https://security.openstack.org/guidelines/dg_validate-certificates.html 0.9.0","title":"Test for missing certificate validation"},{"location":"S502/","text":"Several highly publicized exploitable flaws have been discovered in all versions of SSL and early versions of TLS. It is strongly recommended that use of the following known broken protocol versions be avoided: SSL v2 SSL v3 TLS v1 TLS v1.1 This plugin test scans for calls to Python methods with parameters that indicate the used broken SSL/TLS protocol versions. Currently, detection supports methods using Python's native SSL/TLS support and the pyOpenSSL module. A HIGH severity warning will be reported whenever known broken protocol versions are detected. It is worth noting that native support for TLS 1.2 is only available in more recent Python versions, specifically 2.7.9 and up, and 3.x A note on 'SSLv23': Amongst the available SSL/TLS versions provided by Python/pyOpenSSL there exists the option to use SSLv23. This very poorly named option actually means \"use the highest version of SSL/TLS supported by both the server and client\". This may (and should be) a version well in advance of SSL v2 or v3. Bandit can scan for the use of SSLv23 if desired, but its detection does not necessarily indicate a problem. When using SSLv23 it is important to also provide flags to explicitly exclude bad versions of SSL/TLS from the protocol versions considered. Both the Python native and pyOpenSSL modules provide the OP_NO_SSLv2 and OP_NO_SSLv3 flags for this purpose. Config Options: ssl_with_bad_version : bad_protocol_versions : - PROTOCOL_SSLv2 - SSLv2_METHOD - SSLv23_METHOD - PROTOCOL_SSLv3 # strict option - PROTOCOL_TLSv1 # strict option - SSLv3_METHOD # strict option - TLSv1_METHOD # strict option Example >> Issue: ssl.wrap_socket call with insecure SSL/TLS protocol version identified, security issue. Severity: High Confidence: High Location: ./examples/ssl-insecure-version.py:13 12 # strict tests 13 ssl.wrap_socket(ssl_version=ssl.PROTOCOL_SSLv3) 14 ssl.wrap_socket(ssl_version=ssl.PROTOCOL_TLSv1) See Also: - : func : `ssl_with_bad_defaults` - : func : `ssl_with_no_version` - http :// heartbleed . com / - https :// poodlebleed . com / - https :// security . openstack . org / - https :// security . openstack . org / guidelines / dg_move - data - securely . html 0.9.0","title":"Test for SSL use with bad version used"},{"location":"S503/","text":"This plugin is part of a family of tests that detect the use of known bad versions of SSL/TLS, please see ../plugins/ssl_with_bad_version for a complete discussion. Specifically, this plugin test scans for Python methods with default parameter values that specify the use of broken SSL/TLS protocol versions. Currently, detection supports methods using Python's native SSL/TLS support and the pyOpenSSL module. A MEDIUM severity warning will be reported whenever known broken protocol versions are detected. Config Options: This test shares the configuration provided for the standard ../plugins/ssl_with_bad_version test, please refer to its documentation. Example >> Issue: Function definition identified with insecure SSL/TLS protocol version by default, possible security issue. Severity: Medium Confidence: Medium Location: ./examples/ssl-insecure-version.py:28 27 28 def open_ssl_socket(version=SSL.SSLv2_METHOD): 29 pass See Also: - : func : `ssl_with_bad_version` - : func : `ssl_with_no_version` - http :// heartbleed . com / - https :// poodlebleed . com / - https :// security . openstack . org / - https :// security . openstack . org / guidelines / dg_move - data - securely . html 0.9.0","title":"Test for SSL use with bad defaults specified"},{"location":"S504/","text":"This plugin is part of a family of tests that detect the use of known bad versions of SSL/TLS, please see ../plugins/ssl_with_bad_version for a complete discussion. Specifically, This plugin test scans for specific methods in Python's native SSL/TLS support and the pyOpenSSL module that configure the version of SSL/TLS protocol to use. These methods are known to provide default value that maximize compatibility, but permit use of the aforementioned broken protocol versions. A LOW severity warning will be reported whenever this is detected. Config Options: This test shares the configuration provided for the standard ../plugins/ssl_with_bad_version test, please refer to its documentation. Example >> Issue: ssl.wrap_socket call with no SSL/TLS protocol version specified, the default SSLv23 could be insecure, possible security issue. Severity: Low Confidence: Medium Location: ./examples/ssl-insecure-version.py:23 22 23 ssl.wrap_socket() 24 See Also: - : func : `ssl_with_bad_version` - : func : `ssl_with_bad_defaults` - http :// heartbleed . com / - https :// poodlebleed . com / - https :// security . openstack . org / - https :// security . openstack . org / guidelines / dg_move - data - securely . html 0.9.0","title":"Test for SSL use with no version specified"},{"location":"S505/","text":"As computational power increases, so does the ability to break ciphers with smaller key lengths. The recommended key length size for RSA and DSA algorithms is 2048 and higher. 1024 bits and below are now considered breakable. EC key length sizes are recommended to be 224 and higher with 160 and below considered breakable. This plugin test checks for use of any key less than those limits and returns a high severity error if lower than the lower threshold and a medium severity error for those lower than the higher threshold. Example >> Issue: DSA key sizes below 1024 bits are considered breakable. Severity: High Confidence: High Location: examples/weak_cryptographic_key_sizes.py:36 35 # Also incorrect: without keyword args 36 dsa.generate_private_key(512, 37 backends.default_backend()) 38 rsa.generate_private_key(3, See Also: - http://csrc.nist.gov/publications/nistpubs/800-131A/sp800-131A.pdf - https://security.openstack.org/guidelines/dg_strong-crypto.html 0.14.0","title":"Test for weak cryptographic key use"},{"location":"S506/","text":"This plugin test checks for the unsafe usage of the yaml.load function from the PyYAML package. The yaml.load function provides the ability to construct an arbitrary Python object, which may be dangerous if you receive a YAML document from an untrusted source. The function yaml.safe_load limits this ability to simple Python objects like integers or lists. Please see http://pyyaml.org/wiki/PyYAMLDocumentation#LoadingYAML for more information on yaml.load and yaml.safe_load Example >> Issue: [yaml_load] Use of unsafe yaml load. Allows instantiation of arbitrary objects. Consider yaml.safe_load(). Severity: Medium Confidence: High Location: examples/yaml_load.py:5 4 ystr = yaml.dump({'a' : 1, 'b' : 2, 'c' : 3}) 5 y = yaml.load(ystr) 6 yaml.dump(y) See Also: - http://pyyaml.org/wiki/PyYAMLDocumentation#LoadingYAML 1.0.0","title":"Test for use of yaml load"},{"location":"S507/","text":"Encryption in general is typically critical to the security of many applications. Using SSH can greatly increase security by guaranteeing the identity of the party you are communicating with. This is accomplished by one or both parties presenting trusted host keys during the connection initialization phase of SSH. When paramiko methods are used, host keys are verified by default. If host key verification is disabled, Bandit will return a HIGH severity error. Example >> Issue: [B507:ssh_no_host_key_verification] Paramiko call with policy set to automatically trust the unknown host key. Severity: High Confidence: Medium Location: examples/no_host_key_verification.py:4 3 ssh_client = client.SSHClient() 4 ssh_client.set_missing_host_key_policy(client.AutoAddPolicy) 5 ssh_client.set_missing_host_key_policy(client.WarningPolicy) 1.5.1","title":"Test for missing host key validation"},{"location":"S601/","text":"Paramiko is a Python library designed to work with the SSH2 protocol for secure (encrypted and authenticated) connections to remote machines. It is intended to run commands on a remote host. These commands are run within a shell on the target and are thus vulnerable to various shell injection attacks. Bandit reports a MEDIUM issue when it detects the use of Paramiko's \"exec_command\" method advising the user to check inputs are correctly sanitized. Example >> Issue : Possible shell injection via Paramiko call , check inputs are properly sanitized . Severity : Medium Confidence : Medium Location : ./ examples / paramiko_injection . py : 4 3 # this is not safe 4 paramiko . exec_command ( 'something; really; unsafe' ) 5 See Also: - https://security.openstack.org - https://github.com/paramiko/paramiko - https://www.owasp.org/index.php/Command_Injection 0.12.0","title":"Test for shell injection within Paramiko"},{"location":"S602/","text":"Python possesses many mechanisms to invoke an external executable. However, doing so may present a security issue if appropriate care is not taken to sanitize any user provided or variable input. This plugin test is part of a family of tests built to check for process spawning and warn appropriately. Specifically, this test looks for the spawning of a subprocess using a command shell. This type of subprocess invocation is dangerous as it is vulnerable to various shell injection attacks. Great care should be taken to sanitize all input in order to mitigate this risk. Calls of this type are identified by a parameter of 'shell=True' being given. Additionally, this plugin scans the command string given and adjusts its reported severity based on how it is presented. If the command string is a simple static string containing no special shell characters, then the resulting issue has low severity. If the string is static, but contains shell formatting characters or wildcards, then the reported issue is medium. Finally, if the string is computed using Python's string manipulation or formatting operations, then the reported issue has high severity. These severity levels reflect the likelihood that the code is vulnerable to injection. See also: ../plugins/linux_commands_wildcard_injection ../plugins/subprocess_without_shell_equals_true ../plugins/start_process_with_no_shell ../plugins/start_process_with_a_shell ../plugins/start_process_with_partial_path Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This plugin specifically scans for methods listed in subprocess section that have shell=True specified. shell_injection : # Start a process using the subprocess module, or one of its wrappers. subprocess : - subprocess.Popen - subprocess.call Example >> Issue: subprocess call with shell=True seems safe, but may be changed in the future, consider rewriting without shell Severity: Low Confidence: High Location: ./examples/subprocess_shell.py:21 20 subprocess.check_call(['/bin/ls', '-l'], shell=False) 21 subprocess.check_call('/bin/ls -l', shell=True) 22 >> Issue: call with shell=True contains special shell characters, consider moving extra logic into Python code Severity: Medium Confidence: High Location: ./examples/subprocess_shell.py:26 25 26 subprocess.Popen('/bin/ls *', shell=True) 27 subprocess.Popen('/bin/ls %s' % ('something',), shell=True) >> Issue: subprocess call with shell=True identified, security issue. Severity: High Confidence: High Location: ./examples/subprocess_shell.py:27 26 subprocess.Popen('/bin/ls *', shell=True) 27 subprocess.Popen('/bin/ls %s' % ('something',), shell=True) 28 subprocess.Popen('/bin/ls {}'.format('something'), shell=True) See Also: - https://security.openstack.org - https://docs.python.org/3/library/subprocess.html#frequently-used-arguments - https://security.openstack.org/guidelines/dg_use-subprocess-securely.html - https://security.openstack.org/guidelines/dg_avoid-shell-true.html 0.9.0","title":"Test for use of popen with shell equals true"},{"location":"S603/","text":"Python possesses many mechanisms to invoke an external executable. However, doing so may present a security issue if appropriate care is not taken to sanitize any user provided or variable input. This plugin test is part of a family of tests built to check for process spawning and warn appropriately. Specifically, this test looks for the spawning of a subprocess without the use of a command shell. This type of subprocess invocation is not vulnerable to shell injection attacks, but care should still be taken to ensure validity of input. Because this is a lesser issue than that described in subprocess_popen_with_shell_equals_true a LOW severity warning is reported. See also: ../plugins/linux_commands_wildcard_injection ../plugins/subprocess_popen_with_shell_equals_true ../plugins/start_process_with_no_shell ../plugins/start_process_with_a_shell ../plugins/start_process_with_partial_path Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This plugin specifically scans for methods listed in subprocess section that have shell=False specified. shell_injection : # Start a process using the subprocess module, or one of its wrappers. subprocess : - subprocess.Popen - subprocess.call Example >> Issue : subprocess call - check for execution of untrusted input . Severity : Low Confidence : High Location : . / examples / subprocess_shell . py : 23 22 23 subprocess . check_output ( [ ' /bin/ls ' , ' -l ' ] ) 24 See Also: - https://security.openstack.org - https://docs.python.org/3/library/subprocess.html#frequently-used-arguments - https://security.openstack.org/guidelines/dg_avoid-shell-true.html - https://security.openstack.org/guidelines/dg_use-subprocess-securely.html 0.9.0","title":"Test for use of subprocess without shell equals true"},{"location":"S604/","text":"Python possesses many mechanisms to invoke an external executable. However, doing so may present a security issue if appropriate care is not taken to sanitize any user provided or variable input. This plugin test is part of a family of tests built to check for process spawning and warn appropriately. Specifically, this plugin test interrogates method calls for the presence of a keyword parameter shell equalling true. It is related to detection of shell injection issues and is intended to catch custom wrappers to vulnerable methods that may have been created. See also: ../plugins/linux_commands_wildcard_injection ../plugins/subprocess_popen_with_shell_equals_true ../plugins/subprocess_without_shell_equals_true ../plugins/start_process_with_no_shell ../plugins/start_process_with_a_shell ../plugins/start_process_with_partial_path Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. Specifically, this plugin excludes those functions listed under the subprocess section, these methods are tested in a separate specific test plugin and this exclusion prevents duplicate issue reporting. shell_injection : # Start a process using the subprocess module, or one of its wrappers. subprocess : [ subprocess.Popen , subprocess.call , subprocess.check_call , subprocess.check_output execute_with_timeout ] Example >> Issue: Function call with shell=True parameter identified, possible security issue. Severity: Medium Confidence: High Location: ./examples/subprocess_shell.py:9 8 pop('/bin/gcc --version', shell=True) 9 Popen('/bin/gcc --version', shell=True) 10 See Also: - https://security.openstack.org/guidelines/dg_avoid-shell-true.html - https://security.openstack.org/guidelines/dg_use-subprocess-securely.html 0.9.0","title":"Test for any function with shell equals true"},{"location":"S605/","text":"Python possesses many mechanisms to invoke an external executable. However, doing so may present a security issue if appropriate care is not taken to sanitize any user provided or variable input. This plugin test is part of a family of tests built to check for process spawning and warn appropriately. Specifically, this test looks for the spawning of a subprocess using a command shell. This type of subprocess invocation is dangerous as it is vulnerable to various shell injection attacks. Great care should be taken to sanitize all input in order to mitigate this risk. Calls of this type are identified by the use of certain commands which are known to use shells. Bandit will report a LOW severity warning. See also: ../plugins/linux_commands_wildcard_injection ../plugins/subprocess_without_shell_equals_true ../plugins/start_process_with_no_shell ../plugins/start_process_with_partial_path ../plugins/subprocess_popen_with_shell_equals_true Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This plugin specifically scans for methods listed in shell section. shell_injection : shell : - os.system - os.popen - os.popen2 - os.popen3 - os.popen4 - popen2.popen2 - popen2.popen3 - popen2.popen4 - popen2.Popen3 - popen2.Popen4 - commands.getoutput - commands.getstatusoutput Example >> Issue : Starting a process with a shell : check for injection . Severity : Low Confidence : Medium Location : examples / os_system . py : 3 2 3 os . system ( ' /bin/echo hi ' ) See Also: - https://security.openstack.org - https://docs.python.org/3/library/os.html#os.system - https://docs.python.org/3/library/subprocess.html#frequently-used-arguments - https://security.openstack.org/guidelines/dg_use-subprocess-securely.html 0.10.0","title":"Test for starting a process with a shell"},{"location":"S606/","text":"Python possesses many mechanisms to invoke an external executable. However, doing so may present a security issue if appropriate care is not taken to sanitize any user provided or variable input. This plugin test is part of a family of tests built to check for process spawning and warn appropriately. Specifically, this test looks for the spawning of a subprocess in a way that doesn't use a shell. Although this is generally safe, it maybe useful for penetration testing workflows to track where external system calls are used. As such a LOW severity message is generated. See also: ../plugins/linux_commands_wildcard_injection ../plugins/subprocess_without_shell_equals_true ../plugins/start_process_with_a_shell ../plugins/start_process_with_partial_path ../plugins/subprocess_popen_with_shell_equals_true Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This plugin specifically scans for methods listed in no_shell section. shell_injection : no_shell : - os.execl - os.execle - os.execlp - os.execlpe - os.execv - os.execve - os.execvp - os.execvpe - os.spawnl - os.spawnle - os.spawnlp - os.spawnlpe - os.spawnv - os.spawnve - os.spawnvp - os.spawnvpe - os.startfile Example >> Issue : [ start_process_with_no_shell ] Starting a process without a shell . Severity : Low Confidence : Medium Location : examples / os - spawn . py : 8 7 os . spawnv ( mode , path , args ) 8 os . spawnve ( mode , path , args , env ) 9 os . spawnvp ( mode , file , args ) See Also: - https://security.openstack.org - https://docs.python.org/3/library/os.html#os.system - https://docs.python.org/3/library/subprocess.html#frequently-used-arguments - https://security.openstack.org/guidelines/dg_use-subprocess-securely.html 0.10.0","title":"Test for starting a process with no shell"},{"location":"S607/","text":"Python possesses many mechanisms to invoke an external executable. If the desired executable path is not fully qualified relative to the filesystem root then this may present a potential security risk. In POSIX environments, the PATH environment variable is used to specify a set of standard locations that will be searched for the first matching named executable. While convenient, this behavior may allow a malicious actor to exert control over a system. If they are able to adjust the contents of the PATH variable, or manipulate the file system, then a bogus executable may be discovered in place of the desired one. This executable will be invoked with the user privileges of the Python process that spawned it, potentially a highly privileged user. This test will scan the parameters of all configured Python methods, looking for paths that do not start at the filesystem root, that is, do not have a leading '/' character. Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This test will scan parameters of all methods in all sections. Note that methods are fully qualified and de-aliased prior to checking. shell_injection : # Start a process using the subprocess module, or one of its wrappers. subprocess : - subprocess.Popen - subprocess.call # Start a process with a function vulnerable to shell injection. shell : - os.system - os.popen - popen2.Popen3 - popen2.Popen4 - commands.getoutput - commands.getstatusoutput # Start a process with a function that is not vulnerable to shell injection. no_shell : - os.execl - os.execle Example >> Issue : Starting a process with a partial executable path Severity : Low Confidence : High Location : ./ examples / partial_path_process . py : 3 2 from subprocess import Popen as pop 3 pop ( 'gcc --version' , shell = False ) See Also: - https://security.openstack.org - https://docs.python.org/3/library/os.html#process-management 0.13.0","title":"Test for starting a process with a partial path"},{"location":"S608/","text":"An SQL injection attack consists of insertion or \"injection\" of a SQL query via the input data given to an application. It is a very common attack vector. This plugin test looks for strings that resemble SQL statements that are involved in some form of string building operation. For example: \"SELECT %s FROM derp;\" % var \"SELECT thing FROM \" + tab \"SELECT \" + val + \" FROM \" + tab + ... \"SELECT {} FROM derp;\".format(var) f\"SELECT foo FROM bar WHERE id = {product}\" Unless care is taken to sanitize and control the input data when building such SQL statement strings, an injection attack becomes possible. If strings of this nature are discovered, a LOW confidence issue is reported. In order to boost result confidence, this plugin test will also check to see if the discovered string is in use with standard Python DBAPI calls execute or executemany . If so, a MEDIUM issue is reported. For example: cursor.execute(\"SELECT %s FROM derp;\" % var) Example >> Issue : Possible SQL injection vector through string - based query construction . Severity : Medium Confidence : Low Location : ./ examples / sql_statements_without_sql_alchemy . py : 4 3 query = \"DELETE FROM foo WHERE id = ' %s '\" % identifier 4 query = \"UPDATE foo SET value = 'b' WHERE id = ' %s '\" % identifier 5 See Also: - https://www.owasp.org/index.php/SQL_Injection - https://security.openstack.org/guidelines/dg_parameterize-database-queries.html 0.9.0","title":"Test for SQL injection"},{"location":"S609/","text":"Python provides a number of methods that emulate the behavior of standard Linux command line utilities. Like their Linux counterparts, these commands may take a wildcard \"*\" character in place of a file system path. This is interpreted to mean \"any and all files or folders\" and can be used to build partially qualified paths, such as \"/home/user/*\". The use of partially qualified paths may result in unintended consequences if an unexpected file or symlink is placed into the path location given. This becomes particularly dangerous when combined with commands used to manipulate file permissions or copy data off of a system. This test plugin looks for usage of the following commands in conjunction with wild card parameters: 'chown' 'chmod' 'tar' 'rsync' As well as any method configured in the shell or subprocess injection test configurations. Config Options: This plugin test shares a configuration with others in the same family, namely shell_injection . This configuration is divided up into three sections, subprocess , shell and no_shell . They each list Python calls that spawn subprocesses, invoke commands within a shell, or invoke commands without a shell (by replacing the calling process) respectively. This test will scan parameters of all methods in all sections. Note that methods are fully qualified and de-aliased prior to checking. shell_injection : # Start a process using the subprocess module, or one of its wrappers. subprocess : - subprocess.Popen - subprocess.call # Start a process with a function vulnerable to shell injection. shell : - os.system - os.popen - popen2.Popen3 - popen2.Popen4 - commands.getoutput - commands.getstatusoutput # Start a process with a function that is not vulnerable to shell injection. no_shell : - os.execl - os.execle Example >> Issue : Possible wildcard injection in call : subprocess . Popen Severity : High Confidence : Medium Location : . / examples / wildcard - injection . py : 8 7 o . popen2 ( ' /bin/chmod * ' ) 8 subp . Popen ( ' /bin/chown * ' , shell = True ) 9 >> Issue : subprocess call - check for execution of untrusted input . Severity : Low Confidence : High Location : . / examples / wildcard - injection . py : 11 10 # Not vulnerable to wildcard injection 11 subp . Popen ( ' /bin/rsync * ' ) 12 subp . Popen ( \" /bin/chmod * \" ) See Also: - https://security.openstack.org - https://en.wikipedia.org/wiki/Wildcard_character - http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt 0.9.0","title":"Test for use of wildcard injection"},{"location":"S610/","text":"See Also: - https://docs.djangoproject.com/en/dev/topics/security/#sql-injection-protection 1.5.0","title":"Potential SQL injection on extra function"},{"location":"S611/","text":"See Also: - https://docs.djangoproject.com/en/dev/topics/security/#sql-injection-protection 1.5.0","title":"Potential SQL injection on RawSQL function"},{"location":"S701/","text":"Jinja2 is a Python HTML templating system. It is typically used to build web applications, though appears in other places well, notably the Ansible automation system. When configuring the Jinja2 environment, the option to use autoescaping on input can be specified. When autoescaping is enabled, Jinja2 will filter input strings to escape any HTML content submitted via template variables. Without escaping HTML input the application becomes vulnerable to Cross Site Scripting (XSS) attacks. Unfortunately, autoescaping is False by default. Thus this plugin test will warn on omission of an autoescape setting, as well as an explicit setting of false. A HIGH severity warning is generated in either of these scenarios. Example >> Issue : Using jinja2 templates with autoescape = False is dangerous and can lead to XSS . Use autoescape = True to mitigate XSS vulnerabilities . Severity : High Confidence : High Location : ./ examples / jinja2_templating . py : 11 10 templateEnv = jinja2 . Environment ( autoescape = False , loader = templateLoader ) 11 Environment ( loader = templateLoader , 12 load = templateLoader , 13 autoescape = False ) 14 >> Issue : By default , jinja2 sets autoescape to False . Consider using autoescape = True or use the select_autoescape function to mitigate XSS vulnerabilities . Severity : High Confidence : High Location : ./ examples / jinja2_templating . py : 15 14 15 Environment ( loader = templateLoader , 16 load = templateLoader ) 17 18 Environment ( autoescape = select_autoescape ([ 'html' , 'htm' , 'xml' ]), 19 loader = templateLoader ) See Also: - `OWASP XSS <https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)>`_ - https://realpython.com/blog/python/primer-on-jinja-templating/ - http://jinja.pocoo.org/docs/dev/api/#autoescaping - https://security.openstack.org - https://security.openstack.org/guidelines/dg_cross-site-scripting-xss.html 0.10.0","title":"Test for not auto escaping in jinja2"},{"location":"S702/","text":"Mako is a Python templating system often used to build web applications. It is the default templating system used in Pylons and Pyramid. Unlike Jinja2 (an alternative templating system), Mako has no environment wide variable escaping mechanism. Because of this, all input variables must be carefully escaped before use to prevent possible vulnerabilities to Cross Site Scripting (XSS) attacks. Example >> Issue : Mako templates allow HTML / JS rendering by default and are inherently open to XSS attacks . Ensure variables in all templates are properly sanitized via the 'n' , 'h' or 'x' flags ( depending on context ) . For example , to HTML escape the variable 'data' do $ { data | h } . Severity : Medium Confidence : High Location : ./ examples / mako_templating . py : 10 9 10 mako . template . Template ( \"hern\" ) 11 template . Template ( \"hern\" ) See Also: - http://www.makotemplates.org/ - `OWASP XSS <https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)>`_ - https://security.openstack.org - https://security.openstack.org/guidelines/dg_cross-site-scripting-xss.html 0.10.0","title":"Test for use of mako templates"},{"location":"S703/","text":"See Also: - https://docs.djangoproject.com/en/dev/topics/security/#cross-site-scripting-xss-protection - https://docs.djangoproject.com/en/dev/ref/utils/#module-django.utils.safestring - https://docs.djangoproject.com/en/dev/ref/utils/#django.utils.html.format_html 1.5.0","title":"Potential XSS on mark\\_safe function"},{"location":"flake8-bugbear/index.html","text":"","title":"bugbear"},{"location":"flake8-bugbear/16.7.1/index.html","text":"","title":"16.7.1"},{"location":"flake8-bugbear/16.7.1/B001.html","text":"B001: Do not use bare except: , it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"B001: Do not use bare except:, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"flake8-bugbear/16.7.1/B002.html","text":"B002: Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"B002: Python does not support the unary prefix increment"},{"location":"flake8-bugbear/16.7.1/B301.html","text":"B301: Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"B301: Python 3 does not include .iter* methods on dictionaries"},{"location":"flake8-bugbear/16.7.1/B302.html","text":"B302: Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"B302: Python 3 does not include .view* methods on dictionaries"},{"location":"flake8-bugbear/16.7.1/B303.html","text":"B303: metaclass does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"B303: __metaclass__ does nothing on Python 3"},{"location":"flake8-bugbear/16.7.1/B304.html","text":"B304: sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"B304: sys.maxint is not a thing on Python 3"},{"location":"flake8-bugbear/16.7.1/B305.html","text":"B305: .next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":"B305: .next() is not a thing on Python 3"},{"location":"flake8-bugbear/16.7.1/B306.html","text":"B306: BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"B306: BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"flake8-bugbear/17.2.0/index.html","text":"","title":"17.2.0"},{"location":"flake8-bugbear/17.2.0/B001.html","text":"Do not use bare except: , it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"Do not use bare except:, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"flake8-bugbear/17.2.0/B002.html","text":"Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"Python does not support the unary prefix increment"},{"location":"flake8-bugbear/17.2.0/B003.html","text":"Assigning to os.environ doesn't clear the environment. Subprocesses are going to see outdated variables, in disagreement with the current process. Use os.environ.clear() or the env= argument to Popen.","title":"Assigning to os.environ doesn't clear the environment"},{"location":"flake8-bugbear/17.2.0/B004.html","text":"Using hasattr(x, '__call__') to test if x is callable is unreliable. If x implements custom __getattr__ or its __call__ is itself not callable, you might get misleading results. Use callable(x) for consistent results.","title":"Using hasattr(x, '__call__') to test if x is callable is unreliable"},{"location":"flake8-bugbear/17.2.0/B005.html","text":"Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace() or regular expressions to remove string fragments.","title":"Using .strip() with multi-character strings is misleading the reader"},{"location":"flake8-bugbear/17.2.0/B006.html","text":"Do not use mutable data structures for argument defaults. All calls reuse one instance of that data structure, persisting changes between them.","title":"Do not use mutable data structures for argument defaults"},{"location":"flake8-bugbear/17.2.0/B007.html","text":"Loop control variable {!r} not used within the loop body. If this is intended, start the name with an underscore.","title":"Loop control variable {!r} not used within the loop body"},{"location":"flake8-bugbear/17.2.0/B301.html","text":"Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"Python 3 does not include .iter* methods on dictionaries"},{"location":"flake8-bugbear/17.2.0/B302.html","text":"Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"Python 3 does not include .view* methods on dictionaries"},{"location":"flake8-bugbear/17.2.0/B303.html","text":"__metaclass__ does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"__metaclass__ does nothing on Python 3"},{"location":"flake8-bugbear/17.2.0/B304.html","text":"sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"sys.maxint is not a thing on Python 3"},{"location":"flake8-bugbear/17.2.0/B305.html","text":".next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":".next() is not a thing on Python 3"},{"location":"flake8-bugbear/17.2.0/B306.html","text":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"flake8-bugbear/17.2.0/B901.html","text":"Using yield together with return x . Use native async def coroutines or put a # noqa comment on this line if this was intentional.","title":"Using yield together with return x"},{"location":"flake8-bugbear/17.2.0/B902.html","text":"Invalid first argument {} used for {} method. Use the canonical first argument name in methods, i.e. {}.","title":"Invalid first argument _ used for _ method"},{"location":"flake8-bugbear/17.2.0/B950.html","text":"line too long ({} > {} characters)","title":"line too long (_ > _ characters)"},{"location":"flake8-bugbear/18.2.0/index.html","text":"","title":"18.2.0"},{"location":"flake8-bugbear/18.2.0/B001.html","text":"Do not use bare except: , it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"Do not use bare except:, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"flake8-bugbear/18.2.0/B002.html","text":"Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"Python does not support the unary prefix increment"},{"location":"flake8-bugbear/18.2.0/B003.html","text":"Assigning to os.environ doesn't clear the environment. Subprocesses are going to see outdated variables, in disagreement with the current process. Use os.environ.clear() or the env= argument to Popen.","title":"Assigning to os.environ doesn't clear the environment"},{"location":"flake8-bugbear/18.2.0/B004.html","text":"Using hasattr(x, '__call__') to test if x is callable is unreliable. If x implements custom __getattr__ or its __call__ is itself not callable, you might get misleading results. Use callable(x) for consistent results.","title":"Using hasattr(x, '__call__') to test if x is callable is unreliable"},{"location":"flake8-bugbear/18.2.0/B005.html","text":"Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace() or regular expressions to remove string fragments.","title":"Using .strip() with multi-character strings is misleading the reader"},{"location":"flake8-bugbear/18.2.0/B006.html","text":"Do not use mutable data structures for argument defaults. All calls reuse one instance of that data structure, persisting changes between them.","title":"Do not use mutable data structures for argument defaults"},{"location":"flake8-bugbear/18.2.0/B007.html","text":"Loop control variable {!r} not used within the loop body. If this is intended, start the name with an underscore.","title":"Loop control variable {!r} not used within the loop body"},{"location":"flake8-bugbear/18.2.0/B008.html","text":"Do not perform calls in argument defaults. The call is performed only once at function definition time. All calls to your function will reuse the result of that definition-time call. If this is intended, assign the function call to a module-level variable and use that variable as a default value.","title":"Do not perform calls in argument defaults"},{"location":"flake8-bugbear/18.2.0/B301.html","text":"Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"Python 3 does not include .iter* methods on dictionaries"},{"location":"flake8-bugbear/18.2.0/B302.html","text":"Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"Python 3 does not include .view* methods on dictionaries"},{"location":"flake8-bugbear/18.2.0/B303.html","text":"__metaclass__ does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"__metaclass__ does nothing on Python 3"},{"location":"flake8-bugbear/18.2.0/B304.html","text":"sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"sys.maxint is not a thing on Python 3"},{"location":"flake8-bugbear/18.2.0/B305.html","text":".next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":".next() is not a thing on Python 3"},{"location":"flake8-bugbear/18.2.0/B306.html","text":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"flake8-bugbear/18.2.0/B901.html","text":"Using yield together with return x . Use native async def coroutines or put a # noqa comment on this line if this was intentional.","title":"Using yield together with return x"},{"location":"flake8-bugbear/18.2.0/B902.html","text":"Invalid first argument {} used for {} method. Use the canonical first argument name in methods, i.e. {}.","title":"Invalid first argument _ used for _ method"},{"location":"flake8-bugbear/18.2.0/B903.html","text":"Data class should either be immutable or use slots to save memory. Use collections.namedtuple to generate an immutable class, or enumerate the attributes in a slot declaration in the class to leave attributes mutable.","title":"Data class should either be immutable or use __slots__ to save memory"},{"location":"flake8-bugbear/18.2.0/B950.html","text":"line too long ({} > {} characters)","title":"line too long (_ > _ characters)"},{"location":"flake8-bugbear/19.3.0/index.html","text":"","title":"19.3.0"},{"location":"flake8-bugbear/19.3.0/B001.html","text":"Do not use bare except: , it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"Do not use bare except:, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"flake8-bugbear/19.3.0/B002.html","text":"Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"Python does not support the unary prefix increment"},{"location":"flake8-bugbear/19.3.0/B003.html","text":"Assigning to os.environ doesn't clear the environment. Subprocesses are going to see outdated variables, in disagreement with the current process. Use os.environ.clear() or the env= argument to Popen.","title":"Assigning to os.environ doesn't clear the environment"},{"location":"flake8-bugbear/19.3.0/B004.html","text":"Using hasattr(x, '__call__') to test if x is callable is unreliable. If x implements custom __getattr__ or its __call__ is itself not callable, you might get misleading results. Use callable(x) for consistent results.","title":"Using hasattr(x, '__call__') to test if x is callable is unreliable"},{"location":"flake8-bugbear/19.3.0/B005.html","text":"Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace() or regular expressions to remove string fragments.","title":"Using .strip() with multi-character strings is misleading the reader"},{"location":"flake8-bugbear/19.3.0/B006.html","text":"Do not use mutable data structures for argument defaults. All calls reuse one instance of that data structure, persisting changes between them.","title":"Do not use mutable data structures for argument defaults"},{"location":"flake8-bugbear/19.3.0/B007.html","text":"Loop control variable {!r} not used within the loop body. If this is intended, start the name with an underscore.","title":"Loop control variable {!r} not used within the loop body"},{"location":"flake8-bugbear/19.3.0/B008.html","text":"Do not perform calls in argument defaults. The call is performed only once at function definition time. All calls to your function will reuse the result of that definition-time call. If this is intended, assign the function call to a module-level variable and use that variable as a default value.","title":"Do not perform calls in argument defaults"},{"location":"flake8-bugbear/19.3.0/B009.html","text":"Do not call getattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call getattr with a constant attribute value, it is not any safer than normal property access."},{"location":"flake8-bugbear/19.3.0/B010.html","text":"Do not call setattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call setattr with a constant attribute value, it is not any safer than normal property access."},{"location":"flake8-bugbear/19.3.0/B011.html","text":"Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().","title":"Do not call assert False since python -O removes these calls"},{"location":"flake8-bugbear/19.3.0/B301.html","text":"Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"Python 3 does not include .iter* methods on dictionaries"},{"location":"flake8-bugbear/19.3.0/B302.html","text":"Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"Python 3 does not include .view* methods on dictionaries"},{"location":"flake8-bugbear/19.3.0/B303.html","text":"__metaclass__ does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"__metaclass__ does nothing on Python 3"},{"location":"flake8-bugbear/19.3.0/B304.html","text":"sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"sys.maxint is not a thing on Python 3"},{"location":"flake8-bugbear/19.3.0/B305.html","text":".next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":".next() is not a thing on Python 3"},{"location":"flake8-bugbear/19.3.0/B306.html","text":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"flake8-bugbear/19.3.0/B901.html","text":"Using yield together with return x . Use native async def coroutines or put a # noqa comment on this line if this was intentional.","title":"Using yield together with return x"},{"location":"flake8-bugbear/19.3.0/B902.html","text":"Invalid first argument {} used for {} method. Use the canonical first argument name in methods, i.e. {}.","title":"Invalid first argument _ used for _ method"},{"location":"flake8-bugbear/19.3.0/B903.html","text":"Data class should either be immutable or use slots to save memory. Use collections.namedtuple to generate an immutable class, or enumerate the attributes in a slot declaration in the class to leave attributes mutable.","title":"Data class should either be immutable or use __slots__ to save memory"},{"location":"flake8-bugbear/19.3.0/B950.html","text":"line too long ({} > {} characters)","title":"line too long (_ > _ characters)"},{"location":"flake8-bugbear/20.1.0/index.html","text":"","title":"20.1.0"},{"location":"flake8-bugbear/20.1.0/B001.html","text":"Do not use bare except: , it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"Do not use bare except:, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"flake8-bugbear/20.1.0/B002.html","text":"Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"Python does not support the unary prefix increment"},{"location":"flake8-bugbear/20.1.0/B003.html","text":"Assigning to os.environ doesn't clear the environment. Subprocesses are going to see outdated variables, in disagreement with the current process. Use os.environ.clear() or the env= argument to Popen.","title":"Assigning to os.environ doesn't clear the environment"},{"location":"flake8-bugbear/20.1.0/B004.html","text":"Using hasattr(x, '__call__') to test if x is callable is unreliable. If x implements custom __getattr__ or its __call__ is itself not callable, you might get misleading results. Use callable(x) for consistent results.","title":"Using hasattr(x, '__call__') to test if x is callable is unreliable"},{"location":"flake8-bugbear/20.1.0/B005.html","text":"Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace() or regular expressions to remove string fragments.","title":"Using .strip() with multi-character strings is misleading the reader"},{"location":"flake8-bugbear/20.1.0/B006.html","text":"Do not use mutable data structures for argument defaults. They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.","title":"Do not use mutable data structures for argument defaults"},{"location":"flake8-bugbear/20.1.0/B007.html","text":"Loop control variable {!r} not used within the loop body. If this is intended, start the name with an underscore.","title":"Loop control variable {!r} not used within the loop body"},{"location":"flake8-bugbear/20.1.0/B008.html","text":"Do not perform function calls in argument defaults. The call is performed only once at function definition time. All calls to your function will reuse the result of that definition-time function call. If this is intended, assign the function call to a module-level variable and use that variable as a default value.","title":"Do not perform function calls in argument defaults"},{"location":"flake8-bugbear/20.1.0/B009.html","text":"Do not call getattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call getattr with a constant attribute value, it is not any safer than normal property access."},{"location":"flake8-bugbear/20.1.0/B010.html","text":"Do not call setattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call setattr with a constant attribute value, it is not any safer than normal property access."},{"location":"flake8-bugbear/20.1.0/B011.html","text":"Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().","title":"Do not call assert False since python -O removes these calls"},{"location":"flake8-bugbear/20.1.0/B012.html","text":"return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.","title":"return/continue/break inside finally blocks cause exceptions to be silenced"},{"location":"flake8-bugbear/20.1.0/B301.html","text":"Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"Python 3 does not include .iter* methods on dictionaries"},{"location":"flake8-bugbear/20.1.0/B302.html","text":"Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"Python 3 does not include .view* methods on dictionaries"},{"location":"flake8-bugbear/20.1.0/B303.html","text":"__metaclass__ does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"__metaclass__ does nothing on Python 3"},{"location":"flake8-bugbear/20.1.0/B304.html","text":"sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"sys.maxint is not a thing on Python 3"},{"location":"flake8-bugbear/20.1.0/B305.html","text":".next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":".next() is not a thing on Python 3"},{"location":"flake8-bugbear/20.1.0/B306.html","text":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"flake8-bugbear/20.1.0/B901.html","text":"Using yield together with return x . Use native async def coroutines or put a # noqa comment on this line if this was intentional.","title":"Using yield together with return x"},{"location":"flake8-bugbear/20.1.0/B902.html","text":"Invalid first argument {} used for {} method. Use the canonical first argument name in methods, i.e. {}.","title":"Invalid first argument _ used for _ method"},{"location":"flake8-bugbear/20.1.0/B903.html","text":"Data class should either be immutable or use slots to save memory. Use collections.namedtuple to generate an immutable class, or enumerate the attributes in a slot declaration in the class to leave attributes mutable.","title":"Data class should either be immutable or use __slots__ to save memory"},{"location":"flake8-bugbear/20.1.0/B950.html","text":"line too long ({} > {} characters)","title":"line too long (_ > _ characters)"},{"location":"flake8-bugbear/21.4.3/index.html","text":"","title":"21.4.3"},{"location":"B001/","text":"Do not use {}, it also catches unexpected events like memory errors, interrupts, system exit, and so on. Prefer except Exception: . If you're sure what you're doing, be explicit and write except BaseException: .","title":"Do not use _, it also catches unexpected events like memory errors, interrupts, system exit, and so on"},{"location":"B002/","text":"Python does not support the unary prefix increment. Writing ++n is equivalent to +(+(n)), which equals n. You meant n += 1.","title":"Python does not support the unary prefix increment"},{"location":"B003/","text":"Assigning to os.environ doesn't clear the environment. Subprocesses are going to see outdated variables, in disagreement with the current process. Use os.environ.clear() or the env= argument to Popen.","title":"Assigning to os.environ doesn't clear the environment"},{"location":"B004/","text":"Using hasattr(x, '__call__') to test if x is callable is unreliable. If x implements custom __getattr__ or its __call__ is itself not callable, you might get misleading results. Use callable(x) for consistent results.","title":"Using hasattr(x, '__call__') to test if x is callable is unreliable"},{"location":"B005/","text":"Using .strip() with multi-character strings is misleading the reader. It looks like stripping a substring. Move your character set to a constant if this is deliberate. Use .replace() or regular expressions to remove string fragments.","title":"Using .strip() with multi-character strings is misleading the reader"},{"location":"B006/","text":"Do not use mutable data structures for argument defaults. They are created during function definition time. All calls to the function reuse this one instance of that data structure, persisting changes between them.","title":"Do not use mutable data structures for argument defaults"},{"location":"B007/","text":"Loop control variable {!r} not used within the loop body. If this is intended, start the name with an underscore.","title":"Loop control variable {!r} not used within the loop body"},{"location":"B008/","text":"Do not perform function calls in argument defaults. The call is performed only once at function definition time. All calls to your function will reuse the result of that definition-time function call. If this is intended, assign the function call to a module-level variable and use that variable as a default value.","title":"Do not perform function calls in argument defaults"},{"location":"B009/","text":"Do not call getattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call getattr with a constant attribute value, it is not any safer than normal property access."},{"location":"B010/","text":"Do not call setattr with a constant attribute value, it is not any safer than normal property access.","title":"Do not call setattr with a constant attribute value, it is not any safer than normal property access."},{"location":"B011/","text":"Do not call assert False since python -O removes these calls. Instead callers should raise AssertionError().","title":"Do not call assert False since python -O removes these calls"},{"location":"B012/","text":"return/continue/break inside finally blocks cause exceptions to be silenced. Exceptions should be silenced in except blocks. Control statements can be moved outside the finally block.","title":"return/continue/break inside finally blocks cause exceptions to be silenced"},{"location":"B013/","text":"A length-one tuple literal is redundant. Write except {0}: instead of except ({0},): .","title":"A length-one tuple literal is redundant"},{"location":"B014/","text":"Redundant exception types in except ({0}){1}: . Write except {2}{1}: , which catches exactly the same exceptions.","title":"Redundant exception types in except ({0}){1}:"},{"location":"B015/","text":"Pointless comparison. This comparison does nothing but waste CPU instructions. Either prepend assert or remove it.","title":"Pointless comparison"},{"location":"B016/","text":"Cannot raise a literal. Did you intend to return it or raise an Exception?","title":"Cannot raise a literal"},{"location":"B017/","text":"assertRaises(Exception): should be considered evil. It can lead to your test passing even if the code being tested is never executed due to a typo. Either assert for a more specific exception (builtin or custom), use assertRaisesRegex, or use the context manager form of assertRaises.","title":"assertRaises(Exception): should be considered evil"},{"location":"B301/","text":"Python 3 does not include .iter* methods on dictionaries. Remove the iter prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.iter* or future.utils.iter* .","title":"Python 3 does not include .iter* methods on dictionaries"},{"location":"B302/","text":"Python 3 does not include .view* methods on dictionaries. Remove the view prefix from the method name. For Python 2 compatibility, prefer the Python 3 equivalent unless you expect the size of the container to be large or unbounded. Then use six.view* or future.utils.view* .","title":"Python 3 does not include .view* methods on dictionaries"},{"location":"B303/","text":"__metaclass__ does nothing on Python 3. Use class MyClass(BaseClass, metaclass=...) . For Python 2 compatibility, use six.add_metaclass .","title":"__metaclass__ does nothing on Python 3"},{"location":"B304/","text":"sys.maxint is not a thing on Python 3. Use sys.maxsize .","title":"sys.maxint is not a thing on Python 3"},{"location":"B305/","text":".next() is not a thing on Python 3. Use the next() builtin. For Python 2 compatibility, use six.next() .","title":".next() is not a thing on Python 3"},{"location":"B306/","text":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3. Use str(e) to access the user-readable message. Use e.args to access arguments passed to the exception.","title":"BaseException.message has been deprecated as of Python 2.6 and is removed in Python 3"},{"location":"B901/","text":"Using yield together with return x . Use native async def coroutines or put a # noqa comment on this line if this was intentional.","title":"Using yield together with return x"},{"location":"B902/","text":"Invalid first argument {} used for {} method. Use the canonical first argument name in methods, i.e. {}.","title":"Invalid first argument _ used for _ method"},{"location":"B903/","text":"Data class should either be immutable or use slots to save memory. Use collections.namedtuple to generate an immutable class, or enumerate the attributes in a slot declaration in the class to leave attributes mutable.","title":"Data class should either be immutable or use __slots__ to save memory"},{"location":"B950/","text":"line too long ({} > {} characters)","title":"line too long (_ > _ characters)"},{"location":"meta/index.html","text":"Some stuff about flake8.codes website is here.","title":"Meta"},{"location":"meta/classes.html","text":"Macro Rendering Error AttributeError : does not have the attribute 'cgi' Traceback ( most recent call last ): File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/mkdocs_macros/plugin.py\" , line 434 , in render return md_template . render ( ** page_variables ) File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/jinja2/environment.py\" , line 1304 , in render self . environment . handle_exception () File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/jinja2/environment.py\" , line 925 , in handle_exception raise rewrite_traceback_stack ( source = source ) File \"<template>\" , line 1 , in top - level template code File \"/home/runner/work/flake8.codes/flake8.codes/flake8_codes/macros.py\" , line 100 , in graph with patch ( 'rdflib.tools.rdf2dot.cgi' , html ): File \"/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/unittest/mock.py\" , line 1393 , in __enter__ original , local = self . get_original () File \"/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/unittest/mock.py\" , line 1366 , in get_original raise AttributeError ( AttributeError : < module 'rdflib.tools.rdf2dot' from '/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/rdflib/tools/rdf2dot.py' > does not have the attribute 'cgi'","title":"Foundational Classes"},{"location":"meta/classes.html#macro-rendering-error","text":"AttributeError : does not have the attribute 'cgi' Traceback ( most recent call last ): File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/mkdocs_macros/plugin.py\" , line 434 , in render return md_template . render ( ** page_variables ) File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/jinja2/environment.py\" , line 1304 , in render self . environment . handle_exception () File \"/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/jinja2/environment.py\" , line 925 , in handle_exception raise rewrite_traceback_stack ( source = source ) File \"<template>\" , line 1 , in top - level template code File \"/home/runner/work/flake8.codes/flake8.codes/flake8_codes/macros.py\" , line 100 , in graph with patch ( 'rdflib.tools.rdf2dot.cgi' , html ): File \"/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/unittest/mock.py\" , line 1393 , in __enter__ original , local = self . get_original () File \"/opt/hostedtoolcache/Python/3.8.12/x64/lib/python3.8/unittest/mock.py\" , line 1366 , in get_original raise AttributeError ( AttributeError : < module 'rdflib.tools.rdf2dot' from '/home/runner/work/flake8.codes/flake8.codes/.venv/lib/python3.8/site-packages/rdflib/tools/rdf2dot.py' > does not have the attribute 'cgi'","title":"Macro Rendering Error"},{"location":"meta/generation.html","text":"Convert a lump of goo and data into a semantic graph. I believe that this class should be transformed into Iolanta class, and factored out of octadocs application into its own package. graph : ConjunctiveGraph cached property writable Generate and instantiate the RDFLib graph instance. namespaces cached property writable Join the provided custom namespaces with the defaults. Returns all namespaces registered with this Octiron instance. apply_inference ( self ) Apply inference rules after graph has been updated from files. clear_named_graph ( self , local_iri ) Remove all triples in the specified named graph. create_file_cache_status ( self , local_iri , last_modification_timestamp_on_disk ) Determine caching status of a file. get_context_per_directory ( self , directory ) Find context file per disk directory. get_loader_class_for_path ( self , path ) Based on file path, determine the loader to use. query ( self , query_text , ** kwargs ) Run SPARQL SELECT, CONSTRUCT, or ASK query. update_from_file ( self , path , local_iri , named_contexts = None , global_url = None ) Update the graph from file determined by given path.","title":"Generation"},{"location":"meta/decisions/serve-violations-from-root-directory.html","text":"Context I would like to have WPS123 code description from the latest version of wemake-python-styleguide available not only as https://flake8.codes/wemake-python-styleguide/0.15.1/violations/WPS123/ but also as https://flake8.codes/WPS123/. I feel this would greatly improve the usability of the tool, especially if to create a custom search engine for it in your browser. Solutions Somehow, a file at docs/wemake-python-styleguide/0.15.1/violations/WPS123.md must be served as docs/WPS123.md in addition to its original serving. Choice Evaluation Copy the original file to the root directory Having such a mess of Markdown files in the docs directory would not be a good idea. A lot of duplication, wasted disk space, and ugly diffs. Does not fit any kind of aesthetic standard. Use mkdocs-macros to hook into MkDocs on_files event The on_files hook is not supported. \u21aa Create an ad-hoc MkDocs plugin to hook into on_files event This is the decision. \u2705","title":"Serve violations from root of the website"},{"location":"meta/decisions/site-is-slow.html","text":"mkdocs build or mkdocs serve command takes more than 15 minutes to complete building the site. This happens when we generate all available versions for wemake-python-styleguide and flake8-bugbear packages. That means the docs directory has almost 6900 Markdown files. The MkDocs build process itself (if to turn off octadocs and mkdocs-macros plugins) takes about 5 minutes. Obviously, the remaining 10 minutes are occupied by Octadocs to load the graph and execute queries, and by Jinja2 to render macros in pages.","title":"flake8.codes is slow to build"},{"location":"meta/decisions/inference-queries-order/frontmatter.html","text":"For example: depends-on : some_other_query.sparql By these dependencies, the system would deduce the proper order of the queries; then, it would run the queries in the specified order.","title":"Use YAML front matter section for SPARQL files"},{"location":"meta/decisions/inference-queries-order/hook-resolves-inference-order.html","text":"The order of queries in Python code is easy to manage and debug - that's what a general purpose programming language is about. No need to remember special case logic like depends-on , or rewrite SPARQL queries into a highly specialized serialization.","title":"Hook resolves inference order"},{"location":"meta/decisions/inference-queries-order/hook-resolves-slowness.html","text":"One of the operations which takes too long is the second application of OWL RL after SPARQL queries. If that is not necessary (for example, because these queries do not add any triples that cause OWL RL to infer other triples) - then we can omit it. That can save us a few minutes of generation time.","title":"Hook resolves slowness"},{"location":"meta/decisions/inference-queries-order/hook.html","text":"This should be another hook in mkdocs-macros-plugin . In a pluglet, we will create a def on_before_build() function which will then be able to run arbitrary Python code, including calls to SPARQL.","title":"Create a Python hook to run before site is going to build"},{"location":"meta/decisions/inference-queries-order/inference-queries-order-matters.html","text":"Currently, we have SPARQL files in inference directory which are automatically executed when site is being built. We use them heavily to do subject domain specific reasoning (for example, to assign templates to pages). We got into trouble when the number of inference queries grew to a dozen, and we found there are dependencies between them. One query must run before the other, otherwise nothing works. This has proven to be notoriously hard to debug.","title":"Inference queries order matters"},{"location":"meta/decisions/inference-queries-order/sparql-is-not-enough.html","text":"Inference is not always easy to do with raw SPARQL. I am currently struggling to express a very simple transformation of data in SPARQL \u2014 it either doesn't work at all or has to be a very complex query with a few nesting levels. This is not what we'd want to see. To the contrary, if I could run a SPARQL query, preprocess results in Python and then do another SPARQL query, this would have been simple, readable and easy to debug.","title":"SPARQL is not enough for inference queries"},{"location":"wemake-python-styleguide/index.html","text":"","title":"wemake-python-styleguide"},{"location":"wemake-python-styleguide/0.10.0/index.html","text":"","title":"0.10.0"},{"location":"wemake-python-styleguide/0.10.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.10.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.10.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.10.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.10.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.10.0/constants/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.10.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.10.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.10.0/constants/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.10.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is hidden inside countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits. Then we forbid to use this bad code forever. So, this error will never return to our codebase.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS400.html","text":"Restricts to use several control (or magic) comments. We do not allow to use: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast Reasoning We cover several different use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can already use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow to use # type: ignore comment. Since sometimes it is totally required. Example # Correct : type = MyClass . get_type () # noqa : A001 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS401.html","text":"Forbids to use empty doc comments ( #: ). Reasoning Doc comments are used to provide a documentation. But supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment. Or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS402.html","text":"Forbids to use too many # noqa comments. We count it on a per-module basis. We use MAX_NOQA_COMMENTS as a default value. Reasoning Having too many # noqa comments make your code less readable and clearly indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS403.html","text":"Forbids to use too many # pragma: no cover comments. We count it on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments clearly indicates that there's something wrong with it. Moreover, it makes your tests useless, since they do not cover a big partion of your code. Solution Refactor your code to much the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS410.html","text":"Forbids to have some module level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use pkg_resources if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS411.html","text":"Forbids to have empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS412.html","text":"Forbids to have logic inside __init__ module. Reasoning If you have logic inside the __init__ module it means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic into the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow to have some contents inside the __init__ module: comments, since they are dropped before AST comes in play docs string, because sometimes it is required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case this rule can be configured. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS413.html","text":"Forbids to use __getaddr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS420.html","text":"Forbids to use some python keywords. Reasoning Using some keywords generally gives you more pain that relieve. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no usecase for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale. And leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS421.html","text":"Forbids to call some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid to use them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS422.html","text":"Forbids to use __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS423.html","text":"Forbids to use NotImplemented error. Reasoning These two violations look so similar. But, these violations have different use cases. Use cases of NotImplemented is too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See Also: https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS424.html","text":"Forbids to use BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See Also: https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS425.html","text":"Forbids to pass booleans as non-keyword parameters. Reasoning Passing boolean as regular positional parameters is very non-descriptive. It is almost impossible to tell, what does this parameter means. And you almost always have to look up the implementation to tell what is going on. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UsersRepository.update(cache=True) # Wrong: UsersRepository.update(True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS426.html","text":"Forbids to subclass lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS427.html","text":"Forbids to shadow class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS430.html","text":"Forbids to have nested functions. Reasoning Nesting functions is a bad practice. It is hard to test them, it is hard then to separate them. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures. Until you need them for decorators or factories. We also disallow to nest lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS431.html","text":"Forbids to use nested classes. Reasoning Nested classes are really hard to manage. You can not even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use different design (or metaclasses). See NESTED_CLASSES_WHITELIST for the full list of whitelisted names. Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS432.html","text":"Forbids to use magic numbers in your code. What we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers actually mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS433.html","text":"Forbids to use @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS434.html","text":"Forbids to use some magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS435.html","text":"Forbids to have nested imports in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look like. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS436.html","text":"Forbids to use else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS437.html","text":"Forbids to use finally in try block without except block. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS438.html","text":"Forbids to assign variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0","title":"Found reassigning variable to itself"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS439.html","text":"Forbids to use yield inside of __init__ method. Reasoning __init__ should be used to initialize new objects. It shouldn't yield anything because it should return None by the convention. Example # Correct: class Example(object): def __init__(self): self._public_items_count = 0 # Wrong: class Example(object): def __init__(self): yield 10 0.3.0","title":"Found yield inside __init__ method"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS440.html","text":"Forbids to import protected modules. Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import anything from protected modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass from some.module import _protected 0.3.0","title":"Found protected module import"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS441.html","text":"Forbids to use protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS442.html","text":"Forbids to use lambda inside loops. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS443.html","text":"Forbids to have unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we can not cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your code base at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have. Or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS444.html","text":"Forbids to have statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error. Or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS445.html","text":"Forbids to have multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grown pretty long. And you will not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS446.html","text":"Forbids to have tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique. So, do not use it. Solution Use unpacking with only variables, not any other entities. Example # Correct: first, second = some() # Wrong: first, some_dict['alias'] = some() 0.6.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS447.html","text":"Forbids to have the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Other one will always be ignored. So, that is clearly an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS448.html","text":"Forbids to have yield keyword inside comprehensions. Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in a foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords. Or create a separate generator function. Example # Wrong : >>> list (( yield letter ) for letter in ' ab ' ) [ ' a ' , None , ' b ' , None ] >>> list ( [ ( yield letter ) for letter in ' ab ' ] ) [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS449.html","text":"Forbids to have duplicate items in set literals. Reasoning When you explicitly put duplicate items in set literals it just does not make any sense. Since set can not contain duplicate items and they will be removed anyway. Solution Remove the duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations containers: lists, dicts, tuples, sets 0.7.0","title":"Found non-unique item in set literal: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS450.html","text":"Forbids to have duplicate items in set literals. Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS451.html","text":"Forbids to have simplifiable if conditions. Reasoning This complex construction can cause frustration among other developers. It is longer, more verbose, and more complex. Solution Use bool() to convert test values to boolean values. Or just leave it as it is in case when your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS452.html","text":"Forbids to use incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS453.html","text":"Forbids to have methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so can not access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS454.html","text":"Forbids to have anything else than a class as a base class. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS455.html","text":"Forbids to have incorrect __slots__ definition. Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = Test . __slots__ + ( 'child' ,) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS456.html","text":"Forbids to use super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS457.html","text":"Forbids to use useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS458.html","text":"Forbids to use multiple return path with try / except case. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be actually returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS459.html","text":"Forbids to use complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or http requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS460.html","text":"Forbids to use anything rather than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' pepson ' ] in database . people () : ... 0.8.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS461.html","text":"Forbids to use anything rather than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS462.html","text":"Forbids to use direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS463.html","text":"Forbids to use negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... # Wrong : if not some : ... else : ... 0.8.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS464.html","text":"Forbids to use nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS465.html","text":"Forbids multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has. And it decreases readability of the code. Solution Divide multiline conditions to some if condition. Or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS466.html","text":"Forbids mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List , and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS467.html","text":"Forbids to define useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS468.html","text":"Forbids to have unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS469.html","text":"Forbids to use the same logical conditions in one expression. Reasoning Using the same name in logical condition more that once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicating condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS470.html","text":"Forbids to use not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS471.html","text":"Forbids to heterogenous operators in one compare. Note, that we allow to mix > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0","title":"Found heterogenous compare"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS472.html","text":"Forbids to nest ternary expressions in some places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS473.html","text":"Forbids to use in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS474.html","text":"Forbids to multiple isinstance calls with the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.10.0/violations/best_practices/WPS475.html","text":"Forbids to multiple isinstance calls with tuples of a single item. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single varaible. Example # Correct: isinstance(some, (int, float)) isisntance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated.","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS200.html","text":"Forbids to have modules with complex lines. We are using Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measuring the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS201.html","text":"Forbids to have modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS202.html","text":"Forbids to have many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any differences between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS210.html","text":"Forbids to have too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will find troubles to understand what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS211.html","text":"Forbids to have too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it shows that it is required to refactor this piece of code. It also indicates that function does too many things at once. Solution Split function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS212.html","text":"Forbids placing too many return statements into the function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS213.html","text":"Forbids putting too many expressions in a unit of code. Reasoning When there are too many expressions it means that this specific function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS214.html","text":"Forbids to have many methods in a single class. Reasoning Having too many methods might lead to the \"God object\". This kind of objects can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes. Then use composition or inheritance to refactor your code. This will protect you from \"God object\" anti-pattern. We do not make any difference between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you try to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you try to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into multiple ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS217.html","text":"Forbids placing too many await expressions into the function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where are we and what is going on. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS220.html","text":"Forbids nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS221.html","text":"Forbids to have complex lines. We are using Jones Complexity algorithm to count complexity. What is Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS222.html","text":"Forbids to have conditions with too many logical operators. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS223.html","text":"Forbids to use many elif branches. Reasoning This rule is specifically important because of many elif branches indicate a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use some interface that just call a specific method without if . Or separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS224.html","text":"Forbids to have too many for statement within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS225.html","text":"Forbids to have too many except cases in a single try clause. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design. Since this way, one controlling structure will become too complex. And you will need to test a lot of paths your application might go. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS226.html","text":"Forbids to over-use string constants. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant. And should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS227.html","text":"Forbids to yield too long tuples. Reasoning Long yield tuples complicate generator using. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.10.0/violations/complexity/WPS228.html","text":"Forbids to have too long compare expressions. Reasoning To long compare expressions indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, seprate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/index.html","text":"These checks limit the Python's inconsistency. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to bare with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right. And we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective. But, we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS300.html","text":"Forbids to have imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS301.html","text":"Forbids to use imports like import os.path . Reasoning There too many different ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS302.html","text":"Forbids to use u string prefix. Reasoning We do not need this prefix since python2 . But, it is still possible to find it inside the codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS303.html","text":"Forbids to use underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS304.html","text":"Forbids to use partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and starting zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS305.html","text":"Forbids to use f strings. Reasoning f strings loses context too often and they are hard to lint. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS306.html","text":"Forbids to write classes without base classes. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS307.html","text":"Forbids to have multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS308.html","text":"Forbids to have compares between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the compare, will always be the same. Solution Remove the constant compare and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant compare"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS309.html","text":"Forbids comparision where argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle ordering of the arguments all the time. Bring consistency to the compare! Solution Refactor your compare expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS310.html","text":"Forbids to use capital X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase. Which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS311.html","text":"Forbids comparision where multiple in checks. Reasoning Using multiple in is unreadable. Solution Refactor your compare expression to use several and conditions or separate if statements in case it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS312.html","text":"Forbids to have compares between the same variable. Reasoning When the same variables are compared it is typically an indication of a mistake, since the Boolean value of the compare will always be the same. Solution Remove the same variable compare and any associated dead code. Example # Wrong : a = 1 if a < a : do_something () else : do_something_else () # Correct : do_something () 0.3.0","title":"Found compare between same variable"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS313.html","text":"Enforces to separate parenthesis from the keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between keyword and open paren. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parens right after a keyword"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS314.html","text":"Forbids using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Conditional always evaluates to same result"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS315.html","text":"Forbids extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Founded extra object in parent classes list"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS316.html","text":"Forbids multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into tuple or we are just using two context managers. Solution Use several context managers. Or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS317.html","text":"Forbids to use incorrect parameters indentation. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS318.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS319.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution Place bracket on the same line, when a single line expression. Or place the bracket on a new line when a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS320.html","text":"Forbids to use multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS321.html","text":"Forbids to use uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase modifiers should be written in lowercase. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS322.html","text":"Forbids to use triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS323.html","text":"Enforces to have an extra empty line after the coding comment. Reasoning Since we use flake8-coding <https://github.com/tk0miya/flake8-coding>`_ as a part of our linter we care about extra space after this coding comment. This is done for pure consistency. Why should we even care about this magic coding comment? For several reasons. First, explicit encoding is always better that an implicit one, different countries still use some non utf-8 encodings as a default. But, people might override it with other encodings in a comment. Do you know how much pain it can cause to you? We still know that python3 uses utf-8 inside. Second, some tools break because of this incorrect encoding comment. Including, django , flake8 , and tokenize`` core module. It is very hard to notice these things when they happen. Solution Add an empty line between coding magic comment and your code. Example # Correct: # coding: utf-8 SOME_VAR = 1 # Wrong: # coding: utf-8 SOME_VAR = 1 0.7.0","title":"Found missing empty line between coding magic comment and code"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS324.html","text":"Enforces to have consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 def function () : if some : print ( some ) return 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS325.html","text":"Enforces to have consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS326.html","text":"Forbids to use implicit string contacatenation. Reasoning This is error-prone, since you can possible miss a comma in a collection of string and get an implicit concatenation. And because there are different and safe ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS327.html","text":"Forbids to use meaningless continue node in loops. Reasoning Placing this keyword in the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue node from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS328.html","text":"Forbids to use meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by acedent. This might be also an overuse of syntax. Solution Remove node or make sure it makes any sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS329.html","text":"Forbids to use meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes any sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS330.html","text":"Forbids the use of unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS331.html","text":"Forbids local variable that are only used in return statements. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 # Wrong : def some_function () : some_value = 1 return some_value 0.9.0","title":"Found local variable that are only used in return statements"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS332.html","text":"Forbids to have implicit ternary expressions. Reasoning This is done for consistency and readability reasons. We believe that explicit ternary is better for readability. This also allows you to identify hidden conditionals in your code. Solution Refactor to use explicit ternary, or if condition. Example # Correct : some = one if cond () else two # Wrong : some = cond () and one or two 0.10.0","title":"Found implicit ternary expression"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS333.html","text":"Forbids to have implicit complex compare expressions. Reasoning Two compares in python that are joined with and operator mean that you indeed have a complex compare with tree operators. Solution Refactor your compare without and but with the third operator. Notice, that you migth have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS334.html","text":"Forbids to have reversed order complex compare expressions. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Reverse the order, so the smallest element comes the first and the biggest one comes the last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex compare"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS335.html","text":"Forbids to use lists and dicts as for loop iter targets. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Use tuples to create explicit iterables for for loops. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.10.0/violations/consistency/WPS336.html","text":"Forbids to use multiple equality compare with the same variable name. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII chars for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Keyword-only arguments must be separated from other arguments with * Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called TT or KT or VT Covariant and contravariant types should be marked with Cov and Contra suffixes, in this case, one letter can be dropped: TCov and KContra","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS100.html","text":"Forbids to use blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS101.html","text":"Forbids to use any magic names except whitelisted ones. Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS102.html","text":"Forbids to use module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS110.html","text":"Forbids to have blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the full list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS111.html","text":"Forbids to have too short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS112.html","text":"Forbids to have private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS113.html","text":"Forbids to use the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path 0.1.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS114.html","text":"Forbids to have names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored name pattern: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS115.html","text":"Forbids to use anything but snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS116.html","text":"Forbids to use more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS117.html","text":"Forbids to name your variables as self , cls , and mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS118.html","text":"Forbids to have long short variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS119.html","text":"Forbids to use unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS120.html","text":"Forbids to use trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.10.0/violations/naming/WPS121.html","text":"Forbids to have use variables that are marked as unused. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.11.0/index.html","text":"","title":"0.11.0"},{"location":"wemake-python-styleguide/0.11.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.11.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.11.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.11.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.11.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.11.0/constants/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.11.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.11.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.11.0/constants/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.11.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is hidden inside countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits. Then we forbid to use this bad code forever. So, this error will never return to our codebase.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS400.html","text":"Restricts to use several control (or magic) comments. We do not allow to use: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast Reasoning We cover several different use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can already use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow to use # type: ignore comment. Since sometimes it is totally required. Example # Correct : type = MyClass . get_type () # noqa : A001 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS401.html","text":"Forbids to use empty doc comments ( #: ). Reasoning Doc comments are used to provide a documentation. But supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment. Or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS402.html","text":"Forbids to use too many # noqa comments. We count it on a per-module basis. We use MAX_NOQA_COMMENTS as a default value. Reasoning Having too many # noqa comments make your code less readable and clearly indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS403.html","text":"Forbids to use too many # pragma: no cover comments. We count it on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments clearly indicates that there's something wrong with it. Moreover, it makes your tests useless, since they do not cover a big partion of your code. Solution Refactor your code to much the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS404.html","text":"Forbids to use complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or http requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS405.html","text":"Forbids to use anything rather than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' pepson ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS406.html","text":"Forbids to use anything rather than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS407.html","text":"Forbids mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List , and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS408.html","text":"Forbids to use the same logical conditions in one expression. Reasoning Using the same name in logical condition more that once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicating condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS409.html","text":"Forbids to heterogenous operators in one compare. Note, that we allow to mix > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogenous compare"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS410.html","text":"Forbids to have some module level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use pkg_resources if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS411.html","text":"Forbids to have empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS412.html","text":"Forbids to have logic inside __init__ module. Reasoning If you have logic inside the __init__ module it means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic into the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow to have some contents inside the __init__ module: comments, since they are dropped before AST comes in play docs string, because sometimes it is required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case this rule can be configured. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS413.html","text":"Forbids to use __getaddr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS414.html","text":"Forbids to have tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique. So, do not use it. Solution Use unpacking with only variables, not any other entities. Example # Correct: first, second = some() # Wrong: first, some_dict['alias'] = some() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS415.html","text":"Forbids to have the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Other one will always be ignored. So, that is clearly an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS416.html","text":"Forbids to have yield keyword inside comprehensions. Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in a foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords. Or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS417.html","text":"Forbids to have duplicate items in set literals. Reasoning When you explicitly put duplicate items in set literals it just does not make any sense. Since set can not contain duplicate items and they will be removed anyway. Solution Remove the duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations containers: lists, dicts, tuples, sets 0.7.0 0.11.0","title":"Found non-unique item in set literal: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS418.html","text":"Forbids to have duplicate items in set literals. Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS419.html","text":"Forbids to use multiple return path with try / except case. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be actually returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS420.html","text":"Forbids to use some python keywords. Reasoning Using some keywords generally gives you more pain that relieve. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no usecase for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale. And leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS421.html","text":"Forbids to call some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid to use them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS422.html","text":"Forbids to use __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS423.html","text":"Forbids to use NotImplemented error. Reasoning These two violations look so similar. But, these violations have different use cases. Use cases of NotImplemented is too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS424.html","text":"Forbids to use BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS425.html","text":"Forbids to pass booleans as non-keyword parameters. Reasoning Passing boolean as regular positional parameters is very non-descriptive. It is almost impossible to tell, what does this parameter means. And you almost always have to look up the implementation to tell what is going on. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UsersRepository.update(cache=True) # Wrong: UsersRepository.update(True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS426.html","text":"Forbids to use lambda inside loops. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS427.html","text":"Forbids to have unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we can not cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your code base at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have. Or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS428.html","text":"Forbids to have statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error. Or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS429.html","text":"Forbids to have multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grown pretty long. And you will not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS430.html","text":"Forbids to have nested functions. Reasoning Nesting functions is a bad practice. It is hard to test them, it is hard then to separate them. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures. Until you need them for decorators or factories. We also disallow to nest lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS431.html","text":"Forbids to use nested classes. Reasoning Nested classes are really hard to manage. You can not even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use different design (or metaclasses). See NESTED_CLASSES_WHITELIST for the full list of whitelisted names. Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS432.html","text":"Forbids to use magic numbers in your code. What we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers actually mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS433.html","text":"Forbids to have nested imports in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look like. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS434.html","text":"Forbids to assign variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS435.html","text":"Forbids to use yield inside of __init__ method. Reasoning __init__ should be used to initialize new objects. It shouldn't yield anything because it should return None by the convention. Example # Correct: class Example(object): def __init__(self): self._public_items_count = 0 # Wrong: class Example(object): def __init__(self): yield 10 0.3.0 0.11.0","title":"Found yield inside __init__ method"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS436.html","text":"Forbids to import protected modules. Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import anything from protected modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass from some.module import _protected 0.3.0 0.11.0","title":"Found protected module import"},{"location":"wemake-python-styleguide/0.11.0/violations/best_practices/WPS437.html","text":"Forbids to use protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated.","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS200.html","text":"Forbids to have modules with complex lines. We are using Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measuring the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS201.html","text":"Forbids to have modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS202.html","text":"Forbids to have many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any differences between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS210.html","text":"Forbids to have too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will find troubles to understand what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS211.html","text":"Forbids to have too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it shows that it is required to refactor this piece of code. It also indicates that function does too many things at once. Solution Split function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS212.html","text":"Forbids placing too many return statements into the function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS213.html","text":"Forbids putting too many expressions in a unit of code. Reasoning When there are too many expressions it means that this specific function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS214.html","text":"Forbids to have many methods in a single class. Reasoning Having too many methods might lead to the \"God object\". This kind of objects can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes. Then use composition or inheritance to refactor your code. This will protect you from \"God object\" anti-pattern. We do not make any difference between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you try to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you try to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into multiple ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS217.html","text":"Forbids placing too many await expressions into the function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where are we and what is going on. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS220.html","text":"Forbids nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS221.html","text":"Forbids to have complex lines. We are using Jones Complexity algorithm to count complexity. What is Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS222.html","text":"Forbids to have conditions with too many logical operators. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS223.html","text":"Forbids to use many elif branches. Reasoning This rule is specifically important because of many elif branches indicate a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use some interface that just call a specific method without if . Or separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS224.html","text":"Forbids to have too many for statement within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS225.html","text":"Forbids to have too many except cases in a single try clause. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design. Since this way, one controlling structure will become too complex. And you will need to test a lot of paths your application might go. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS226.html","text":"Forbids to over-use string constants. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant. And should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS227.html","text":"Forbids to yield too long tuples. Reasoning Long yield tuples complicate generator using. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.11.0/violations/complexity/WPS228.html","text":"Forbids to have too long compare expressions. Reasoning To long compare expressions indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, seprate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/index.html","text":"These checks limit the Python's inconsistency. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to bare with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right. And we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective. But, we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS300.html","text":"Forbids to have imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS301.html","text":"Forbids to use imports like import os.path . Reasoning There too many different ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS302.html","text":"Forbids to use u string prefix. Reasoning We do not need this prefix since python2 . But, it is still possible to find it inside the codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS303.html","text":"Forbids to use underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS304.html","text":"Forbids to use partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and starting zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS305.html","text":"Forbids to use f strings. Reasoning f strings loses context too often and they are hard to lint. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS306.html","text":"Forbids to write classes without base classes. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS307.html","text":"Forbids to have multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS308.html","text":"Forbids to have compares between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the compare, will always be the same. Solution Remove the constant compare and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant compare"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS309.html","text":"Forbids comparision where argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle ordering of the arguments all the time. Bring consistency to the compare! Solution Refactor your compare expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS310.html","text":"Forbids to use capital X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase. Which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS311.html","text":"Forbids comparision where multiple in checks. Reasoning Using multiple in is unreadable. Solution Refactor your compare expression to use several and conditions or separate if statements in case it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS312.html","text":"Forbids to have compares between the same variable. Reasoning When the same variables are compared it is typically an indication of a mistake, since the Boolean value of the compare will always be the same. Solution Remove the same variable compare and any associated dead code. Example # Wrong : a = 1 if a < a : do_something () else : do_something_else () # Correct : do_something () 0.3.0","title":"Found compare between same variable"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS313.html","text":"Enforces to separate parenthesis from the keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between keyword and open paren. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parens right after a keyword"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS314.html","text":"Forbids using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Conditional always evaluates to same result"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS315.html","text":"Forbids extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Founded extra object in parent classes list"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS316.html","text":"Forbids multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into tuple or we are just using two context managers. Solution Use several context managers. Or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS317.html","text":"Forbids to use incorrect parameters indentation. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS318.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS319.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution Place bracket on the same line, when a single line expression. Or place the bracket on a new line when a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS320.html","text":"Forbids to use multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS321.html","text":"Forbids to use uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase modifiers should be written in lowercase. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS322.html","text":"Forbids to use triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS323.html","text":"Enforces to have an extra empty line after the coding comment. Reasoning Since we use flake8-coding <https://github.com/tk0miya/flake8-coding>`_ as a part of our linter we care about extra space after this coding comment. This is done for pure consistency. Why should we even care about this magic coding comment? For several reasons. First, explicit encoding is always better that an implicit one, different countries still use some non utf-8 encodings as a default. But, people might override it with other encodings in a comment. Do you know how much pain it can cause to you? We still know that python3 uses utf-8 inside. Second, some tools break because of this incorrect encoding comment. Including, django , flake8 , and tokenize`` core module. It is very hard to notice these things when they happen. Solution Add an empty line between coding magic comment and your code. Example # Correct: # coding: utf-8 SOME_VAR = 1 # Wrong: # coding: utf-8 SOME_VAR = 1 0.7.0","title":"Found missing empty line between coding magic comment and code"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS324.html","text":"Enforces to have consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 def function () : if some : print ( some ) return 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS325.html","text":"Enforces to have consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS326.html","text":"Forbids to use implicit string contacatenation. Reasoning This is error-prone, since you can possible miss a comma in a collection of string and get an implicit concatenation. And because there are different and safe ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS327.html","text":"Forbids to use meaningless continue node in loops. Reasoning Placing this keyword in the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue node from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS328.html","text":"Forbids to use meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by acedent. This might be also an overuse of syntax. Solution Remove node or make sure it makes any sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS329.html","text":"Forbids to use meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes any sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS330.html","text":"Forbids the use of unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS331.html","text":"Forbids local variable that are only used in return statements. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 # Wrong : def some_function () : some_value = 1 return some_value 0.9.0","title":"Found local variable that are only used in return statements"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS332.html","text":"Forbids to have implicit ternary expressions. Reasoning This is done for consistency and readability reasons. We believe that explicit ternary is better for readability. This also allows you to identify hidden conditionals in your code. Solution Refactor to use explicit ternary, or if condition. Example # Correct : some = one if cond () else two # Wrong : some = cond () and one or two 0.10.0","title":"Found implicit ternary expression"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS333.html","text":"Forbids to have implicit complex compare expressions. Reasoning Two compares in python that are joined with and operator mean that you indeed have a complex compare with tree operators. Solution Refactor your compare without and but with the third operator. Notice, that you migth have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS334.html","text":"Forbids to have reversed order complex compare expressions. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Reverse the order, so the smallest element comes the first and the biggest one comes the last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex compare"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS335.html","text":"Forbids to use lists and dicts as for loop iter targets. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Use tuples to create explicit iterables for for loops. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS336.html","text":"Forbids to use multiple equality compare with the same variable name. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.11.0/violations/consistency/WPS337.html","text":"Forbids multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has. And it decreases readability of the code. Solution Divide multiline conditions to some if condition. Or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII chars for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Keyword-only arguments must be separated from other arguments with * Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called TT or KT or VT Covariant and contravariant types should be marked with Cov and Contra suffixes, in this case, one letter can be dropped: TCov and KContra","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS100.html","text":"Forbids to use blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS101.html","text":"Forbids to use any magic names except whitelisted ones. Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS102.html","text":"Forbids to use module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS110.html","text":"Forbids to have blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the full list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS111.html","text":"Forbids to have too short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS112.html","text":"Forbids to have private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS113.html","text":"Forbids to use the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path 0.1.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS114.html","text":"Forbids to have names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored name pattern: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS115.html","text":"Forbids to use anything but snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS116.html","text":"Forbids to use more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS117.html","text":"Forbids to name your variables as self , cls , and mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS118.html","text":"Forbids to have long short variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS119.html","text":"Forbids to use unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS120.html","text":"Forbids to use trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.11.0/violations/naming/WPS121.html","text":"Forbids to have use variables that are marked as unused. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beatiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS600.html","text":"Forbids to subclass lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS601.html","text":"Forbids to shadow class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS602.html","text":"Forbids to use @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS603.html","text":"Forbids to use some magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS604.html","text":"Forbids to use incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS605.html","text":"Forbids to have methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so can not access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS606.html","text":"Forbids to have anything else than a class as a base class. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS607.html","text":"Forbids to have incorrect __slots__ definition. Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = Test . __slots__ + ( 'child' ,) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS608.html","text":"Forbids to use super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.11.0/violations/oop/WPS609.html","text":"Forbids to use direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS500.html","text":"Forbids to use else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS501.html","text":"Forbids to use finally in try block without except block. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS502.html","text":"Forbids to have simplifiable if conditions. Reasoning This complex construction can cause frustration among other developers. It is longer, more verbose, and more complex. Solution Use bool() to convert test values to boolean values. Or just leave it as it is in case when your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS503.html","text":"Forbids to use useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS504.html","text":"Forbids to use negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS505.html","text":"Forbids to use nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS506.html","text":"Forbids to define useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS507.html","text":"Forbids to have unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS508.html","text":"Forbids to use not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS509.html","text":"Forbids to nest ternary expressions in some places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS510.html","text":"Forbids to use in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS511.html","text":"Forbids to multiple isinstance calls with the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.11.0/violations/refactoring/WPS512.html","text":"Forbids to multiple isinstance calls with tuples of a single item. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single varaible. Example # Correct: isinstance(some, (int, float)) isisntance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.12.0/index.html","text":"","title":"0.12.0"},{"location":"wemake-python-styleguide/0.12.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_ACCESS_LEVEL.html","text":"Maximum number of access level in an expression.","title":"MAX_ACCESS_LEVEL"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_ASSERTS.html","text":"Maximum number of assert statements in a function.","title":"MAX_ASSERTS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_ATTRIBUTES.html","text":"Maximum number of public attributes in a single class.","title":"MAX_ATTRIBUTES"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_AWAITS.html","text":"Maximum number of await expressions for functions or methods.","title":"MAX_AWAITS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_FUNCTION_EXPRESSIONS.html","text":"Maximum amount of same expressions per function.","title":"MAX_FUNCTION_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_IMPORTED_NAMES.html","text":"Maximum number of imported names in a single module.","title":"MAX_IMPORTED_NAMES"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_MODULE_EXPRESSIONS.html","text":"Maximum amount of same expressions per module.","title":"MAX_MODULE_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.12.0/configuration/MAX_TRY_BODY_LENGTH.html","text":"Maximum amount of try node body length.","title":"MAX_TRY_BODY_LENGTH"},{"location":"wemake-python-styleguide/0.12.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.12.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.12.0/constants/ALL_MAGIC_METHODS.html","text":"List of all magic methods from the python docs.","title":"ALL_MAGIC_METHODS"},{"location":"wemake-python-styleguide/0.12.0/constants/ASYNC_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be async.","title":"ASYNC_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.12.0/constants/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.12.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.12.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.12.0/constants/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.12.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/constants/YIELD_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be generators.","title":"YIELD_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is hidden inside countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits. Then we forbid to use this bad code forever. So, this error will never return to our codebase.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS400.html","text":"Restricts to use several control (or magic) comments. We do not allow to use: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast This violation is reported at the top of the module, so it cannot be locally ignored. Reasoning We cover several different use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can already use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow to use # type: ignore comment. Since sometimes it is totally required. Example # Correct : type = MyClass . get_type () # noqa : A001 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS401.html","text":"Forbids to use empty doc comments ( #: ). Reasoning Doc comments are used to provide a documentation. But supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment. Or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS402.html","text":"Forbids to use too many # noqa comments. We count it on a per-module basis. We use MAX_NOQA_COMMENTS as a hard limit. Reasoning Having too many # noqa comments make your code less readable and clearly indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS403.html","text":"Forbids to use too many # pragma: no cover comments. We count it on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments clearly indicates that there's something wrong with it. Moreover, it makes your tests useless, since they do not cover a big partion of your code. Solution Refactor your code to much the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS404.html","text":"Forbids to use complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or http requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS405.html","text":"Forbids to use anything rather than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' person ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS406.html","text":"Forbids to use anything rather than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS407.html","text":"Forbids mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List , and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS408.html","text":"Forbids to use the same logical conditions in one expression. Reasoning Using the same name in logical condition more that once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicating condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS409.html","text":"Forbids to heterogenous operators in one compare. Note, that we allow to mix > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogenous compare"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS410.html","text":"Forbids to have some module level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use pkg_resources if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS411.html","text":"Forbids to have empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS412.html","text":"Forbids to have logic inside __init__ module. Reasoning If you have logic inside the __init__ module it means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic into the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow to have some contents inside the __init__ module: comments, since they are dropped before AST comes in play docs string, because sometimes it is required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case this rule can be configured. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS413.html","text":"Forbids to use __getaddr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS414.html","text":"Forbids to have tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique. So, do not use it. Solution Use unpacking with only variables, not any other entities. Example # Correct: first, second = some() # Wrong: first, some_dict['alias'] = some() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS415.html","text":"Forbids to have the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Other one will always be ignored. So, that is clearly an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS416.html","text":"Forbids to have yield keyword inside comprehensions. Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in a foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords. Or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS417.html","text":"Forbids to have duplicate items in hashes. Reasoning When you explicitly put duplicate items in set literals or in dict keys it just does not make any sense. Since hashes cannot contain duplicate items and they will be removed anyway. Solution Remove duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations 0.7.0 0.11.0 0.12.0","title":"Found non-unique item in hash: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS418.html","text":"Forbids to have duplicate items in set literals. Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS419.html","text":"Forbids to use multiple returning paths with try / except case. Note, that we check for any return , break , or raise nodes. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be actually returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Correct : try : return 1 except YourException : ... finally : clear_things_up () # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0 0.12.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS420.html","text":"Forbids to use some python keywords. Reasoning Using some keywords generally gives you more pain that relieve. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no usecase for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale. And leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS421.html","text":"Forbids to call some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid to use them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS422.html","text":"Forbids to use __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS423.html","text":"Forbids to use NotImplemented error. Reasoning These two violations look so similar. But, these violations have different use cases. Use cases of NotImplemented is too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS424.html","text":"Forbids to use BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS425.html","text":"Forbids to pass booleans as non-keyword parameters. Reasoning Passing boolean as regular positional parameters is very non-descriptive. It is almost impossible to tell, what does this parameter means. And you almost always have to look up the implementation to tell what is going on. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UsersRepository.update(cache=True) # Wrong: UsersRepository.update(True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS426.html","text":"Forbids to use lambda inside loops. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS427.html","text":"Forbids to have unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we can not cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your code base at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have. Or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS428.html","text":"Forbids to have statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error. Or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS429.html","text":"Forbids to have multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grown pretty long. And you will not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS430.html","text":"Forbids to have nested functions. Reasoning Nesting functions is a bad practice. It is hard to test them, it is hard then to separate them. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures. Until you need them for decorators or factories. We also disallow to nest lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS431.html","text":"Forbids to use nested classes. Reasoning Nested classes are really hard to manage. You can not even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use different design (or metaclasses). See NESTED_CLASSES_WHITELIST for the full list of whitelisted names. Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS432.html","text":"Forbids to use magic numbers in your code. What we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers actually mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS433.html","text":"Forbids to have nested imports in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look like. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS434.html","text":"Forbids to assign variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS435.html","text":"Forbids to multiply lists. Reasoning When you multiply lists - it does not create new values, it creates references to the existing value. It is not what people mean in 99.9% of cases. Solution Use list comprehension or loop instead. Example # Wrong: my_list = [1, 2, 3] * 3 See also https://github.com/satwikkansal/wtfPython#-explanation-8 0.12.0","title":"Found list multiply"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS436.html","text":"Forbids to import protected modules. Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import anything from protected modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass from some.module import _protected 0.3.0 0.11.0","title":"Found protected module import"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS437.html","text":"Forbids to use protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS438.html","text":"Forbids to raise StopIteration inside generators. Reasoning StopIteration should not be raised explicitly in generators. Solution Use return statement to get out of a generator. Example # Correct : def some_generator () : if some_value : return yield 1 # Wrong : def some_generator () : if some_value : raise StopIteration yield 1 See also https://docs.python.org/3/library/exceptions.html#StopIteration 0.12.0","title":"Found StopIteration raising inside generator"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS439.html","text":"Forbids to use unicode escape sequences in binary strings. Reasoning Binary strings do not work with unicode. Having unicode escape characters in there means that you have an error in your code. Solution Use regular strings when escaping unicode strings. Example # Correct: escaped = '\\u0041' # equals to 'A' # Wrong: escaped = b'\\u0040' # equals to b'\\\\u0040' 0.12.0","title":"Found unicode escape in a binary string: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS440.html","text":"Forbids to local and block variables to overlap. What we call local variables: Assigns and annotations Function arguments (they are local to the function body) What we call block variables: Imports Functions and async functions definitions Classes, methods, and async methods definitions For and async for loops variables Except block exception aliases We allow local variables to overlap theirselfs, we forbid block varibals to overlap theirselfs. Reasoning A lot of complex errors might happen when you shadow local varibales with block variables or when you shadow block variables with local variables. Solution Use names that do not overlap. Example # Correct: my_value = 1 my_value = my_value + 1 # Wrong: import my_value my_value = 1 # overlaps with import See also https://github.com/satwikkansal/wtfPython#-explanation-20 0.12.0","title":"Found block variables overlap: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS441.html","text":"Forbids to use control variables after the block body. What we call block control variables: for loop unpacked variables with context variables except exception names Reasoning Variables leaking from the blocks can damage your logic. It might not contain what you think they contain. Some variables even might be deleted right after the block, just like in except Exception as exc: where exc won't be in scope after except body. Solution Use names inside the scope they are defined. Create new functions to return values in case you need to use block variables: when searching for a value, etc. Example # Correct : for my_item in collection : print ( my_item ) # Wrong : for my_item in collection : ... print ( my_item ) See also https://github.com/satwikkansal/wtfPython#-explanation-32 0.12.0","title":"Found control variable used after block: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS442.html","text":"Forbids to shadow variables from outer scopes. We check function, method, and module scopes. While we do not check class scope. Because class level constants are not available via regular name, and they are scope to ClassName.var_name . Reasoning Shadowing can lead you to a big pile of strage and unexpected bugs. Solution Use different names and do not allow scoping. Example # Correct: def test(): ... def other(): test1 = 1 # Wrong: def test(): ... def other(): test = 1 # shadows ``test()` function 0.12.0","title":"Found outer scope names shadowing: _"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS443.html","text":"Forbids to use exlicit unhashable types as set items and dict keys. Reasoning This will resolve in TypeError in runtime. Solution Use hashable types to define set items and dict keys. Example # Correct: my_dict = {1: {}, (1, 2): [], (2, 3): {1, 2}} # Wrong: my_dict = {[1, 2]: [], {2, 3}: {1, 2}} 0.12.0","title":"Found unhashable item"},{"location":"wemake-python-styleguide/0.12.0/violations/best_practices/WPS444.html","text":"Forbids to use exlicit falsly-evaluated conditions with several keywords. We check: ast.While ast.Assert We only check constants. We do not check variables, attributes, calls, etc. Reasoning Some conditions clearly tell us that this node won't work correctly. So, we need to check that we can fix that. Solution Remove the unreachable node, or change the condition item. Example # Correct: assert some_variable while True : ... # Wrong: assert [] while False : ... 0.12.0","title":"Found wrong keyword condition: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated.","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS200.html","text":"Forbids to have modules with complex lines. We are using Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measuring the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS201.html","text":"Forbids to have modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS202.html","text":"Forbids to have many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any differences between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS203.html","text":"Forbids to have modules with too many imported names. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imported names without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imported-names . Default: MAX_IMPORTED_NAMES 0.12.0","title":"Found module with too many imported names: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS204.html","text":"Forbids to have overused expressions in a module, function or method. Reasoning Overusing expression lead to losing the parts that can and should be refactored into methods and properties of objects. Solution Refactor expressions to be attribute, method, or a new variable. Configuration This rule is configurable with --max-module-expressions . Default: MAX_MODULE_EXPRESSIONS And with --max-function-expressions . Default: MAX_FUNCTION_EXPRESSIONS 0.12.0","title":"Found overused expression: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS210.html","text":"Forbids to have too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will find troubles to understand what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS211.html","text":"Forbids to have too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it shows that it is required to refactor this piece of code. It also indicates that function does too many things at once. Solution Split function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS212.html","text":"Forbids placing too many return statements into the function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS213.html","text":"Forbids putting too many expressions in a unit of code. Reasoning When there are too many expressions it means that this specific function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS214.html","text":"Forbids to have many methods in a single class. Reasoning Having too many methods might lead to the \"God object\". This kind of objects can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes. Then use composition or inheritance to refactor your code. This will protect you from \"God object\" anti-pattern. We do not make any difference between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you try to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you try to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into multiple ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS217.html","text":"Forbids placing too many await expressions into a function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where are we and what is going on. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS218.html","text":"Forbids placing too many asseert statements into a function. Reasoning When there are too many assert keywords, functions are starting to get really complex. It might indicate that your tests or contracts are too big. Solution Create rich assert statements, use higher-level contracts, or create special guard functions. Configuration This rule is configurable with --max-asserts . Default: MAX_ASSERTS 0.12.0","title":"Found too many assert statements: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS219.html","text":"Forbids to have consecutive expressions with too deep access level. We consider only these expressions as accesses: ast.Subscript ast.Attribute We do not treat ast.Call as an access, since there are a lot of call-based APIs like Django ORM, builder patterns, etc. Reasoning Having too deep access level indicates a bad design and overcomplicated data without proper API. Solution Split the expression into variables, functions or classes. Refactor the API for your data layout. Example # Correct: access level = 4 self . attr . inner . wrapper [ 1 ] # Correct: access level = 1 manager . filter (). exclude (). annotate (). values (). first () # Wrong: access level = 5 self . attr . inner . wrapper . method . call () # Wrong: access level = 5 # ``obj` has access level of 2: # ``.attr`, ``.call` # ``call()` has access level of 5: # ``.other`, ``[0]`, ``.field`, ``.type`, ``.boom` obj . attr . call (). other [ 0 ] . field . type . boom Configuration This rule is configurable with --max-access-level . Default: MAX_ACCESS_LEVEL 0.12.0","title":"Found too deep access level: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS220.html","text":"Forbids nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS221.html","text":"Forbids to have complex lines. We are using Jones Complexity algorithm to count complexity. What is Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS222.html","text":"Forbids to have conditions with too many logical operators. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS223.html","text":"Forbids to use many elif branches. Reasoning This rule is specifically important because of many elif branches indicate a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use some interface that just call a specific method without if . Or separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS224.html","text":"Forbids to have too many for statement within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS225.html","text":"Forbids to have too many except cases in a single try clause. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design. Since this way, one controlling structure will become too complex. And you will need to test a lot of paths your application might go. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS226.html","text":"Forbids to over-use string constants. We allow to use strings without any restrictions as annotations for variables, arguments, return values, and class attributes. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant. And should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS227.html","text":"Forbids to yield too long tuples. Reasoning Long yield tuples complicate generator using. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS228.html","text":"Forbids to have too long compare expressions. Reasoning To long compare expressions indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, seprate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS229.html","text":"Forbids to have try blocks with too long bodies. Reasoning Having too many statements inside your try block can lead to situations when some different statement raises an exception and you are not aware of it since it is not expected. Solution Move things out of the try block or create new functions. The less lines you have in your try block - the safer you are from accidental errors. Configuration This rule is configurable with --max-try-body-length . Default: MAX_TRY_BODY_LENGTH 0.12.0","title":"Found too long try body length: _"},{"location":"wemake-python-styleguide/0.12.0/violations/complexity/WPS230.html","text":"Forbids to have try blocks with too long bodies. We only check static definitions in a form of self.public = ... . We do not count parent attributes. We do not count properties. We do not count annotations. We do not count class attributes. Reasoning Having too many public instance attributes means that your class is too complex in terms of coupling. Other classes and functions will rely on these concrete fields instead of better abstraction layers. Solution Make some attributes protected. Split this class into several ones. If class is a Data Transder Object, then use @dataclass decorator. Configuration This rule is configurable with --max-attributes . Default: MAX_ATTRIBUTES See also https://en.wikipedia.org/wiki/Coupling_(computer_programming) 0.12.0","title":"Found too many public instance attributes"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/index.html","text":"These checks limit the Python's inconsistency. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to bare with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right. And we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective. But, we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS300.html","text":"Forbids to have imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS301.html","text":"Forbids to use imports like import os.path . Reasoning There too many different ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS302.html","text":"Forbids to use u string prefix. Reasoning We do not need this prefix since python2 . But, it is still possible to find it inside the codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS303.html","text":"Forbids to use underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS304.html","text":"Forbids to use partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and starting zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS305.html","text":"Forbids to use f strings. Reasoning f strings loses context too often and they are hard to lint. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS306.html","text":"Forbids to write classes without base classes. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... See also https://google.github.io/styleguide/pyguide.html#39-classes 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS307.html","text":"Forbids to have multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS308.html","text":"Forbids to have compares between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the compare, will always be the same. Solution Remove the constant compare and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant compare"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS309.html","text":"Forbids comparision where argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle ordering of the arguments all the time. Bring consistency to the compare! Solution Refactor your compare expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS310.html","text":"Forbids to use capital X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase. Which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS311.html","text":"Forbids comparision where multiple in checks. Reasoning Using multiple in is unreadable. Solution Refactor your compare expression to use several and conditions or separate if statements in case it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS312.html","text":"Forbids to have compares between the same variable. Reasoning When the same variables are compared it is typically an indication of a mistake, since the Boolean value of the compare will always be the same. Solution Remove the same variable compare and any associated dead code. Example # Wrong : a = 1 if a < a : do_something () else : do_something_else () # Correct : do_something () 0.3.0","title":"Found compare between same variable"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS313.html","text":"Enforces to separate parenthesis from the keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between keyword and open paren. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parens right after a keyword"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS314.html","text":"Forbids using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Conditional always evaluates to same result"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS315.html","text":"Forbids extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Founded extra object in parent classes list"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS316.html","text":"Forbids multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into tuple or we are just using two context managers. Solution Use several context managers. Or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS317.html","text":"Forbids to use incorrect parameters indentation. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS318.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS319.html","text":"Forbids to have brackets in the wrong position. Reasoning You can do bizzare things with bracket positioning in python. We require all brackets to be consistent. Solution Place bracket on the same line, when a single line expression. Or place the bracket on a new line when a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS320.html","text":"Forbids to use multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS321.html","text":"Forbids to use uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase modifiers should be written in lowercase. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS322.html","text":"Forbids to use triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS323.html","text":"Enforces to have an extra empty line after the coding comment. Reasoning Since we use flake8-coding <https://github.com/tk0miya/flake8-coding>`_ as a part of our linter we care about extra space after this coding comment. This is done for pure consistency. Why should we even care about this magic coding comment? For several reasons. First, explicit encoding is always better that an implicit one, different countries still use some non utf-8 encodings as a default. But, people might override it with other encodings in a comment. Do you know how much pain it can cause to you? We still know that python3 uses utf-8 inside. Second, some tools break because of this incorrect encoding comment. Including, django , flake8 , and tokenize`` core module. It is very hard to notice these things when they happen. Solution Add an empty line between coding magic comment and your code. Example # Correct: # coding: utf-8 SOME_VAR = 1 # Wrong: # coding: utf-8 SOME_VAR = 1 0.7.0","title":"Found missing empty line between coding magic comment and code"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS324.html","text":"Enforces to have consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS325.html","text":"Enforces to have consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS326.html","text":"Forbids to use implicit string contacatenation. Reasoning This is error-prone, since you can possible miss a comma in a collection of string and get an implicit concatenation. And because there are different and safe ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS327.html","text":"Forbids to use meaningless continue node in loops. Reasoning Placing this keyword in the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue node from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS328.html","text":"Forbids to use meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by acedent. This might be also an overuse of syntax. Solution Remove node or make sure it makes any sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS329.html","text":"Forbids to use meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes any sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS330.html","text":"Forbids the use of unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS331.html","text":"Forbids local variable that are only used in return statements. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 # Wrong : def some_function () : some_value = 1 return some_value 0.9.0","title":"Found local variable that are only used in return statements"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS332.html","text":"Forbids to have implicit ternary expressions. Reasoning This is done for consistency and readability reasons. We believe that explicit ternary is better for readability. This also allows you to identify hidden conditionals in your code. Solution Refactor to use explicit ternary, or if condition. Example # Correct : some = one if cond () else two # Wrong : some = cond () and one or two 0.10.0","title":"Found implicit ternary expression"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS333.html","text":"Forbids to have implicit complex compare expressions. Reasoning Two compares in python that are joined with and operator mean that you indeed have a complex compare with tree operators. Solution Refactor your compare without and but with the third operator. Notice, that you migth have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS334.html","text":"Forbids to have reversed order complex compare expressions. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Reverse the order, so the smallest element comes the first and the biggest one comes the last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex compare"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS335.html","text":"Forbids to use wrong for loop iter targets. We forbid to use: Lists and list comprehensions Sets and set comprehensions Dicts and dict comprehensions Generator expressions Empty tuples Reasoning Using lists, dicts, and sets do not make much sense. You can use tuples instead. Using comprehensions implicitly create a two level loops, that are hard to read and deal with. Solution Use tuples to create explicit iterables for for loops. In case you are using a comprehension, create a new variable. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0 0.12.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS336.html","text":"Forbids explicit string concat in favour of .format method. However, we still allow multiline string concat as a way to write long stirngs that does not fit the 80-chars rule. Reasoning When formating strings one must use .format and not any other formatting methods like % , + , or f . This is done for consistency reasons. Solution Join strings together if you can, or use .format method. Example # Correct: x = 'ab: {0}'.format(some_data) # Wrong: x = 'a' + 'b: ' + some_data 0.12.0","title":"Found explicit string concat"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS337.html","text":"Forbids multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has. And it decreases readability of the code. Solution Divide multiline conditions to some if condition. Or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS338.html","text":"Forbids to have incorrect order of methods inside a class. We follow the same ordering: __new__ __init__ public and megic methods protected methods private methods (we discourage to use them) We follow \"Newspaper order\" when the most important things come the first. Reasoning It is hard to read classes which API declarations is bloated with implementation details. We need to see the important stuff first, then we can go deeper in case we are interested. Solution Reorder methods inside your class to match our format. 0.12.0","title":"Found incorrect order of methods in a class"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS339.html","text":"Forbids to use meaningless zeros. We discorauge using meaningless zeros in float, binary, octal, hex, and expanentional numbers. Reasoning There are \\~infinitive ways to write these numbers by adding meaningless leading zeros to the number itself. 0b1 is the same as 0b01 and 0b001 . How a language can be called consistent if you can write numbers in a infinite ways? It hurts readability and understanding of your code. Solution Remove meaningless leading zeros. Example # Correct: numbers = [1.5, 0b1, 0o2, 0x5, 10e10] # Wrong: numbers = [1.50, 0b00000001, 0o0002, 0x05, 10e010] 0.12.0","title":"Found number with meaningless zeros: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS340.html","text":"Forbids to extra + signs in the exponent. Reasoning Positive exponent is positive by default, there's no need to write an extra + sign. We enforce consistency with this rule. Solution Remove meaningless + sign from the exponent. Example # Correct: number = 1e1 + 1e-1 # Wrong: number = 1e+1 0.12.0","title":"Found exponent number with positive exponent: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS341.html","text":"Forbids use lower-case letters as hex numbers. Reasoning One can write 0xA and 0xa which is inconsistent. This rule enforces upper-case letters in hex numbers. Solution Use upper-case letters in hex numbers. Example # Correct: number = 0xABCDEF # Wrong: number = 0xabcdef 0.12.0","title":"Found wrong hex number case: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS342.html","text":"Forbids to use \\\\ escape sequences inside regular strings. Reasoning It is hard to read escape sequencse inside regular strings, because they use \\\\ double backslash for a single character escape. Solution Use raw strings r'' to rewrite the escape sequence with a \\ single backslash. Example # Correct: escaped = [r'\\n', '\\n'] # Wrong: escaped = '\\\\n' 0.12.0","title":"Found implicit raw string: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS343.html","text":"Forbids to use uppercase complex number suffix. Reasoning Numbers should be consistent. Solution Use lowercase suffix for imaginary part. Example # Correct: complex_number = 1j # Wrong: complex_number = 1J 0.12.0","title":"Found wrong complex number suffix: _"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS344.html","text":"Forbids to explicitly divide by zero. Reasoning This will just throw ZeroDivisoionError in case that's what you need: just throw it. No need to use undefined meth behaviours. Or it might be just a typo / mistake, then fix it. Solution Use ZeroDivisoionError or fix your number not to be 0 . Example # Correct: raise ZeroDivisoionError() # Wrong: 1 / 0 0.12.0","title":"Found explicit zero division"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS345.html","text":"Forbids to use meaningless math opeartions with 0 and 1 . Reasoning Adding and substracting zero does not change the value. There's no need to do that. Multipling by zero is also redundunt: it can be replaced with explicit 0 assign. Multiplying and dividing by 1 is also meaningless. Solution Remove useless zero operaionts. Example # Correct: number = 1 zero = 0 one = 1 # Wrong: number = 1 + 0 * 1 zero = some * 0 / 1 one = some ** 0 ** 1 0.12.0","title":"Found meaningless number operation"},{"location":"wemake-python-styleguide/0.12.0/violations/consistency/WPS346.html","text":"Forbids to have double minus operations. Reasoning Having two operations is harder than having just one. Two negations are harder than one positive expression. Two negations equal to one positive expression. Positive and negative equal to one negative. Solution Replace double minus operation to a single one with plus. Replace 'plus-minus' operation to a single one with minus. Example # Correct: number = 3 + 1 number += 6 number -= 2 # Wrong: number = 3 - -1 number -= -6 number += -2 0.12.0","title":"Found wrong operation sign"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII chars for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Do not define unused variables unless you are unpacking other values as well Do not use multiple underscores ( __ ) to create unused variables Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Enum fields also must use snamek_case Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Keyword-only arguments must be separated from other arguments with * Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called TT or KT or VT Covariant and contravariant types should be marked with Cov and Contra suffixes, in this case, one letter can be dropped: TCov and KContra","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS100.html","text":"Forbids to use blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS101.html","text":"Forbids to use any magic names except whitelisted ones. Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS102.html","text":"Forbids to use module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS110.html","text":"Forbids to have blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the full list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS111.html","text":"Forbids to have too short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. We do not count trailing and leading underscores when calculating length. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0 0.12.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS112.html","text":"Forbids to have private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS113.html","text":"Forbids to use the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path 0.1.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS114.html","text":"Forbids to have names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored name pattern: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS115.html","text":"Forbids to use anything but snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS116.html","text":"Forbids to use more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS117.html","text":"Forbids to name your variables as self , cls , and mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS118.html","text":"Forbids to have long short variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS119.html","text":"Forbids to use unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS120.html","text":"Forbids to use trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS121.html","text":"Forbids to have use variables that are marked as unused. We discourage using _ at all and variables that start with _ only inside functions and methods as local variables. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0 0.12.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS122.html","text":"Forbids to define explicit unused variables. Reasoning While it is ok to define unused variables when you have to, like when unpacking a tuple, it is totally not ok to define explicit unusued variables in cases like assignment, function return, exception handling, or context managers. Why do you need this explicitly unused variables? Solution Remove all unused variables definition. Example # Correct: my_function() first, _second = some_tuple() print(first) # Wrong: _ = my_function() _first, _second = some_tuple() This rule checks: assigns, context managers, except clauses. 0.12.0","title":"Found all unused variables definition: _"},{"location":"wemake-python-styleguide/0.12.0/violations/naming/WPS123.html","text":"Forbids to define unused variables with multiple underscores. Reasoning We only use _ as a special definition for an unused variable. Other variables are hard to read. It is unclear why would one use it. Solution Rename unused variables to _ or give it some more context with an explicit name: _context . Example # Correct: some_element, _next_element, _ = some_tuple() some_element, _, _ = some_tuple() some_element, _ = some_tuple() # Wrong: some_element, _, __ = some_tuple() 0.12.0","title":"Found wrong unused variable name: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beatiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS600.html","text":"Forbids to subclass lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS601.html","text":"Forbids to shadow class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS602.html","text":"Forbids to use @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS603.html","text":"Forbids to use some magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS604.html","text":"Forbids to use incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS605.html","text":"Forbids to have methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so can not access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS606.html","text":"Forbids to have anything else than a class as a base class. We only check base classes and not keywords. They can be anything you need. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Use annotation future import in case you use strings in base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0 0.12.0","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS607.html","text":"Forbids to have incorrect __slots__ definition. Things that this rule checks: That __slots__ is a tuple, name, attribute, star, or call That __slots__ do not have duplicates That __slots__ do not have empty strings or invalid python names Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Use snake_case to define attributes in __slots__ . Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = (* Test . __slots__ , 'child' ) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0 0.12.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS608.html","text":"Forbids to use super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS609.html","text":"Forbids to use direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS610.html","text":"Forbids to make some magic methods async. We allow to make __anext__ , __aenter__ , __aexit__ async. We also allow custom magic methods to be async. See ASYNC_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted async magic methods. Reasoning Defining the magic methods as async which are not supposed to be async would not work as expected. Solution Do not make this magic method async. Example # Correct: class Test ( object ): def __lt__ ( self , other ): ... # Wrong: class Test ( object ): async def __lt__ ( self , other ): ... See also https://docs.python.org/3/reference/datamodel.html 0.12.0","title":"Found forbidden async magic method usage: _"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS611.html","text":"Forbids to use yield inside of several magic methods. We allow to make __iter__ a generator. See YIELD_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted generator magic methods. Reasoning Python's datamodel is strict. You cannot make generators from random magic methods. This rule enforces it. Solution Remove yield from a magic method or rename it to be a custom method. Example # Correct: class Example(object): def __init__(self): ... # Wrong: class Example(object): def __init__(self): yield 10 See also https://docs.python.org/3/reference/datamodel.html 0.3.0 0.11.0 0.12.0","title":"Found forbidden yield magic method usage"},{"location":"wemake-python-styleguide/0.12.0/violations/oop/WPS612.html","text":"Forbids to have useless overwritten methods. Reasoning Overwriting method without any changes does not have any positive impact. Solution Do not overwrite method in case you do not want to do any changes inside it. Example # Correct: class Test ( Base ): ... # Wrong: class Test ( object ): def method ( self , argument ): return super (). method ( argument ) 0.12.0","title":"Found useless overwritten method: _"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS500.html","text":"Forbids to use else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS501.html","text":"Forbids to use finally in try block without except block. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS502.html","text":"Forbids to have simplifiable if conditions. Reasoning This complex construction can cause frustration among other developers. It is longer, more verbose, and more complex. Solution Use bool() to convert test values to boolean values. Or just leave it as it is in case when your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS503.html","text":"Forbids to use useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS504.html","text":"Forbids to use negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS505.html","text":"Forbids to use nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS506.html","text":"Forbids to define useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS507.html","text":"Forbids to have unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS508.html","text":"Forbids to use not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS509.html","text":"Forbids to nest ternary expressions in some places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS510.html","text":"Forbids to use in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS511.html","text":"Forbids to multiple isinstance calls with the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS512.html","text":"Forbids to multiple isinstance calls with tuples of a single item. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single varaible. Example # Correct: isinstance(some, (int, float)) isisntance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS513.html","text":"Forbids to have implicit elif conditions. Reasoning Nested if in else cases are bad for readability because of the nesting level. Solution Use elif on the same level. Example # Correct : if some : ... elif other : ... # Wrong : if some : ... else : if other : ... 0.12.0","title":"Found implicit elif condition"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS514.html","text":"Forbids to use multiple equality compare with the same variable name. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0 0.12.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS515.html","text":"Forbids to use open() with a context manager. Reasoning When you open() something, you need to close it. When using a context manager - it is automatically done for you. When not using it - you might find yourself in a situation when file is not closed and is not accessable anymore. Solution Refactor open() call to use with . Example # Correct: with open(filename) as file_obj: ... # Wrong: file_obj = open(filename) 0.12.0","title":"Found open() used without a context manager"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS516.html","text":"Forbids to compare types with type() function. Reasoning When you compare types with type() function call it means that you break polymorphism and dissallow child classes of a node to work here. That's incorrect. Solution Use isinstance to compare types. Example # Correct : print ( something , type ( something )) # Wrong : if type ( something ) == int : ... 0.12.0","title":"Found type() used to compare types"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS517.html","text":"Forbids to have useless starred expressions. Reasoning Using starred expression with constants is useless. This piece of code can be rewritten to be flat. Eg.: print(*[1, 2, 3]) is print(1, 2, 3) . Solution Refactor your code not to use starred expressions with list , dict , tuple , and set constants. Use regular argument passing instead. Example # Correct: my_list = [1, 2, 3, *other_iterable] # Wrong: print(*[1, 2, 3], ** {{}} ) 0.12.0","title":"Found pointless starred expression"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS518.html","text":"Forbids to have implicit enumerate() calls. Reasoning Using range(len(...)) is not pythonic. Python uses collection iterators, not index-based loops. Solution Use enumerate(...) instead of range(len(...)) . Example # Correct: for index , person in enumerate ( people ): ... # Wrong: for index in range ( len ( people )): ... See also https://docs.python.org/3/library/functions.html#enumerate 0.12.0","title":"Found implicit enumerate() call"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS519.html","text":"Forbids to have implicit sum() calls. When summing types different from numbers, you might need to provide the second argument to the sum function: sum([[1], [2], [3]], []) You might also use str.join to join iterable of strings. Reasoning Using for loops with += assign inside indicates that you iteratively sum things inside your collection. That's what sum() builtin function does. Solution Use sum(...) instead of a loop with += operation. Example # Correct : sum_result = sum ( get_elements ()) # Wrong : sum_result = 0 for to_sum in get_elements () : sum_result += to_sum See also https://docs.python.org/3/library/functions.html#sum https://docs.python.org/3/library/stdtypes.html#str.join 0.12.0","title":"Found implicit sum() call"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS520.html","text":"Forbids to compare with explicit falsy constants. We allow to compare with falsy numbers, strings, booleans, None . We disallow complex constants like tuple, dicts, and lists. Reasoning When comparing something with explicit falsy constants what we really mean is not something . Solution Use not with your variable. Fix your data types. Example # Correct : if not my_check : ... if some_other is None : ... if some_num == 0 : ... # Wrong : if my_check == []: ... 0.12.0","title":"Found compare with falsy constant"},{"location":"wemake-python-styleguide/0.12.0/violations/refactoring/WPS521.html","text":"Forbids to compare values with constants using is or is not . However, we allow to compare with None and booleans. Reasoning is compares might not do what you want them to do. Firstly, they check for the same object, not equality. Secondly, they behave unexpectedly even with the simple values like 257 . Solution Use == to compare with constants. Example # Correct : if my_check == [ 1 , 2 , 3 ]: ... # Wrong : if my_check is [ 1 , 2 , 3 ]: ... See also https://stackoverflow.com/a/33130014/4842742 0.12.0","title":"Found wrong is compare"},{"location":"wemake-python-styleguide/0.13.0/index.html","text":"","title":"0.13.0"},{"location":"wemake-python-styleguide/0.13.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_ACCESS_LEVEL.html","text":"Maximum number of access level in an expression.","title":"MAX_ACCESS_LEVEL"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_ASSERTS.html","text":"Maximum number of assert statements in a function.","title":"MAX_ASSERTS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_ATTRIBUTES.html","text":"Maximum number of public attributes in a single class.","title":"MAX_ATTRIBUTES"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_AWAITS.html","text":"Maximum number of await expressions for functions or methods.","title":"MAX_AWAITS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_CALL_LEVEL.html","text":"Maximum number of call chains.","title":"MAX_CALL_LEVEL"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_COGNITIVE_AVERAGE.html","text":"Maximum amount of average cognitive complexity per module.","title":"MAX_COGNITIVE_AVERAGE"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_COGNITIVE_SCORE.html","text":"Maximum amount of cognitive complexity per function.","title":"MAX_COGNITIVE_SCORE"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_FUNCTION_EXPRESSIONS.html","text":"Maximum amount of same expressions per function.","title":"MAX_FUNCTION_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_IMPORTED_NAMES.html","text":"Maximum number of imported names in a single module.","title":"MAX_IMPORTED_NAMES"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_MODULE_EXPRESSIONS.html","text":"Maximum amount of same expressions per module.","title":"MAX_MODULE_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.13.0/configuration/MAX_TRY_BODY_LENGTH.html","text":"Maximum amount of try node body length.","title":"MAX_TRY_BODY_LENGTH"},{"location":"wemake-python-styleguide/0.13.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.13.0/configuration/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.13.0/constants/ALL_MAGIC_METHODS.html","text":"List of all magic methods from the python docs.","title":"ALL_MAGIC_METHODS"},{"location":"wemake-python-styleguide/0.13.0/constants/ASYNC_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be async.","title":"ASYNC_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/LITERALS_BLACKLIST.html","text":"List of literals without arguments we forbid to use.","title":"LITERALS_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MATH_APPROXIMATE_CONSTANTS.html","text":"Approximate constants which real values should be imported from math module.","title":"MATH_APPROXIMATE_CONSTANTS"},{"location":"wemake-python-styleguide/0.13.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.13.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.13.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.13.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.13.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/constants/YIELD_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be generators.","title":"YIELD_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is hidden inside countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits. Then we forbid to use this bad code forever. So, this error will never return to our codebase.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS400.html","text":"Restricts to use several control (or magic) comments. We do not allow to use: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast This violation is reported at the top of the module, so it cannot be locally ignored. Reasoning We cover several different use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can already use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow to use # type: ignore comment. Since sometimes it is totally required. Example # Correct : type = MyClass . get_type () # noqa : A001 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS401.html","text":"Forbids to use empty doc comments ( #: ). Reasoning Doc comments are used to provide a documentation. But supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment. Or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS402.html","text":"Forbids to use too many # noqa comments. We count it on a per-module basis. We use MAX_NOQA_COMMENTS as a hard limit. Reasoning Having too many # noqa comments make your code less readable and clearly indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. Configuration This rule is configurable with --max-noqa-comments . Default: MAX_NOQA_COMMENTS 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS403.html","text":"Forbids to use too many # pragma: no cover comments. We count it on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments clearly indicates that there's something wrong with it. Moreover, it makes your tests useless, since they do not cover a big partion of your code. Solution Refactor your code to much the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS404.html","text":"Forbids to use complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or http requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS405.html","text":"Forbids to use anything rather than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' person ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS406.html","text":"Forbids to use anything rather than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS407.html","text":"Forbids mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List , and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS408.html","text":"Forbids to use the same logical conditions in one expression. Reasoning Using the same name in logical condition more that once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicating condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0 0.13.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS409.html","text":"Forbids to heterogenous operators in one compare. Note, that we allow to mix > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogenous compare"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS410.html","text":"Forbids to have some module level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use pkg_resources if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS411.html","text":"Forbids to have empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS412.html","text":"Forbids to have logic inside __init__ module. Reasoning If you have logic inside the __init__ module it means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic into the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow to have some contents inside the __init__ module: comments, since they are dropped before AST comes in play docs string, because sometimes it is required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case this rule can be configured. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS413.html","text":"Forbids to use __getattr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS414.html","text":"Forbids to have tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique. So, do not use it. Solution Use unpacking with only variables, not any other entities. Example # Correct: first, second = some() # Wrong: first, some_dict['alias'] = some() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS415.html","text":"Forbids to have the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Other one will always be ignored. So, that is clearly an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS416.html","text":"Forbids to have yield keyword inside comprehensions. Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in a foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords. Or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS417.html","text":"Forbids to have duplicate items in hashes. Reasoning When you explicitly put duplicate items in set literals or in dict keys it just does not make any sense. Since hashes cannot contain duplicate items and they will be removed anyway. Solution Remove duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations 0.7.0 0.11.0 0.12.0","title":"Found non-unique item in hash: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS418.html","text":"Forbids to have duplicate items in set literals. Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS419.html","text":"Forbids to use multiple returning paths with try / except case. Note, that we check for any return , break , or raise nodes. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be actually returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Correct : try : return 1 except YourException : ... finally : clear_things_up () # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0 0.12.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS420.html","text":"Forbids to use some python keywords. Reasoning Using some keywords generally gives you more pain that relieve. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no usecase for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale. And leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS421.html","text":"Forbids to call some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid to use them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS422.html","text":"Forbids to use __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS423.html","text":"Forbids to use NotImplemented error. Reasoning These two violations look so similar. But, these violations have different use cases. Use cases of NotImplemented is too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS424.html","text":"Forbids to use BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS425.html","text":"Forbids to pass booleans as non-keyword parameters. Reasoning Passing boolean as regular positional parameters is very non-descriptive. It is almost impossible to tell, what does this parameter means. And you almost always have to look up the implementation to tell what is going on. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UsersRepository.update(cache=True) # Wrong: UsersRepository.update(True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS426.html","text":"Forbids to use lambda inside loops. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS427.html","text":"Forbids to have unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we can not cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your code base at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have. Or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS428.html","text":"Forbids to have statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error. Or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS429.html","text":"Forbids to have multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grown pretty long. And you will not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS430.html","text":"Forbids to have nested functions. Reasoning Nesting functions is a bad practice. It is hard to test them, it is hard then to separate them. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures. Until you need them for decorators or factories. We also disallow to nest lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS431.html","text":"Forbids to use nested classes. Reasoning Nested classes are really hard to manage. You can not even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use different design (or metaclasses). Configuration This rule is configurable with --nested-classes-whitelist . Default: NESTED_CLASSES_WHITELIST Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0 0.13.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS432.html","text":"Forbids to use magic numbers in your code. What we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers actually mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS433.html","text":"Forbids to have nested imports in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look like. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS434.html","text":"Forbids to assign variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS435.html","text":"Forbids to multiply lists. Reasoning When you multiply lists - it does not create new values, it creates references to the existing value. It is not what people mean in 99.9% of cases. Solution Use list comprehension or loop instead. Example # Wrong: my_list = [1, 2, 3] * 3 See also https://github.com/satwikkansal/wtfPython#-explanation-8 0.12.0","title":"Found list multiply"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS436.html","text":"Forbids to import protected modules. Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import anything from protected modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass from some.module import _protected 0.3.0 0.11.0","title":"Found protected module import"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS437.html","text":"Forbids to use protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS438.html","text":"Forbids to raise StopIteration inside generators. Reasoning StopIteration should not be raised explicitly in generators. Solution Use return statement to get out of a generator. Example # Correct : def some_generator () : if some_value : return yield 1 # Wrong : def some_generator () : if some_value : raise StopIteration yield 1 See also https://docs.python.org/3/library/exceptions.html#StopIteration 0.12.0","title":"Found StopIteration raising inside generator"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS439.html","text":"Forbids to use unicode escape sequences in binary strings. Reasoning Binary strings do not work with unicode. Having unicode escape characters in there means that you have an error in your code. Solution Use regular strings when escaping unicode strings. Example # Correct: escaped = '\\u0041' # equals to 'A' # Wrong: escaped = b'\\u0040' # equals to b'\\\\u0040' 0.12.0","title":"Found unicode escape in a binary string: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS440.html","text":"Forbids to local and block variables to overlap. What we call local variables: Assigns and annotations Function arguments (they are local to the function body) What we call block variables: Imports Functions and async functions definitions Classes, methods, and async methods definitions For and async for loops variables Except block exception aliases We allow local variables to overlap theirselfs, we forbid block varibals to overlap theirselfs. Reasoning A lot of complex errors might happen when you shadow local varibales with block variables or when you shadow block variables with local variables. Solution Use names that do not overlap. Example # Correct: my_value = 1 my_value = my_value + 1 # Wrong: import my_value my_value = 1 # overlaps with import See also https://github.com/satwikkansal/wtfPython#-explanation-20 0.12.0","title":"Found block variables overlap: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS441.html","text":"Forbids to use control variables after the block body. What we call block control variables: for loop unpacked variables with context variables except exception names Reasoning Variables leaking from the blocks can damage your logic. It might not contain what you think they contain. Some variables even might be deleted right after the block, just like in except Exception as exc: where exc won't be in scope after except body. Solution Use names inside the scope they are defined. Create new functions to return values in case you need to use block variables: when searching for a value, etc. Example # Correct : for my_item in collection : print ( my_item ) # Wrong : for my_item in collection : ... print ( my_item ) See also https://github.com/satwikkansal/wtfPython#-explanation-32 0.12.0","title":"Found control variable used after block: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS442.html","text":"Forbids to shadow variables from outer scopes. We check function, method, and module scopes. While we do not check class scope. Because class level constants are not available via regular name, and they are scope to ClassName.var_name . Reasoning Shadowing can lead you to a big pile of strage and unexpected bugs. Solution Use different names and do not allow scoping. Example # Correct: def test(): ... def other(): test1 = 1 # Wrong: def test(): ... def other(): test = 1 # shadows ``test()` function 0.12.0","title":"Found outer scope names shadowing: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS443.html","text":"Forbids to use exlicit unhashable types as set items and dict keys. Reasoning This will resolve in TypeError in runtime. Solution Use hashable types to define set items and dict keys. Example # Correct: my_dict = {1: {}, (1, 2): [], (2, 3): {1, 2}} # Wrong: my_dict = {[1, 2]: [], {2, 3}: {1, 2}} 0.12.0","title":"Found unhashable item"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS444.html","text":"Forbids to use exlicit falsly-evaluated conditions with several keywords. We check: ast.While ast.Assert We do not check variables, attributes, calls, bool and bin operators, etc. We disallow constants and some expressions. Reasoning Some conditions clearly tell us that this node won't work correctly. So, we need to check that we can fix that. Solution Remove the unreachable node, or change the condition item. Example # Correct: assert some_variable while True : ... # Wrong: assert [] while False : ... 0.12.0 0.13.0","title":"Found wrong keyword condition"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS445.html","text":"Forbids to have wrong named keywords in starred dicts. Reasoning Using wrong keywords in starred dict. Eg.: print(**{'@': 1}) . Solution Don't use incorrect identifiers for keywords. Example # Correct : print ( ** { ' end ' : ' | ' } ) # Wrong : print ( ** { ' 3end ' : ' | ' } ) 0.13.0","title":"Found wrong named keyword in starred dict"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS446.html","text":"Forbids to use approximate constants. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare numbers as strings and raise this violation when they start with the same chars. Solution Use pre-defined constants. Example # Correct: from math import pi random_number = 3.15 too_short = 3.1 # Wrong: pi = 3.14 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. See also https://docs.python.org/3/library/math.html#constants 0.13.0","title":"Found approximate constant: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS447.html","text":"Forbid to use alphabet as a string. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare strings and raise this violation when they have exactly the same chars. Solution Use pre-defined constants. Example # Correct: import string UPPERCASE_ALPH = string . ascii_uppercase LOWERCASE_ALPH = string . ascii_lowercase # Wrong: GUESS_MY_NAME = \"abcde...WXYZ\" UPPERCASE_ALPH = \"ABCD...WXYZ\" LOWERCASE_ALPH = \"abcd...wxyz\" 0.13.0","title":"Found alphabet as strings: _"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS448.html","text":"Forbids the use of incorrect order of except . Note, we only check for built-in exceptions. Because we cannot statically identify the inheritance order of custom ones. Reasoning Using incorrect order of exceptions is error-prone, since you end up with some unreachable exception clauses. Solution Use correct order of exceptions. Example # Correct: try: ... except ValueError: ... except Exception: ... # Wrong: try: ... except Exception: ... except ValueError: ... See also https://bit.ly/36MHlzw 0.13.0","title":"Found incorrect exception order"},{"location":"wemake-python-styleguide/0.13.0/violations/best_practices/WPS449.html","text":"Forbids to define and use float keys. Reasoning float is a very ugly data type. It has a lot of \"precision\" errors. When we use float as keys we can hit this wall. We also cannot use float keys with lists by design. Solution Use other data types: integers, decimals, or use fuzzy logic. Example # Correct: some = {1: 'a'} some[1] # Wrong: some = {1.0: 'a'} some[1.0] 0.13.0","title":"Found float used as a key"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated. See also: https://sobolevn.me/2019/10/complexity-waterfall","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS200.html","text":"Forbids to have modules with complex lines. We are using Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measuring the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS201.html","text":"Forbids to have modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS202.html","text":"Forbids to have many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any differences between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS203.html","text":"Forbids to have modules with too many imported names. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imported names without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imported-names . Default: MAX_IMPORTED_NAMES 0.12.0","title":"Found module with too many imported names: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS204.html","text":"Forbids to have overused expressions in a module, function or method. Reasoning Overusing expression lead to losing the parts that can and should be refactored into methods and properties of objects. Solution Refactor expressions to be attribute, method, or a new variable. Configuration This rule is configurable with --max-module-expressions . Default: MAX_MODULE_EXPRESSIONS And with --max-function-expressions . Default: MAX_FUNCTION_EXPRESSIONS 0.12.0","title":"Found overused expression: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS210.html","text":"Forbids to have too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will find troubles to understand what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS211.html","text":"Forbids to have too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it shows that it is required to refactor this piece of code. It also indicates that function does too many things at once. Solution Split function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS212.html","text":"Forbids placing too many return statements into the function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS213.html","text":"Forbids putting too many expressions in a unit of code. Reasoning When there are too many expressions it means that this specific function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS214.html","text":"Forbids to have many methods in a single class. Reasoning Having too many methods might lead to the \"God object\". This kind of objects can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes. Then use composition or inheritance to refactor your code. This will protect you from \"God object\" anti-pattern. We do not make any difference between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you try to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you try to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into multiple ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS217.html","text":"Forbids placing too many await expressions into a function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where are we and what is going on. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS218.html","text":"Forbids placing too many asseert statements into a function. Reasoning When there are too many assert keywords, functions are starting to get really complex. It might indicate that your tests or contracts are too big. Solution Create rich assert statements, use higher-level contracts, or create special guard functions. Configuration This rule is configurable with --max-asserts . Default: MAX_ASSERTS 0.12.0","title":"Found too many assert statements: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS219.html","text":"Forbids to have consecutive expressions with too deep access level. We consider only these expressions as accesses: ast.Subscript ast.Attribute We do not treat ast.Call as an access, since there are a lot of call-based APIs like Django ORM, builder patterns, etc. Reasoning Having too deep access level indicates a bad design and overcomplicated data without proper API. Solution Split the expression into variables, functions or classes. Refactor the API for your data layout. Example # Correct: access level = 4 self . attr . inner . wrapper [ 1 ] # Correct: access level = 1 manager . filter (). exclude (). annotate (). values (). first () # Wrong: access level = 5 self . attr . inner . wrapper . method . call () # Wrong: access level = 5 # ``obj` has access level of 2: # ``.attr`, ``.call` # ``call()` has access level of 5: # ``.other`, ``[0]`, ``.field`, ``.type`, ``.boom` obj . attr . call (). other [ 0 ] . field . type . boom Configuration This rule is configurable with --max-access-level . Default: MAX_ACCESS_LEVEL 0.12.0","title":"Found too deep access level: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS220.html","text":"Forbids nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS221.html","text":"Forbids to have complex lines. We are using Jones Complexity algorithm to count complexity. What is Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS222.html","text":"Forbids to have conditions with too many logical operators. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS223.html","text":"Forbids to use many elif branches. Reasoning This rule is specifically important because of many elif branches indicate a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use some interface that just call a specific method without if . Or separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS224.html","text":"Forbids to have too many for statement within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS225.html","text":"Forbids to have too many except cases in a single try clause. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design. Since this way, one controlling structure will become too complex. And you will need to test a lot of paths your application might go. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS226.html","text":"Forbids to over-use string constants. We allow to use strings without any restrictions as annotations for variables, arguments, return values, and class attributes. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant. And should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS227.html","text":"Forbids to yield too long tuples. Reasoning Long yield tuples complicate generator using. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS228.html","text":"Forbids to have too long compare expressions. Reasoning To long compare expressions indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, seprate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS229.html","text":"Forbids to have try blocks with too long bodies. Reasoning Having too many statements inside your try block can lead to situations when some different statement raises an exception and you are not aware of it since it is not expected. Solution Move things out of the try block or create new functions. The less lines you have in your try block - the safer you are from accidental errors. Configuration This rule is configurable with --max-try-body-length . Default: MAX_TRY_BODY_LENGTH 0.12.0","title":"Found too long try body length: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS230.html","text":"Forbids to have try blocks with too long bodies. We only check static definitions in a form of self.public = ... . We do not count parent attributes. We do not count properties. We do not count annotations. We do not count class attributes. Reasoning Having too many public instance attributes means that your class is too complex in terms of coupling. Other classes and functions will rely on these concrete fields instead of better abstraction layers. Solution Make some attributes protected. Split this class into several ones. If class is a Data Transder Object, then use @dataclass decorator. Configuration This rule is configurable with --max-attributes . Default: MAX_ATTRIBUTES See also https://en.wikipedia.org/wiki/Coupling_(computer_programming) 0.12.0","title":"Found too many public instance attributes"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS231.html","text":"Forbids to have functions with too high cognitive complexity. Reasoning People are not great at reading and iterpretating code in their heads. That's why code with a lot of nested loops, conditions, exceptions handlers, and context managers is hard to read and understand. Solution Rewrite your code to be simplier. Use flat structures and conditions, remove nested loops. Configuration This rule is configurable with --max-cognitive-score . Default: MAX_COGNITIVE_SCORE See also https://en.wikipedia.org/wiki/Cognitive_complexity https://pypi.org/project/cognitive-complexity/ https://github.com/Melevir/flake8-cognitive-complexity 0.13.0","title":"Found too high function cognitive complexity: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS232.html","text":"Forbids to have modules with too high average cognitive complexity. Reasoning Modules with lots of functions might hide cognitive complexity inside many small and relatevely simple functions. Solution Rewrite your code to be simplier. Or use several modules. Configuration This rule is configurable with --max-cognitive-average . Default: MAX_COGNITIVE_AVERAGE See also https://en.wikipedia.org/wiki/Cognitive_complexity 0.13.0","title":"Found too high module cognitive complexity: _"},{"location":"wemake-python-styleguide/0.13.0/violations/complexity/WPS233.html","text":"Forbids too long call chains. Reasoning Too long call chains are overcomplicated and indicators of bad API design. Solution Split the expression into variables, functions or classes. Refactor the API to allow higher-level access to functions. Configuration This rule is configurable with --max-call-level . Default: MAX_CALL_LEVEL 0.13.0","title":"Found too lang call chain length: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/index.html","text":"These checks limit the Python's inconsistency. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to bare with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right. And we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective. But, we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS300.html","text":"Forbids to have imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS301.html","text":"Forbids to use imports like import os.path . Reasoning There too many different ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS302.html","text":"Forbids to use u string prefix. Reasoning We do not need this prefix since python2 . But, it is still possible to find it inside the codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS303.html","text":"Forbids to use underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS304.html","text":"Forbids to use partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and starting zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS305.html","text":"Forbids to use f strings. Reasoning f strings loses context too often and they are hard to lint. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS306.html","text":"Forbids to write classes without base classes. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... See also https://google.github.io/styleguide/pyguide.html#39-classes 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS307.html","text":"Forbids to have multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS308.html","text":"Forbids to have compares between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the compare, will always be the same. Solution Remove the constant compare and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant compare"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS309.html","text":"Forbids comparison where argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle ordering of the arguments all the time. Bring consistency to the compare! Solution Refactor your compare expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS310.html","text":"Forbids to use capital X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase. Which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written in lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS311.html","text":"Forbids comparison where multiple in checks. Reasoning Using multiple in is unreadable. Solution Refactor your compare expression to use several and conditions or separate if statements in case it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS312.html","text":"Forbids to have compares between the same variable. Reasoning When the same variables are compared it is typically an indication of a mistake, since the Boolean value of the compare will always be the same. Solution Remove the same variable compare and any associated dead code. Example # Wrong : a = 1 if a < a : do_something () else : do_something_else () # Correct : do_something () 0.3.0","title":"Found compare between same variable"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS313.html","text":"Enforces to separate parenthesis from the keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between keyword and open paren. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parens right after a keyword"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS314.html","text":"Forbids using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Conditional always evaluates to same result"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS315.html","text":"Forbids extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Founded extra object in parent classes list"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS316.html","text":"Forbids multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into tuple or we are just using two context managers. Solution Use several context managers. Or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS317.html","text":"Forbids to use incorrect parameters indentation. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS318.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') This rule is consistent with the \"Vertical Hanging Indent\" option for multi_line_output setting of isort . To avoid conflicting rules, you should set multi_line_output = 3 in the isort settings. See also https://github.com/timothycrosley/isort#multi-line-output-modes https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/isort.toml 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS319.html","text":"Forbids to have brackets in the wrong position. Reasoning You can do bizzare things with bracket positioning in python. We require all brackets to be consistent. Solution Place bracket on the same line, in case of a single line expression. Or place the bracket on a new line in case of a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS320.html","text":"Forbids to use multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS321.html","text":"Forbids to use uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase modifiers. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS322.html","text":"Forbids to use triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS323.html","text":"Enforces to have an extra empty line after the coding comment. Reasoning Since we use flake8-coding <https://github.com/tk0miya/flake8-coding>`_ as a part of our linter we care about extra space after this coding comment. This is done for pure consistency. Why should we even care about this magic coding comment? For several reasons. First, explicit encoding is always better that an implicit one, different countries still use some non utf-8 encodings as a default. But, people might override it with other encodings in a comment. Do you know how much pain it can cause to you? We still know that python3 uses utf-8 inside. Second, some tools break because of this incorrect encoding comment. Including, django , flake8 , and tokenize`` core module. It is very hard to notice these things when they happen. Solution Add an empty line between coding magic comment and your code. Example # Correct: # coding: utf-8 SOME_VAR = 1 # Wrong: # coding: utf-8 SOME_VAR = 1 0.7.0","title":"Found missing empty line between coding magic comment and code"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS324.html","text":"Enforces to have consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS325.html","text":"Enforces to have consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS326.html","text":"Forbids to use implicit string concatenation. Reasoning This is error-prone, since you can possibly miss a comma in a collection of string and get an implicit concatenation. And because there are different and safe ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS327.html","text":"Forbids to use meaningless continue node in loops. Reasoning Placing this keyword in the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue node from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS328.html","text":"Forbids to use meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by acedent. This might be also an overuse of syntax. Solution Remove node or make sure it makes sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS329.html","text":"Forbids to use meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS330.html","text":"Forbids the use of unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS331.html","text":"Forbids local variable that are only used in return statements. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 # Wrong : def some_function () : some_value = 1 return some_value 0.9.0","title":"Found local variable that are only used in return statements"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS332.html","text":"Forbids to have implicit ternary expressions. Reasoning This is done for consistency and readability reasons. We believe that explicit ternary is better for readability. This also allows you to identify hidden conditionals in your code. Solution Refactor to use explicit ternary, or if condition. Example # Correct : some = one if cond () else two # Wrong : some = cond () and one or two 0.10.0","title":"Found implicit ternary expression"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS333.html","text":"Forbids to have implicit complex compare expressions. Reasoning Two compares in python that are joined with and operator mean that you indeed have a complex compare with tree operators. Solution Refactor your compare without and but with the third operator. Notice, that you might have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS334.html","text":"Forbids to have reversed order complex compare expressions. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Reverse the order, so the smallest element comes the first and the biggest one comes the last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex compare"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS335.html","text":"Forbids to use wrong for loop iter targets. We forbid to use: Lists and list comprehensions Sets and set comprehensions Dicts and dict comprehensions Generator expressions Empty tuples Reasoning Using lists, dicts, and sets do not make much sense. You can use tuples instead. Using comprehensions implicitly create a two level loops, that are hard to read and deal with. Solution Use tuples to create explicit iterables for for loops. In case you are using a comprehension, create a new variable. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0 0.12.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS336.html","text":"Forbids explicit string concat in favour of .format method. However, we still allow multiline string concat as a way to write long strings that does not fit the 80-chars rule. Reasoning When formating strings one must use .format and not any other formatting methods like % , + , or f . This is done for consistency reasons. Solution Join strings together if you can, or use .format method. Example # Correct: x = 'ab: {0}'.format(some_data) # Wrong: x = 'a' + 'b: ' + some_data 0.12.0","title":"Found explicit string concat"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS337.html","text":"Forbids multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has. And it decreases readability of the code. Solution Divide multiline conditions to some if condition. Or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS338.html","text":"Forbids to have incorrect order of methods inside a class. We follow the same ordering: __new__ __init__ public and magic methods protected methods private methods (we discourage using them) We follow \"Newspaper order\" where the most important things come first. Reasoning It is hard to read classes where API declarations are bloated with implementation details. We need to see the important stuff first, then we can go deeper in case we are interested. Solution Reorder methods inside your class to match our format. 0.12.0","title":"Found incorrect order of methods in a class"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS339.html","text":"Forbids to use meaningless zeros. We discorauge using meaningless zeros in float, binary, octal, hex, and exponential numbers. Reasoning There are \\~infinite ways to write these numbers by adding meaningless leading zeros to the number itself. 0b1 is the same as 0b01 and 0b001 . How a language can be called consistent if you can write numbers in an infinite ways? It hurts readability and understanding of your code. Solution Remove meaningless leading zeros. Example # Correct: numbers = [1.5, 0b1, 0o2, 0x5, 10e10] # Wrong: numbers = [1.50, 0b00000001, 0o0002, 0x05, 10e010] 0.12.0","title":"Found number with meaningless zeros: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS340.html","text":"Forbids to extra + signs in the exponent. Reasoning Positive exponent is positive by default, there's no need to write an extra + sign. We enforce consistency with this rule. Solution Remove meaningless + sign from the exponent. Example # Correct: number = 1e1 + 1e-1 # Wrong: number = 1e+1 0.12.0","title":"Found exponent number with positive exponent: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS341.html","text":"Forbids to use letters as hex numbers. Reasoning One can write 0xA and 0xa which is inconsistent. This rule enforces upper-case letters in hex numbers. Solution Use uppercase letters in hex numbers. Example # Correct: number = 0xABCDEF # Wrong: number = 0xabcdef 0.12.0","title":"Found wrong hex number case: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS342.html","text":"Forbids to use \\\\ escape sequences inside regular strings. Reasoning It is hard to read escape sequencse inside regular strings, because they use \\\\ double backslash for a single character escape. Solution Use raw strings r'' to rewrite the escape sequence with a \\ single backslash. Example # Correct: escaped = [r'\\n', '\\n'] # Wrong: escaped = '\\\\n' 0.12.0","title":"Found implicit raw string: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS343.html","text":"Forbids to use uppercase complex number suffix. Reasoning Numbers should be consistent. Solution Use lowercase suffix for imaginary part. Example # Correct: complex_number = 1j # Wrong: complex_number = 1J 0.12.0","title":"Found wrong complex number suffix: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS344.html","text":"Forbids to explicitly divide by zero. Reasoning This will just throw ZeroDivisionError in case that's what you need: just throw it. No need to use undefined meth behaviours. Or it might be just a typo / mistake, then fix it. Solution Use ZeroDivisionError or fix your number not to be 0 . Example # Correct: raise ZeroDivisionError() # Wrong: 1 / 0 0.12.0","title":"Found explicit zero division"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS345.html","text":"Forbids to use meaningless math operations with 0 and 1 . Reasoning Adding and substracting zero does not change the value. There's no need to do that. Multipling by zero is also redundant: it can be replaced with explicit 0 assign. Multiplying and dividing by 1 is also meaningless. Solution Remove useless zero operations. Example # Correct: number = 1 zero = 0 one = 1 # Wrong: number = 1 + 0 * 1 zero = some * 0 / 1 one = some ** 0 ** 1 0.12.0","title":"Found meaningless number operation"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS346.html","text":"Forbids to have double minus operations. Reasoning Having two operations is harder than having just one. Two negations are harder than one positive expression. Two negations equal to one positive expression. Positive and negative equal to one negative. Solution Replace double minus operation to a single one with plus. Replace 'plus-minus' operation to a single one with minus. Example # Correct: number = 3 + 1 number += 6 number -= 2 # Wrong: number = 3 - -1 number -= -6 number += -2 0.12.0","title":"Found wrong operation sign"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS347.html","text":"Forbids imports that may cause confusion outside of the module. Reasoning See datetime.* in code? You know that it's from datetime. See BaseView in a Django project? You know where it is from. See loads ? It can be anything: yaml , toml , json , etc. See VAGUE_IMPORTS_BLACKLIST for the full list of bad import names. Example # Correct: import json json . loads ( content ) # Wrong: from json import loads loads ( content ) 0.13.0","title":"Found vague import that may cause confusion: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS348.html","text":"Forbids to start lines with a dot. Reasoning We enforce strict consitency rules about how to break lines. We also enforce strict rules about multi-line parameters. Starting new lines with the dot means that this rule is broken. Solution Use () to break lines in a complex expression. Example # Correct: some = MyModel.objects.filter( ..., ).exclude( ..., ).annotate( ..., ) # Wrong some = ( MyModel.objects.filter(...) .exclude(...) .annotate(...) ) 0.13.0","title":"Found a line that starts with a dot"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS349.html","text":"Forbids the use of redundant components in a subscript's slice. Reasoning We do it for consistency reasons. Example # Correct: array[:7] array[3:] # Wrong: x[0:7] x[3:None] 0.13.0","title":"Found redundant subscript slice: _"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS350.html","text":"Enforce using augmented assign pattern. Reasoning a += b is short and correct version of a = a + b . Why not using the short version? Example # Correct: a += b # Wrong: a = a + b 0.13.0","title":"Found usable augmented assign pattern"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS351.html","text":"Forbids the use of unnecessary literals in your code. Reasoning We discourage using primitive calls to get default type values. There are better ways to get these values. Solution Use direct default values of the given type Example # Correct: default = 0 # Wrong: default = int() 0.13.0","title":"Found unnecessary literals"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS352.html","text":"Forbids multiline loops. Reasoning It decreased the readability of the code. Solution Use single line loops and create new variables in case you need to fit too many logic inside the loop definition. Example # Correct : for num in some_function ( arg1 , arg2 ) : ... # Wrong : for num in range ( arg1 , arg2 , ) : ... 0.13.0","title":"Found multiline loop"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS353.html","text":"Forbids to use yield from with several nodes. We allow to yield from tuples, names, attributes, calls, and subscripts. Reasoning We enforce consitency when yielding values from tuple instead of any other types. It also might be an error when you try to yield from something that is not iterable. Solution Use allowed node types with yield from . Example # Correct: yield from (1, 2, 3) yield from some # Wrong: yield from [1, 2, 3] 0.13.0","title":"Found incorrect yield from target"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS354.html","text":"Forbids to have consecutive yield expressions. We raise this violation when we find at least two consecutive yield expressions. Reasoning One can write multiple yield nodes in a row. That's incosistent. Because we have yield from form. Solution It can be easily changed to yield from (...) format. 0.13.0","title":"Found consecutive yield expressions"},{"location":"wemake-python-styleguide/0.13.0/violations/consistency/WPS355.html","text":"Forbids useless blank lines before and after brackets. Reasoning We do this for consistency. Solution Remove blank lines from the start and from the end of a collection. Example # Correct: arr = [ 1, 2 ] # Wrong: arr = [ 1, 2 ] 0.13.0","title":"Found an unnecessary blank line before a bracket"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII chars for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Do not define unused variables unless you are unpacking other values as well Do not use multiple underscores ( __ ) to create unused variables Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Enum fields also must use snamek_case Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Keyword-only arguments must be separated from other arguments with * Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called TT or KT or VT Covariant and contravariant types should be marked with Cov and Contra suffixes, in this case, one letter can be dropped: TCov and KContra","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS100.html","text":"Forbids to use blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS101.html","text":"Forbids to use any magic names except whitelisted ones. Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS102.html","text":"Forbids to use module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS110.html","text":"Forbids to have blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the full list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS111.html","text":"Forbids to have too short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. We do not count trailing and leading underscores when calculating length. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0 0.12.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS112.html","text":"Forbids to have private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS113.html","text":"Forbids to use the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.1.0 0.13.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS114.html","text":"Forbids to have names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored name pattern: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS115.html","text":"Forbids to use anything but snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS116.html","text":"Forbids to use more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS117.html","text":"Forbids to name your variables as self , cls , and mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS118.html","text":"Forbids to have long short variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS119.html","text":"Forbids to use unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS120.html","text":"Forbids to use trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS121.html","text":"Forbids to have use variables that are marked as unused. We discourage using _ at all and variables that start with _ only inside functions and methods as local variables. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0 0.12.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS122.html","text":"Forbids to define explicit unused variables. Reasoning While it is ok to define unused variables when you have to, like when unpacking a tuple, it is totally not ok to define explicit unusued variables in cases like assignment, function return, exception handling, or context managers. Why do you need this explicitly unused variables? Solution Remove all unused variables definition. Example # Correct: my_function() first, _second = some_tuple() print(first) # Wrong: _ = my_function() _first, _second = some_tuple() This rule checks: assigns, context managers, except clauses. 0.12.0","title":"Found all unused variables definition: _"},{"location":"wemake-python-styleguide/0.13.0/violations/naming/WPS123.html","text":"Forbids to define unused variables with multiple underscores. Reasoning We only use _ as a special definition for an unused variable. Other variables are hard to read. It is unclear why would one use it. Solution Rename unused variables to _ or give it some more context with an explicit name: _context . Example # Correct: some_element, _next_element, _ = some_tuple() some_element, _, _ = some_tuple() some_element, _ = some_tuple() # Wrong: some_element, _, __ = some_tuple() 0.12.0","title":"Found wrong unused variable name: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beatiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS600.html","text":"Forbids to subclass lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS601.html","text":"Forbids to shadow class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS602.html","text":"Forbids to use @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS603.html","text":"Forbids to use some magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS604.html","text":"Forbids to use incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS605.html","text":"Forbids to have methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so can not access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS606.html","text":"Forbids to have anything else than a class as a base class. We only check base classes and not keywords. They can be anything you need. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Use annotation future import in case you use strings in base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0 0.12.0","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS607.html","text":"Forbids to have incorrect __slots__ definition. Things that this rule checks: That __slots__ is a tuple, name, attribute, star, or call That __slots__ do not have duplicates That __slots__ do not have empty strings or invalid python names Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Use snake_case to define attributes in __slots__ . Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = (* Test . __slots__ , 'child' ) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0 0.12.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS608.html","text":"Forbids to use super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS609.html","text":"Forbids to use direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS610.html","text":"Forbids to make some magic methods async. We allow to make __anext__ , __aenter__ , __aexit__ async. We also allow custom magic methods to be async. See ASYNC_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted async magic methods. Reasoning Defining the magic methods as async which are not supposed to be async would not work as expected. Solution Do not make this magic method async. Example # Correct: class Test ( object ): def __lt__ ( self , other ): ... # Wrong: class Test ( object ): async def __lt__ ( self , other ): ... See also https://docs.python.org/3/reference/datamodel.html 0.12.0","title":"Found forbidden async magic method usage: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS611.html","text":"Forbids to use yield inside of several magic methods. We allow to make __iter__ a generator. See YIELD_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted generator magic methods. Reasoning Python's datamodel is strict. You cannot make generators from random magic methods. This rule enforces it. Solution Remove yield from a magic method or rename it to be a custom method. Example # Correct: class Example(object): def __init__(self): ... # Wrong: class Example(object): def __init__(self): yield 10 See also https://docs.python.org/3/reference/datamodel.html 0.3.0 0.11.0 0.12.0","title":"Found forbidden yield magic method usage"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS612.html","text":"Forbids to have useless overwritten methods. Reasoning Overwriting method without any changes does not have any positive impact. Solution Do not overwrite method in case you do not want to do any changes inside it. Example # Correct: class Test ( Base ): ... # Wrong: class Test ( object ): def method ( self , argument ): return super (). method ( argument ) 0.12.0","title":"Found useless overwritten method: _"},{"location":"wemake-python-styleguide/0.13.0/violations/oop/WPS613.html","text":"Forbids to use super() with incorrect methods or properties access. Reasoning Can only use super() method that matches the following context. super().some() and super().some in Child.some() , and super().prop and super().prop() in Child.prop Solution Use super() methods and properties with the correct context. Example # Correct: class Child ( Parent ): def some_method ( self ): original = super (). some_method () # Wrong: class Child ( Parent ): def some_method ( self ): other = super (). other_method () 0.13.0","title":"Found incorrect super() call context: _"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS500.html","text":"Forbids to use else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS501.html","text":"Forbids to use finally in try block without except block. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS502.html","text":"Forbids to have simplifiable if conditions. Reasoning This complex construction can cause frustration among other developers. It is longer, more verbose, and more complex. Solution Use bool() to convert test values to boolean values. Or just leave it as it is in case when your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS503.html","text":"Forbids to use useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS504.html","text":"Forbids to use negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS505.html","text":"Forbids to use nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS506.html","text":"Forbids to define useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS507.html","text":"Forbids to have unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS508.html","text":"Forbids to use not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS509.html","text":"Forbids to nest ternary expressions in some places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS510.html","text":"Forbids to use in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS511.html","text":"Forbids to multiple isinstance calls with the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS512.html","text":"Forbids to multiple isinstance calls with tuples of a single item. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single varaible. Example # Correct: isinstance(some, (int, float)) isisntance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS513.html","text":"Forbids to have implicit elif conditions. Reasoning Nested if in else cases are bad for readability because of the nesting level. Solution Use elif on the same level. Example # Correct : if some : ... elif other : ... # Wrong : if some : ... else : if other : ... 0.12.0","title":"Found implicit elif condition"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS514.html","text":"Forbids to use multiple equality compare with the same variable name. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0 0.12.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS515.html","text":"Forbids to use open() with a context manager. Reasoning When you open() something, you need to close it. When using a context manager - it is automatically done for you. When not using it - you might find yourself in a situation when file is not closed and is not accessable anymore. Solution Refactor open() call to use with . Example # Correct: with open(filename) as file_obj: ... # Wrong: file_obj = open(filename) 0.12.0","title":"Found open() used without a context manager"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS516.html","text":"Forbids to compare types with type() function. Reasoning When you compare types with type() function call it means that you break polymorphism and dissallow child classes of a node to work here. That's incorrect. Solution Use isinstance to compare types. Example # Correct : print ( something , type ( something )) # Wrong : if type ( something ) == int : ... 0.12.0","title":"Found type() used to compare types"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS517.html","text":"Forbids to have useless starred expressions. Reasoning Using starred expression with constants is useless. This piece of code can be rewritten to be flat. Eg.: print(*[1, 2, 3]) is print(1, 2, 3) . Solution Refactor your code not to use starred expressions with list , dict , tuple , and set constants. Use regular argument passing instead. Example # Correct: my_list = [1, 2, 3, *other_iterable] # Wrong: print(*[1, 2, 3], ** {{}} ) 0.12.0","title":"Found pointless starred expression"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS518.html","text":"Forbids to have implicit enumerate() calls. Reasoning Using range(len(...)) is not pythonic. Python uses collection iterators, not index-based loops. Solution Use enumerate(...) instead of range(len(...)) . Example # Correct: for index , person in enumerate ( people ): ... # Wrong: for index in range ( len ( people )): ... See also https://docs.python.org/3/library/functions.html#enumerate 0.12.0","title":"Found implicit enumerate() call"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS519.html","text":"Forbids to have implicit sum() calls. When summing types different from numbers, you might need to provide the second argument to the sum function: sum([[1], [2], [3]], []) You might also use str.join to join iterable of strings. Reasoning Using for loops with += assign inside indicates that you iteratively sum things inside your collection. That's what sum() builtin function does. Solution Use sum(...) instead of a loop with += operation. Example # Correct : sum_result = sum ( get_elements ()) # Wrong : sum_result = 0 for to_sum in get_elements () : sum_result += to_sum See also https://docs.python.org/3/library/functions.html#sum https://docs.python.org/3/library/stdtypes.html#str.join 0.12.0","title":"Found implicit sum() call"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS520.html","text":"Forbids to compare with explicit falsy constants. We allow to compare with falsy numbers, strings, booleans, None . We disallow complex constants like tuple, dicts, and lists. Reasoning When comparing something with explicit falsy constants what we really mean is not something . Solution Use not with your variable. Fix your data types. Example # Correct : if not my_check : ... if some_other is None : ... if some_num == 0 : ... # Wrong : if my_check == []: ... 0.12.0","title":"Found compare with falsy constant"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS521.html","text":"Forbids to compare values with constants using is or is not . However, we allow to compare with None and booleans. Reasoning is compares might not do what you want them to do. Firstly, they check for the same object, not equality. Secondly, they behave unexpectedly even with the simple values like 257 . Solution Use == to compare with constants. Example # Correct : if my_check == [ 1 , 2 , 3 ]: ... # Wrong : if my_check is [ 1 , 2 , 3 ]: ... See also https://stackoverflow.com/a/33130014/4842742 0.12.0","title":"Found wrong is compare"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS522.html","text":"Forbids to use implicit primitives in a form of lambda functions. Reasoning When you use lambda that returns a primitive value and takes no arguments, it means that you should use a primitive type instead. Solution Replace lambda with int , float , list , or any other primitive. Example # Correct: defaultdict(int) # Wrong: defaultdict(lambda: 0) 0.13.0","title":"Found implicit primitive in a form of lambda"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS523.html","text":"Forbids unpythonic swap variables. We check for a = b; b = a sequences. Reasoning This looks like a failed attempt to swap. Solution Use standard way to swap two variables. Example # Correct: a, b = b, a # Wrong: a = b b = a temp = a a = b b = temp 0.13.0","title":"Found incorrectly swapped variables"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS524.html","text":"Forbids to use misrefactored self assignment. Reasoning Self assignment does not need to have the same operand on the left hand side and on the right hand side. Solution Refactor you code to use multiple self assignments or fix your code. Example # Correct: test += 1 test *= 2 # Wrong: test += test + 1 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. 0.13.0","title":"Found self assignment  with refactored assignment"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS525.html","text":"Forbids comparisons where in is compared with single item container. Reasoning in comparison with a container which contains only one item looks like overhead and unneeded complexity. Solution Refactor your code to use == instead in . Example # Correct: a == 's' # Wrong: a in {'s'} 0.13.0","title":"Found wrong \"in\" compare with single item container"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS526.html","text":"Forbids to use yield inside for loop instead of yield from . Reasoning It is known that yield from is a semantically identical to a for loop with a yield inside. But, it is way more readable. Solution Use yield from some iterable directly instead iterating over it inside a loop and yield it one by one. Example # Correct : yield from some () # Wrong : for item in some () : yield item 0.13.0","title":"Found implicit yield from usage"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS527.html","text":"Forces using tuples as arguments for some functions. Reasoning For some functions, it is better to use tuples instead of another iterable types (list, sets,...) as arguments. Solution Use tuples as arguments. Example # Correct: a = frozenset((2,)) # Wrong: a = frozenset([2]) See TUPLE_ARGUMENTS_METHODS for full list of methods that we check for. 0.13.0","title":"Found not a tuple used as an argument"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS528.html","text":"Forbids to use implicit .items() iterator. Reasoning When iterating over collection it is easy to forget to use .items() when you need to access both keys and values. So, when you access the iterable with the key inside a for loop, that's a sign to refactor your code. Solution Use .items() with direct keys and values when you need them. Example # Correct : for some_key , some_value in collection . items () : print ( some_key , some_value ) # Wrong : for some_key in collection : print ( some_key , collection [ some_key ] ) 0.13.0","title":"Found implicit .items() usage"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS529.html","text":"Forbids to use implicit .get() dict method. Reasoning When using in with a dict key it is hard to keep the code clean. It is more convinient to use .get() and check for None later. Solution Use .get() with the key you need. Check for None in case you need it, or just act with the default value of the same type. Example # Correct : value = collection . get ( key ) if value is not None : print ( value ) # Wrong : if key in collection : print ( collection [ key ] ) 0.13.0","title":"Found implicit .get() dict usage"},{"location":"wemake-python-styleguide/0.13.0/violations/refactoring/WPS530.html","text":"Forbids to use implicit negative indexes. Reasoning There's no need in getting the length of an iterable and then having a negative offset, when you can specify negative indexes in the first place. Solution Use negative indexes. Example # Correct: some_list[-1] # Wrong: some_list[len(some_list) - 1] 0.13.0","title":"Found implicit negative index"},{"location":"wemake-python-styleguide/0.13.0/violations/system/index.html","text":"These checks ensures that our internal checks passes. For example, we can report violations from this group when some exception occur during the linting process or some dependencies are missing.","title":"WPS0xx System"},{"location":"wemake-python-styleguide/0.13.0/violations/system/WPS000.html","text":"Happens when we get unhandled exception during the linting process. All this violations should be reported to the main issue tracker. We ideally should not produce these violations at all. See also https://github.com/wemake-services/wemake-python-styleguide/issues 0.13.0","title":"Internal error happened, see log. Please, take some time to report it"},{"location":"wemake-python-styleguide/0.14.0/index.html","text":"","title":"0.14.0"},{"location":"wemake-python-styleguide/0.14.0/configuration/ALLOWED_DOMAIN_NAMES.html","text":"Domain names that are removed from variable names' blacklist.","title":"ALLOWED_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.14.0/configuration/FORBIDDEN_DOMAIN_NAMES.html","text":"Domain names that extends variable names' blacklist.","title":"FORBIDDEN_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.14.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_ACCESS_LEVEL.html","text":"Maximum number of access level in an expression.","title":"MAX_ACCESS_LEVEL"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_ANN_COMPLEXITY.html","text":"Maximum number of nested annotations.","title":"MAX_ANN_COMPLEXITY"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_ASSERTS.html","text":"Maximum number of assert statements in a function.","title":"MAX_ASSERTS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_ATTRIBUTES.html","text":"Maximum number of public attributes in a single class.","title":"MAX_ATTRIBUTES"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_AWAITS.html","text":"Maximum number of await expressions for functions or methods.","title":"MAX_AWAITS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_CALL_LEVEL.html","text":"Maximum number of call chains.","title":"MAX_CALL_LEVEL"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_COGNITIVE_AVERAGE.html","text":"Maximum amount of average cognitive complexity per module.","title":"MAX_COGNITIVE_AVERAGE"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_COGNITIVE_SCORE.html","text":"Maximum amount of cognitive complexity per function.","title":"MAX_COGNITIVE_SCORE"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_FUNCTION_EXPRESSIONS.html","text":"Maximum amount of same expressions per function.","title":"MAX_FUNCTION_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_IMPORTED_NAMES.html","text":"Maximum number of imported names in a single module.","title":"MAX_IMPORTED_NAMES"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_IMPORT_FROM_MEMBERS.html","text":"Maximum number of names that can be imported from module.","title":"MAX_IMPORT_FROM_MEMBERS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_MODULE_EXPRESSIONS.html","text":"Maximum amount of same expressions per module.","title":"MAX_MODULE_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.14.0/configuration/MAX_TRY_BODY_LENGTH.html","text":"Maximum amount of try node body length.","title":"MAX_TRY_BODY_LENGTH"},{"location":"wemake-python-styleguide/0.14.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.14.0/configuration/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.14.0/constants/ALL_MAGIC_METHODS.html","text":"List of all magic methods from the python docs.","title":"ALL_MAGIC_METHODS"},{"location":"wemake-python-styleguide/0.14.0/constants/ASYNC_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be async.","title":"ASYNC_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/LITERALS_BLACKLIST.html","text":"List of literals without arguments we forbid to use.","title":"LITERALS_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MATH_APPROXIMATE_CONSTANTS.html","text":"Approximate constants which real values should be imported from math module.","title":"MATH_APPROXIMATE_CONSTANTS"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_COMPARES.html","text":"Maximum number of compare nodes in a single expression.","title":"MAX_COMPARES"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_CONDITIONS.html","text":"Maximum number of conditions in a single if or while statement.","title":"MAX_CONDITIONS"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_ELIFS.html","text":"Maximum number of elif blocks in a single if condition:","title":"MAX_ELIFS"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_EXCEPT_CASES.html","text":"Maximum number of except cases in a single try clause.","title":"MAX_EXCEPT_CASES"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.14.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.14.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.14.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.14.0/constants/TUPLE_ARGUMENTS_METHODS.html","text":"List of functions in which arguments must be tuples.","title":"TUPLE_ARGUMENTS_METHODS"},{"location":"wemake-python-styleguide/0.14.0/constants/UNREADABLE_CHARACTER_COMBINATIONS.html","text":"List of characters sequences that are hard to read.","title":"UNREADABLE_CHARACTER_COMBINATIONS"},{"location":"wemake-python-styleguide/0.14.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/constants/YIELD_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be generators.","title":"YIELD_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is hidden inside countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits. Then we forbid to use this bad code forever. So, this error will never return to our codebase.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS400.html","text":"Restricts to use several control (or magic) comments. We do not allow to use: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast This violation is reported at the top of the module, so it cannot be locally ignored. Reasoning We cover several different use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can already use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow to use # type: ignore comment. Since sometimes it is totally required. Example # Correct : type = MyClass . get_type () # noqa : WPS125 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS401.html","text":"Forbids to use empty doc comments ( #: ). Reasoning Doc comments are used to provide a documentation. But supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment. Or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS402.html","text":"Forbids to use too many # noqa comments. We count it on a per-module basis. Reasoning Having too many # noqa comments make your code less readable and clearly indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. Configuration This rule is configurable with --max-noqa-comments . Default: MAX_NOQA_COMMENTS 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS403.html","text":"Forbids to use too many # pragma: no cover comments. We count it on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments clearly indicates that there's something wrong with it. Moreover, it makes your tests useless, since they do not cover a big partion of your code. Solution Refactor your code to much the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS404.html","text":"Forbids to use complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or http requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS405.html","text":"Forbids to use anything rather than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' person ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS406.html","text":"Forbids to use anything rather than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS407.html","text":"Forbids mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List , and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS408.html","text":"Forbids to use the same logical conditions in one expression. Reasoning Using the same name in logical condition more that once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicating condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0 0.13.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS409.html","text":"Forbids to heterogenous operators in one compare. Note, that we allow to mix > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogenous compare"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS410.html","text":"Forbids to have some module level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use importlib.metadata (or importlib_metadata on python \\< 3.8) if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS411.html","text":"Forbids to have empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS412.html","text":"Forbids to have logic inside __init__ module. Reasoning If you have logic inside the __init__ module it means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic into the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow to have some contents inside the __init__ module: comments, since they are dropped before AST comes in play docs string, because sometimes it is required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case this rule can be configured. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS413.html","text":"Forbids to use __getattr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS414.html","text":"Forbids to have tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique. So, do not use it. Solution Use unpacking with only variables, not any other entities. Example # Correct: first, second = some() # Wrong: first, some_dict['alias'] = some() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS415.html","text":"Forbids to have the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Other one will always be ignored. So, that is clearly an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS416.html","text":"Forbids to have yield keyword inside comprehensions. This is a SyntaxError starting from python3.8 . Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in a foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords. Or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS417.html","text":"Forbids to have duplicate items in hashes. Reasoning When you explicitly put duplicate items in set literals or in dict keys it just does not make any sense. Since hashes cannot contain duplicate items and they will be removed anyway. Solution Remove duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations 0.7.0 0.11.0 0.12.0","title":"Found non-unique item in hash: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS418.html","text":"Forbids to have duplicate items in set literals. Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS419.html","text":"Forbids to use multiple returning paths with try / except case. Note, that we check for any return , break , or raise nodes. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be actually returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Correct : try : return 1 except YourException : ... finally : clear_things_up () # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0 0.12.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS420.html","text":"Forbids to use some python keywords. Reasoning Using some keywords generally gives you more pain that relieve. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no usecase for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale. And leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS421.html","text":"Forbids to call some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid to use them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS422.html","text":"Forbids to use __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS423.html","text":"Forbids to use NotImplemented error. Reasoning These two violations look so similar. But, these violations have different use cases. Use cases of NotImplemented is too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS424.html","text":"Forbids to use BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS425.html","text":"Forbids to pass booleans as non-keyword parameters. Reasoning Passing boolean as regular positional parameters is very non-descriptive. It is almost impossible to tell, what does this parameter means. And you almost always have to look up the implementation to tell what is going on. The only exception from this rule is passing booleans as non-keyword argument when it is the only passed argument. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UserRepository.update(True) UsersRepository.add(user, cache=True) # Wrong: UsersRepository.add(user, True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS426.html","text":"Forbids to use lambda inside loops. We check while , for , and async for loop bodies. We also check comprehension value parts. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 0.14.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS427.html","text":"Forbids to have unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we cannot cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your code base at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have. Or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS428.html","text":"Forbids to have statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error. Or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS429.html","text":"Forbids to have multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grown pretty long. And you will not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS430.html","text":"Forbids to have nested functions. Reasoning Nesting functions is a bad practice. It is hard to test them, it is hard then to separate them. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures. Until you need them for decorators or factories. We also disallow to nest lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS431.html","text":"Forbids to use nested classes. Reasoning Nested classes are really hard to manage. You cannot even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use different design (or metaclasses). Configuration This rule is configurable with --nested-classes-whitelist . Default: NESTED_CLASSES_WHITELIST Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0 0.13.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS432.html","text":"Forbids to use magic numbers in your code. What we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers actually mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS433.html","text":"Forbids to have nested imports in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look like. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS434.html","text":"Forbids to assign variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS435.html","text":"Forbids to multiply lists. Reasoning When you multiply lists - it does not create new values, it creates references to the existing value. It is not what people mean in 99.9% of cases. Solution Use list comprehension or loop instead. Example # Wrong: my_list = [1, 2, 3] * 3 See also https://github.com/satwikkansal/wtfPython#-explanation-8 0.12.0","title":"Found list multiply"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS436.html","text":"Forbids to import protected modules. Related to WPS450 Found protected object import: _ . Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import protected modules. Respect the encapsulation. Example # Correct: import public_module from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass 0.3.0 0.11.0 0.14.0","title":"Found protected module import: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS437.html","text":"Forbids to use protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS438.html","text":"Forbids to raise StopIteration inside generators. Reasoning StopIteration should not be raised explicitly in generators. Solution Use return statement to get out of a generator. Example # Correct : def some_generator () : if some_value : return yield 1 # Wrong : def some_generator () : if some_value : raise StopIteration yield 1 See also https://docs.python.org/3/library/exceptions.html#StopIteration 0.12.0","title":"Found StopIteration raising inside generator"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS439.html","text":"Forbids to use unicode escape sequences in binary strings. Reasoning Binary strings do not work with unicode. Having unicode escape characters in there means that you have an error in your code. Solution Use regular strings when escaping unicode strings. Example # Correct: escaped = '\\u0041' # equals to 'A' # Wrong: escaped = b'\\u0040' # equals to b'\\\\u0040' 0.12.0","title":"Found unicode escape in a binary string: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS440.html","text":"Forbids to local and block variables to overlap. What we call local variables: Assigns and annotations Function arguments (they are local to the function body) What we call block variables: Imports Functions and async functions definitions Classes, methods, and async methods definitions For and async for loops variables Except block exception aliases We allow local variables to overlap theirselfs, we forbid block varibals to overlap theirselfs. Reasoning A lot of complex errors might happen when you shadow local varibales with block variables or when you shadow block variables with local variables. Solution Use names that do not overlap. Example # Correct: my_value = 1 my_value = my_value + 1 # Wrong: import my_value my_value = 1 # overlaps with import See also https://github.com/satwikkansal/wtfPython#-explanation-20 0.12.0","title":"Found block variables overlap: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS441.html","text":"Forbids to use control variables after the block body. What we call block control variables: for loop unpacked variables with context variables Reasoning Variables leaking from the blocks can damage your logic. It might not contain what you think they contain. Solution Use names inside the scope they are defined. Create new functions to return values in case you need to use block variables: when searching for a value, etc. Example # Correct : for my_item in collection : print ( my_item ) # Wrong : for my_item in collection : ... print ( my_item ) See also https://github.com/satwikkansal/wtfPython#-explanation-32 0.12.0 0.14.0","title":"Found control variable used after block: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS442.html","text":"Forbids to shadow variables from outer scopes. We check function, method, and module scopes. While we do not check class scope. Because class level constants are not available via regular name, and they are scope to ClassName.var_name . Reasoning Shadowing can lead you to a big pile of strage and unexpected bugs. Solution Use different names and do not allow scoping. Example # Correct: def test(): ... def other(): test1 = 1 # Wrong: def test(): ... def other(): test = 1 # shadows ``test()` function 0.12.0","title":"Found outer scope names shadowing: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS443.html","text":"Forbids to use exlicit unhashable types as set items and dict keys. Reasoning This will resolve in TypeError in runtime. Solution Use hashable types to define set items and dict keys. Example # Correct: my_dict = {1: {}, (1, 2): [], (2, 3): {1, 2}} # Wrong: my_dict = {[1, 2]: [], {2, 3}: {1, 2}} 0.12.0","title":"Found unhashable item"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS444.html","text":"Forbids to use exlicit falsly-evaluated conditions with several keywords. We check: ast.While ast.Assert We do not check variables, attributes, calls, bool and bin operators, etc. We disallow constants and some expressions. Reasoning Some conditions clearly tell us that this node won't work correctly. So, we need to check that we can fix that. Solution Remove the unreachable node, or change the condition item. Example # Correct: assert some_variable while True : ... # Wrong: assert [] while False : ... 0.12.0 0.13.0","title":"Found wrong keyword condition"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS445.html","text":"Forbids to have wrong named keywords in starred dicts. Reasoning Using wrong keywords in starred dict. Eg.: print(**{'@': 1}) . Solution Don't use incorrect identifiers for keywords. Example # Correct : print ( ** { ' end ' : ' | ' } ) # Wrong : print ( ** { ' 3end ' : ' | ' } ) 0.13.0","title":"Found wrong named keyword in starred dict"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS446.html","text":"Forbids to use approximate constants. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare numbers as strings and raise this violation when they start with the same chars. Solution Use pre-defined constants. Example # Correct: from math import pi random_number = 3.15 too_short = 3.1 # Wrong: pi = 3.14 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. See also https://docs.python.org/3/library/math.html#constants 0.13.0","title":"Found approximate constant: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS447.html","text":"Forbid to use alphabet as a string. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare strings and raise this violation when they have exactly the same chars. Solution Use pre-defined constants. Example # Correct: import string UPPERCASE_ALPH = string . ascii_uppercase LOWERCASE_ALPH = string . ascii_lowercase # Wrong: GUESS_MY_NAME = \"abcde...WXYZ\" UPPERCASE_ALPH = \"ABCD...WXYZ\" LOWERCASE_ALPH = \"abcd...wxyz\" 0.13.0","title":"Found alphabet as strings: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS448.html","text":"Forbids the use of incorrect order of except . Note, we only check for built-in exceptions. Because we cannot statically identify the inheritance order of custom ones. Reasoning Using incorrect order of exceptions is error-prone, since you end up with some unreachable exception clauses. Solution Use correct order of exceptions. Example # Correct: try: ... except ValueError: ... except Exception: ... # Wrong: try: ... except Exception: ... except ValueError: ... See also https://bit.ly/36MHlzw 0.13.0","title":"Found incorrect exception order"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS449.html","text":"Forbids to define and use float keys. Reasoning float is a very ugly data type. It has a lot of \"precision\" errors. When we use float as keys we can hit this wall. We also cannot use float keys with lists by design. Solution Use other data types: integers, decimals, or use fuzzy logic. Example # Correct: some = {1: 'a'} some[1] # Wrong: some = {1.0: 'a'} some[1.0] 0.13.0","title":"Found float used as a key"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS450.html","text":"Forbids to import protected objects from modules. Related to WPS436 Found protected module import: _ . Reasoning When importing protected modules' members we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import protected objects from modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: from some.module import _protected from some.module import _protected as not_protected 0.14.0","title":"Found protected object import: _"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS451.html","text":"Forbids to use positional only or / arguments. This violation is only raised for python3.8+ , earlier versions do not have this concept. Reasoning This is a very rare case. Almost exclusively used by C code and stdlib. There's no point in declaring your own parameters as positional only. It will break your code! Solution Use regular arguments. In case you are working with C, then this violation can be ignored. Example # Correct: def my_function(first, second): ... # Wrong: def my_function(first, /, second): ... See also https://www.python.org/dev/peps/pep-0570/ 0.14.0","title":"Found positional-only argument"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS452.html","text":"Forbids to use break and continue in finally case. Related to WPS419 Found try/else/finally with multiple return paths . Reasoning Putting any control statements in finally` is a terrible practice, because finally` is implicitly called and can cause damage to your logic with its implicitness. We should not allow it. Solution Remove break and continue from finally blocks. Example # Correct : try : ... finally : ... # Wrong : try : ... finally : break try : ... finally : continue 0.14.0","title":"Found break or continue in finally block"},{"location":"wemake-python-styleguide/0.14.0/violations/best_practices/WPS453.html","text":"Forbids to execute the file with shebang incorrectly set. A violation is raised in these cases : Shebang is present but the file is not executable. The file is executable but no shebang is present. Shebang is present but does not contain \"python\". There is whitespace before shebang. There are blank or comment lines before shebang. Reasoning Setting the shebang incorrectly causes executable mismatch. Solution Ensure the shebang is present on the first line, contains \"python\", and there is no whitespace before. Example # Correct: #!/usr/bin/env python # Wrong: #!/usr/bin/env #!/usr/bin/env python 0.14.0","title":"Found executable mismatch: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated. See also: https://sobolevn.me/2019/10/complexity-waterfall","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS200.html","text":"Forbids to have modules with complex lines. We are using Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measuring the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS201.html","text":"Forbids to have modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS202.html","text":"Forbids to have many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any differences between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS203.html","text":"Forbids to have modules with too many imported names. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imported names without prefixes is quite expensive. You have to memorize all the source locations of the imports. And sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why a single module has so many dependencies? So, it becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several ones. Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imported-names . Default: MAX_IMPORTED_NAMES 0.12.0","title":"Found module with too many imported names: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS204.html","text":"Forbids to have overused expressions in a module, function or method. What do we call an \"overused expression\"? When you use any expression (like user_dict['age'] for example) inside your code, you always have to track that you are not using it \"too much\". Because if that expression is everywhere inside your code, it is a sign of a problem. It means that you are missing an abstraction. We check overused expression on two levels: per each function per all module Related to WPS213 Found too many expressions: _ . Reasoning Overusing expression lead to losing the parts that can and should be refactored into variables, methods, and properties of objects. Solution Refactor expressions to be an attribute, a method, or a new variable. Configuration This rule is configurable with --max-module-expressions . Default: MAX_MODULE_EXPRESSIONS And with --max-function-expressions . Default: MAX_FUNCTION_EXPRESSIONS 0.12.0 0.14.0","title":"Found overused expression: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS210.html","text":"Forbids to have too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will find troubles to understand what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS211.html","text":"Forbids to have too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it shows that it is required to refactor this piece of code. It also indicates that function does too many things at once. Solution Split function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS212.html","text":"Forbids placing too many return statements into the function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS213.html","text":"Forbids putting too many expressions in a single function. This rule is quite similar to \"max lines\" in a function, but is much nicer. Because we don't count lines, we count real code entities. This way adding just several extra empty lines for readability will never trigger this violation. Related to WPS204 Found overused expression: _ . Reasoning When there are too many expressions it means that this specific function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0 See also https://en.wikipedia.org/wiki/Expression_(computer_science)","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS214.html","text":"Forbids to have many methods in a single class. Reasoning Having too many methods might lead to the \"God object\". This kind of objects can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes. Then use composition or inheritance to refactor your code. This will protect you from \"God object\" anti-pattern. We do not make any difference between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you try to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you try to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into multiple ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS217.html","text":"Forbids placing too many await expressions into a function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where are we and what is going on. Solution Change your design. Split functions into multiple ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS218.html","text":"Forbids placing too many asseert statements into a function. Reasoning When there are too many assert keywords, functions are starting to get really complex. It might indicate that your tests or contracts are too big. Solution Create rich assert statements, use higher-level contracts, or create special guard functions. Configuration This rule is configurable with --max-asserts . Default: MAX_ASSERTS 0.12.0","title":"Found too many assert statements: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS219.html","text":"Forbids to have consecutive expressions with too deep access level. We consider only these expressions as accesses: ast.Subscript ast.Attribute We do not treat ast.Call as an access, since there are a lot of call-based APIs like Django ORM, builder patterns, etc. Reasoning Having too deep access level indicates a bad design and overcomplicated data without proper API. Solution Split the expression into variables, functions or classes. Refactor the API for your data layout. Example # Correct: access level = 4 self . attr . inner . wrapper [ 1 ] # Correct: access level = 1 manager . filter (). exclude (). annotate (). values (). first () # Wrong: access level = 5 self . attr . inner . wrapper . method . call () # Wrong: access level = 5 # ``obj` has access level of 2: # ``.attr`, ``.call` # ``call()` has access level of 5: # ``.other`, ``[0]`, ``.field`, ``.type`, ``.boom` obj . attr . call (). other [ 0 ] . field . type . boom Configuration This rule is configurable with --max-access-level . Default: MAX_ACCESS_LEVEL 0.12.0","title":"Found too deep access level: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS220.html","text":"Forbids nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS221.html","text":"Forbids to have complex lines. We are using Jones Complexity algorithm to count complexity. What is Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS222.html","text":"Forbids to have conditions with too many logical operators. We use MAX_CONDITIONS as a default value. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS223.html","text":"Forbids to use many elif branches. We use MAX_ELIFS as a default value. Reasoning This rule is specifically important because of many elif branches indicate a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use some interface that just call a specific method without if . Or separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS224.html","text":"Forbids to have too many for statement within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS225.html","text":"Forbids to have too many except cases in a single try clause. We use MAX_EXCEPT_CASES as a default value. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design. Since this way, one controlling structure will become too complex. And you will need to test a lot of paths your application might go. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS226.html","text":"Forbids to over-use string constants. We allow to use strings without any restrictions as annotations for variables, arguments, return values, and class attributes. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant. And should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS227.html","text":"Forbids to yield too long tuples. Reasoning Long yield tuples complicate generator using. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS228.html","text":"Forbids to have too long compare expressions. Reasoning To long compare expressions indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, seprate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS229.html","text":"Forbids to have try blocks with too long bodies. Reasoning Having too many statements inside your try block can lead to situations when some different statement raises an exception and you are not aware of it since it is not expected. Solution Move things out of the try block or create new functions. The less lines you have in your try block - the safer you are from accidental errors. Configuration This rule is configurable with --max-try-body-length . Default: MAX_TRY_BODY_LENGTH See also https://adamj.eu/tech/2019/10/02/limit-your-try-clauses-in-python/ 0.12.0","title":"Found too long try body length: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS230.html","text":"Forbids to have try blocks with too long bodies. We only check static definitions in a form of self.public = ... . We do not count parent attributes. We do not count properties. We do not count annotations. We do not count class attributes. We do not count duplicates. Reasoning Having too many public instance attributes means that your class is too complex in terms of coupling. Other classes and functions will rely on these concrete fields instead of better abstraction layers. Solution Make some attributes protected. Split this class into several ones. If class is a Data Transfer Object, then use @dataclass decorator. Configuration This rule is configurable with --max-attributes . Default: MAX_ATTRIBUTES See also https://en.wikipedia.org/wiki/Coupling_(computer_programming) 0.12.0","title":"Found too many public instance attributes: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS231.html","text":"Forbids to have functions with too high cognitive complexity. Reasoning People are not great at reading and iterpretating code in their heads. That's why code with a lot of nested loops, conditions, exceptions handlers, and context managers is hard to read and understand. Solution Rewrite your code to be simplier. Use flat structures and conditions, remove nested loops. Configuration This rule is configurable with --max-cognitive-score . Default: MAX_COGNITIVE_SCORE See also https://en.wikipedia.org/wiki/Cognitive_complexity https://pypi.org/project/cognitive-complexity/ https://github.com/Melevir/flake8-cognitive-complexity 0.13.0","title":"Found too high function cognitive complexity: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS232.html","text":"Forbids to have modules with too high average cognitive complexity. Reasoning Modules with lots of functions might hide cognitive complexity inside many small and relatevely simple functions. Solution Rewrite your code to be simplier. Or use several modules. Configuration This rule is configurable with --max-cognitive-average . Default: MAX_COGNITIVE_AVERAGE See also https://en.wikipedia.org/wiki/Cognitive_complexity 0.13.0","title":"Found too high module cognitive complexity: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS233.html","text":"Forbids too long call chains. Reasoning Too long call chains are overcomplicated and indicators of bad API design. Solution Split the expression into variables, functions or classes. Refactor the API to allow higher-level access to functions. Configuration This rule is configurable with --max-call-level . Default: MAX_CALL_LEVEL 0.13.0","title":"Found too lang call chain length: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS234.html","text":"Forbids too complex annotations. Annotation complexity is maximum annotation nesting level. ## Example List[int] has complexity of 2 and Tuple[List[Optional[str]], int] has complexity of 4. Reasoning Too complex annotations make your types unreadable. And make developers afraid of types. Solution Create type aliases. And use them a lot! Configuration This rule is configurable with --max-annotation-complexity . Default: MAX_ANN_COMPLEXITY See also https://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases https://github.com/best-doctor/flake8-annotations-complexity 0.14.0","title":"Found too complex annotation: _"},{"location":"wemake-python-styleguide/0.14.0/violations/complexity/WPS235.html","text":"Forbids from ... import ... with too many imported names. Reasoning Importing too many names from one import is easy way to cause violation WPS203 - too many imported names. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names Configuration This rule is configurable with --max-import-from-members . Default: MAX_IMPORT_FROM_MEMBERS 0.14.0","title":"Found too many imported names from a module: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/index.html","text":"These checks limit the Python's inconsistency. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to bare with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right. And we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective. But, we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS300.html","text":"Forbids to have imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS301.html","text":"Forbids to use imports like import os.path . Reasoning There too many different ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS302.html","text":"Forbids to use u string prefix. Reasoning We do not need this prefix since python2 . But, it is still possible to find it inside the codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS303.html","text":"Forbids to use underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS304.html","text":"Forbids to use partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and starting zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS305.html","text":"Forbids to use f strings. Reasoning f strings loses context too often and they are hard to lint. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS306.html","text":"Forbids to write classes without base classes. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... See also https://google.github.io/styleguide/pyguide.html#39-classes 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS307.html","text":"Forbids to have multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS308.html","text":"Forbids to have compares between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the compare, will always be the same. Solution Remove the constant compare and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant compare"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS309.html","text":"Forbids comparison where argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle ordering of the arguments all the time. Bring consistency to the compare! Solution Refactor your compare expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS310.html","text":"Forbids to use capital X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase. Which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written in lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS311.html","text":"Forbids comparison where multiple in checks. Reasoning Using multiple in is unreadable. Solution Refactor your compare expression to use several and conditions or separate if statements in case it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS312.html","text":"Forbids to have compares between the same variable. Reasoning When the same variables are compared it is typically an indication of a mistake, since the Boolean value of the compare will always be the same. Solution Remove the same variable compare and any associated dead code. Example # Correct : do_something () # Wrong : if a < a : do_something () else : do_something_else () 0.3.0","title":"Found compare between same variable"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS313.html","text":"Enforces to separate parenthesis from the keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between keyword and open paren. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parens right after a keyword"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS314.html","text":"Forbids using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Found conditional that always evaluates to same result"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS315.html","text":"Forbids extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Found extra object in parent classes list"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS316.html","text":"Forbids multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into tuple or we are just using two context managers. Solution Use several context managers. Or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS317.html","text":"Forbids to use incorrect parameters indentation. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) # Correct complex case: @ pytest . mark . parametrize (( 'boolean_arg' , 'string_arg' ), [ ( True , \"string\" ), ( False , \"another string\" ), ]) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS318.html","text":"Forbids to use extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you will keep the indentation level equal for this specific node. But, that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') This rule is consistent with the \"Vertical Hanging Indent\" option for multi_line_output setting of isort . To avoid conflicting rules, you should set multi_line_output = 3 in the isort settings. See also https://github.com/timothycrosley/isort#multi-line-output-modes https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/isort.toml 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS319.html","text":"Forbids to have brackets in the wrong position. Reasoning You can do bizzare things with bracket positioning in python. We require all brackets to be consistent. Solution Place bracket on the same line, in case of a single line expression. Or place the bracket on a new line in case of a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS320.html","text":"Forbids to use multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS321.html","text":"Forbids to use uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase modifiers. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS322.html","text":"Forbids to use triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS323.html","text":"Forbids to use % formatting on strings. We check for string formatting. We try not to issue false positives. It is better for us to ignore a real (but hard to detect) case, then marking a valid one as incorrect. Internally we check for this pattern in string definitions: %[ (name) ] [ flags ] [ width ] [ .precision ] [ {h | l} ] type This is a C format specification. Related to WPS305 Found f string and solves the same problem. Reasoning You must use a single formatting method across your project. Solution We enforce to use string .format() method for this task. Example # Correct: 'some string', 'your name: {0}', 'data: {data}' # Wrong: 'my name is: %s', 'data: %(data)d' See also https://github.com/gforcada/flake8-pep3101 https://msdn.microsoft.com/en-us/library/56e442dc.aspx https://docs.python.org/3/library/stdtypes.html#old-string-formatting https://pyformat.info/ 0.14.0","title":"Found % string formatting"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS324.html","text":"Enforces to have consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS325.html","text":"Enforces to have consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS326.html","text":"Forbids to use implicit string concatenation. Reasoning This is error-prone, since you can possibly miss a comma in a collection of string and get an implicit concatenation. And because there are different and safe ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS327.html","text":"Forbids to use meaningless continue node in loops. Reasoning Placing this keyword in the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue node from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS328.html","text":"Forbids to use meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by acedent. This might be also an overuse of syntax. Solution Remove node or make sure it makes sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS329.html","text":"Forbids to use meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS330.html","text":"Forbids the use of unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS331.html","text":"Forbids local variable that are only used in return statements. We also allow cases when variable is assigned, then there are some other statements without direct variable access, and the variable is returned. We reserve this use-case to be able to do some extra work before the function returns. We also allow to return partial, sorted, or modified tuple items that are defined just above. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 def other_function () : some_value = 1 do_something ( some_value ) return some_value # Wrong : def some_function () : some_value = 1 return some_value 0.9.0 0.14.0","title":"Found variables that are only used for return: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS332.html","text":"Forbids local variable that are only used in return statements. This violation can only be thrown on python3.8+ . Reasoning Code with := is hardly readable. It has big problems with scoping and reading order. And it can lead to a huge mess inside your code. Python is not expression-based. Solution Don't use fancy stuff, use good old assignments. Example # Correct : some = call () if some : print ( some ) # Wrong : if some : = call () : print ( some ) 0.14.0","title":"Found walrus operator"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS333.html","text":"Forbids to have implicit complex compare expressions. Reasoning Two compares in python that are joined with and operator mean that you indeed have a complex compare with tree operators. Solution Refactor your compare without and but with the third operator. Notice, that you might have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS334.html","text":"Forbids to have reversed order complex compare expressions. Reasoning Compares where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is incosistent. Solution Reverse the order, so the smallest element comes the first and the biggest one comes the last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex compare"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS335.html","text":"Forbids to use wrong for loop iter targets. We forbid to use: Lists and list comprehensions Sets and set comprehensions Dicts and dict comprehensions Generator expressions Empty tuples Reasoning Using lists, dicts, and sets do not make much sense. You can use tuples instead. Using comprehensions implicitly create a two level loops, that are hard to read and deal with. Solution Use tuples to create explicit iterables for for loops. In case you are using a comprehension, create a new variable. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0 0.12.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS336.html","text":"Forbids explicit string concat in favour of .format method. However, we still allow multiline string concat as a way to write long strings that does not fit the 80-chars rule. Reasoning When formating strings one must use .format and not any other formatting methods like % , + , or f . This is done for consistency reasons. Solution Join strings together if you can, or use .format method. Example # Correct: x = 'ab: {0}'.format(some_data) # Wrong: x = 'a' + 'b: ' + some_data 0.12.0","title":"Found explicit string concat"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS337.html","text":"Forbids multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has. And it decreases readability of the code. Solution Divide multiline conditions to some if condition. Or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS338.html","text":"Forbids to have incorrect order of methods inside a class. We follow the same ordering: __new__ __init__ __call__ public and magic methods protected methods private methods (we discourage using them) We follow \"Newspaper order\" where the most important things come first. Reasoning It is hard to read classes where API declarations are bloated with implementation details. We need to see the important stuff first, then we can go deeper in case we are interested. Solution Reorder methods inside your class to match our format. 0.12.0","title":"Found incorrect order of methods in a class"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS339.html","text":"Forbids to use meaningless zeros. We discorauge using meaningless zeros in float, binary, octal, hex, and exponential numbers. Reasoning There are \\~infinite ways to write these numbers by adding meaningless leading zeros to the number itself. 0b1 is the same as 0b01 and 0b001 . How a language can be called consistent if you can write numbers in an infinite ways? It hurts readability and understanding of your code. Solution Remove meaningless leading zeros. Example # Correct: numbers = [1.5, 0b1, 0o2, 0x5, 10e10] # Wrong: numbers = [1.50, 0b00000001, 0o0002, 0x05, 10e010] 0.12.0","title":"Found number with meaningless zeros: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS340.html","text":"Forbids to extra + signs in the exponent. Reasoning Positive exponent is positive by default, there's no need to write an extra + sign. We enforce consistency with this rule. Solution Remove meaningless + sign from the exponent. Example # Correct: number = 1e1 + 1e-1 # Wrong: number = 1e+1 0.12.0","title":"Found exponent number with positive exponent: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS341.html","text":"Forbids to use letters as hex numbers. Reasoning One can write 0xA and 0xa which is inconsistent. This rule enforces upper-case letters in hex numbers. Solution Use uppercase letters in hex numbers. Example # Correct: number = 0xABCDEF # Wrong: number = 0xabcdef 0.12.0","title":"Found wrong hex number case: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS342.html","text":"Forbids to use \\\\ escape sequences inside regular strings. Reasoning It is hard to read escape sequencse inside regular strings, because they use \\\\ double backslash for a single character escape. Solution Use raw strings r'' to rewrite the escape sequence with a \\ single backslash. Example # Correct: escaped = [r'\\n', '\\n'] # Wrong: escaped = '\\\\n' 0.12.0","title":"Found implicit raw string: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS343.html","text":"Forbids to use uppercase complex number suffix. Reasoning Numbers should be consistent. Solution Use lowercase suffix for imaginary part. Example # Correct: complex_number = 1j # Wrong: complex_number = 1J 0.12.0","title":"Found wrong complex number suffix: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS344.html","text":"Forbids to explicitly divide by zero. Reasoning This will just throw ZeroDivisionError in case that's what you need: just throw it. No need to use undefined meth behaviours. Or it might be just a typo / mistake, then fix it. Solution Use ZeroDivisionError or fix your number not to be 0 . Example # Correct: raise ZeroDivisionError() # Wrong: 1 / 0 0.12.0","title":"Found explicit zero division"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS345.html","text":"Forbids to use meaningless math operations with 0 and 1 . Reasoning Adding and substracting zero does not change the value. There's no need to do that. Multipling by zero is also redundant: it can be replaced with explicit 0 assign. Multiplying and dividing by 1 is also meaningless. Solution Remove useless zero operations. Example # Correct: number = 1 zero = 0 one = 1 # Wrong: number = 1 + 0 * 1 zero = some * 0 / 1 one = some ** 0 ** 1 0.12.0","title":"Found meaningless number operation"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS346.html","text":"Forbids to have double minus operations. Reasoning Having two operations is harder than having just one. Two negations are harder than one positive expression. Two negations equal to one positive expression. Positive and negative equal to one negative. Solution Replace double minus operation to a single one with plus. Replace 'plus-minus' operation to a single one with minus. Example # Correct: number = 3 + 1 number += 6 number -= 2 # Wrong: number = 3 - -1 number -= -6 number += -2 0.12.0","title":"Found wrong operation sign"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS347.html","text":"Forbids imports that may cause confusion outside of the module. Names that we forbid to import: Common names like dumps and loads Names starting with to_ and from_ Too short names like Q or F , but we are fine with _ Reasoning See datetime.* in code? You know that it's from datetime. See BaseView in a Django project? You know where it is from. See loads ? It can be anything: yaml , toml , json , etc. We are also enforcing consitency with our naming too-short rules here. Solution Use package level imports or import aliases. See VAGUE_IMPORTS_BLACKLIST for the full list of bad import names. Example # Correct: import json import dumps # package names are not checked from json import loads as json_loads # Wrong: from json import loads 0.13.0 0.14.0","title":"Found vague import that may cause confusion: _"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS348.html","text":"Forbids to start lines with a dot. Reasoning We enforce strict consitency rules about how to break lines. We also enforce strict rules about multi-line parameters. Starting new lines with the dot means that this rule is broken. Solution Use () to break lines in a complex expression. Example # Correct: some = MyModel.objects.filter( ..., ).exclude( ..., ).annotate( ..., ) # Wrong some = ( MyModel.objects.filter(...) .exclude(...) .annotate(...) ) 0.13.0","title":"Found a line that starts with a dot"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS349.html","text":"Forbids the use of redundant components in a subscript's slice. Reasoning We do it for consistency reasons. Example # Correct: array[:7] array[3:] # Wrong: x[0:7] x[3:None] 0.13.0","title":"Found redundant subscript slice"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS350.html","text":"Enforce using augmented assign pattern. Reasoning a += b is short and correct version of a = a + b . Why not using the short version? Example # Correct: a += b # Wrong: a = a + b 0.13.0","title":"Found usable augmented assign pattern"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS351.html","text":"Forbids the use of unnecessary literals in your code. Reasoning We discourage using primitive calls to get default type values. There are better ways to get these values. Solution Use direct default values of the given type Example # Correct: default = 0 # Wrong: default = int() 0.13.0","title":"Found unnecessary literals"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS352.html","text":"Forbids multiline loops. Reasoning It decreased the readability of the code. Solution Use single line loops and create new variables in case you need to fit too many logic inside the loop definition. Example # Correct : for num in some_function ( arg1 , arg2 ) : ... # Wrong : for num in range ( arg1 , arg2 , ) : ... 0.13.0","title":"Found multiline loop"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS353.html","text":"Forbids to use yield from with several nodes. We allow to yield from tuples, names, attributes, calls, and subscripts. Reasoning We enforce consitency when yielding values from tuple instead of any other types. It also might be an error when you try to yield from something that is not iterable. Solution Use allowed node types with yield from . Example # Correct: yield from (1, 2, 3) yield from some # Wrong: yield from [1, 2, 3] 0.13.0","title":"Found incorrect yield from target"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS354.html","text":"Forbids to have consecutive yield expressions. We raise this violation when we find at least two consecutive yield expressions. Reasoning One can write multiple yield nodes in a row. That's incosistent. Because we have yield from form. Solution It can be easily changed to yield from (...) format. 0.13.0","title":"Found consecutive yield expressions"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS355.html","text":"Forbids useless blank lines before and after brackets. Reasoning We do this for consistency. Solution Remove blank lines from the start and from the end of a collection. Example # Correct: arr = [ 1, 2, ] # Wrong: arr = [ 1, 2, ] 0.13.0","title":"Found an unnecessary blank line before a bracket"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS356.html","text":"Forbids unnecessary iterable unpacking. Reasoning We do this for consistency. Solution Do not use iterables unpacking, when it's not necessary. Example # Correct: [1, *numbers, 99] {*iterable, *other_iterable} list(iterable) first, *iterable = other_iterable # Wrong: [*iterable] *iterable, = other_iterable 0.13.0","title":"Found an unnecessary iterable unpacking"},{"location":"wemake-python-styleguide/0.14.0/violations/consistency/WPS357.html","text":"Forbids to use \\r (carriage return) in line breaks. Reasoning We enforce Unix-style newlines. We only use newlines ( \\n ), not carriage returns. So \\r line breaks not allowed in code. Solution Use only \\n (not \\r\\n or \\r ) to break lines. 0.14.0","title":"Found a \\r (carriage return) line break"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII characters for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Do not mask builtins Do not use unreadable charachter sequences like O0 and Il Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Do not define unused variables unless you are unpacking other values as well Do not use multiple underscores ( __ ) to create unused variables Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Enum fields also must use snake_case Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called clearly and properly, not just TT or KT or VT","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS100.html","text":"Forbids to use blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py See also https://tonsky.me/blog/utils/ 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS101.html","text":"Forbids to use any magic names except whitelisted ones. Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS102.html","text":"Forbids to use module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS110.html","text":"Forbids to have blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the base list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None Configuration This rule is configurable with --allowed-domain-names . Default: ALLOWED_DOMAIN_NAMES And with --forbidden-domain-names . Default: FORBIDDEN_DOMAIN_NAMES The options listed above are used to create new variable names' blacklist starting from VARIABLE_NAMES_BLACKLIST . 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS111.html","text":"Forbids to have too short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. We do not count trailing and leading underscores when calculating length. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0 0.12.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS112.html","text":"Forbids to have private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0 0.14.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS113.html","text":"Forbids to use the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path When --i-control-code` is set to False you can reexport things with as , because mypy might require it with implicit_reexport = False setting turned on. Configuration: This rule is configurable with --i-control-code and --i-dont-control-code` . Default: :str:`wemake_python_styleguide.options.defaults.I_CONTROL_CODE 0.1.0 0.13.0 0.14.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS114.html","text":"Forbids to have names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored name pattern: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS115.html","text":"Forbids to use anything but snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS116.html","text":"Forbids to use more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS117.html","text":"Forbids to name your variables as self , cls , and mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS118.html","text":"Forbids to have long short variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS119.html","text":"Forbids to use unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS120.html","text":"Forbids to use trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS121.html","text":"Forbids to have use variables that are marked as unused. We discourage using variables that start with _ only inside functions and methods as local variables. However, we allow to use _ because tools like ipython , babel , and django enforce it. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. This way it is declared to be used. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0 0.12.0 0.14.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS122.html","text":"Forbids to define explicit unused variables. Reasoning While it is ok to define unused variables when you have to, like when unpacking a tuple, it is totally not ok to define explicit unusued variables in cases like assignment, function return, exception handling, or context managers. Why do you need this explicitly unused variables? Solution Remove all unused variables definition. Example # Correct: my_function() first, _second = some_tuple() print(first) # Wrong: _ = my_function() _first, _second = some_tuple() This rule checks: assigns, context managers, except clauses. 0.12.0","title":"Found all unused variables definition: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS123.html","text":"Forbids to define unused variables with multiple underscores. Reasoning We only use _ as a special definition for an unused variable. Other variables are hard to read. It is unclear why would one use it. Solution Rename unused variables to _ or give it some more context with an explicit name: _context . Example # Correct: some_element, _next_element, _ = some_tuple() some_element, _, _ = some_tuple() some_element, _ = some_tuple() # Wrong: some_element, _, __ = some_tuple() 0.12.0","title":"Found wrong unused variable name: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS124.html","text":"Forbids to have variable or module names which could be difficult to read. Reasoning Currently one can name your classes like so: ZerO0 Inside it is just O and 0 , but we cannot tell it from the word. There are a lot other combinations which are unreadable. Solution Rename your entity not to contain unreadable sequences. This rule checks: modules, variables, attributes, functions, methods, and classes. See UNREADABLE_CHARACTER_COMBINATIONS for full list of unreadable combinations. Example # Correct: ControlStatement AveragePrice # Wrong: Memo0Output 0.14","title":"Found unreadable characters combination: _"},{"location":"wemake-python-styleguide/0.14.0/violations/naming/WPS125.html","text":"Forbids to have variable or module names which shadows builtin names. Reasoning Your code simply breaks Python. After you create list = 1 , you cannot not call builtin function list and what can be worth than that? Solution Rename your entity not to shadow Python builtins. Example # Correct: my_list = list(some_other) # Wrong: str = '' list = [1, 2, 3] 0.14","title":"Found builtin shadowing: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beatiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS600.html","text":"Forbids to subclass lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS601.html","text":"Forbids to shadow class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0 0.14.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS602.html","text":"Forbids to use @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS603.html","text":"Forbids to use some magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS604.html","text":"Forbids to use incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS605.html","text":"Forbids to have methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so cannot access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS606.html","text":"Forbids to have anything else than a class as a base class. We only check base classes and not keywords. They can be anything you need. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Use annotation future import in case you use strings in base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0 0.12.0","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS607.html","text":"Forbids to have incorrect __slots__ definition. Things that this rule checks: That __slots__ is a tuple, name, attribute, star, or call That __slots__ do not have duplicates That __slots__ do not have empty strings or invalid python names Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Use snake_case to define attributes in __slots__ . Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = (* Test . __slots__ , 'child' ) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0 0.12.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS608.html","text":"Forbids to use super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS609.html","text":"Forbids to use direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS610.html","text":"Forbids to make some magic methods async. We allow to make __anext__ , __aenter__ , __aexit__ async. We also allow custom magic methods to be async. See ASYNC_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted async magic methods. Reasoning Defining the magic methods as async which are not supposed to be async would not work as expected. Solution Do not make this magic method async. Example # Correct: class Test ( object ): def __lt__ ( self , other ): ... # Wrong: class Test ( object ): async def __lt__ ( self , other ): ... See also https://docs.python.org/3/reference/datamodel.html 0.12.0","title":"Found forbidden async magic method usage: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS611.html","text":"Forbids to use yield inside of several magic methods. We allow to make __iter__ a generator. See YIELD_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted generator magic methods. Reasoning Python's datamodel is strict. You cannot make generators from random magic methods. This rule enforces it. Solution Remove yield from a magic method or rename it to be a custom method. Example # Correct: class Example(object): def __init__(self): ... # Wrong: class Example(object): def __init__(self): yield 10 See also https://docs.python.org/3/reference/datamodel.html 0.3.0 0.11.0 0.12.0","title":"Found forbidden yield magic method usage"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS612.html","text":"Forbids to have useless overwritten methods. Reasoning Overwriting method without any changes does not have any positive impact. Solution Do not overwrite method in case you do not want to do any changes inside it. Example # Correct: class Test ( Base ): def method ( self , argument ): super (). method ( argument ) return argument # or None, or anything! # Wrong: class Test ( object ): def method ( self , argument ): return super (). method ( argument ) 0.12.0","title":"Found useless overwritten method: _"},{"location":"wemake-python-styleguide/0.14.0/violations/oop/WPS613.html","text":"Forbids to use super() with incorrect methods or properties access. Reasoning Can only use super() method that matches the following context. super().some() and super().some in Child.some() , and super().prop and super().prop() in Child.prop Solution Use super() methods and properties with the correct context. Example # Correct: class Child ( Parent ): def some_method ( self ): original = super (). some_method () # Wrong: class Child ( Parent ): def some_method ( self ): other = super (). other_method () 0.13.0","title":"Found incorrect super() call context: incorrect name access"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS500.html","text":"Forbids to use else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS501.html","text":"Forbids to use finally in try block without except block. However, we allow to use try with just finally block when function or method is decorated. Because we cannot control what is going on in this decorator. It might be @contextmanager or similar thing that requires this API. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0 0.14.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS502.html","text":"Forbids to have simplifiable if conditions. Reasoning This complex construction can cause frustration among other developers. It is longer, more verbose, and more complex. Solution Use bool() to convert test values to boolean values. Or just leave it as it is in case when your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS503.html","text":"Forbids to use useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS504.html","text":"Forbids to use negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... if not some : ... elif other : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS505.html","text":"Forbids to use nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS506.html","text":"Forbids to define useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS507.html","text":"Forbids to have unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS508.html","text":"Forbids to use not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS509.html","text":"Forbids to nest ternary expressions in some places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS510.html","text":"Forbids to use in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0 0.14.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS511.html","text":"Forbids to multiple isinstance calls with the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS512.html","text":"Forbids to multiple isinstance calls with tuples of a single item. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single varaible. Example # Correct: isinstance(some, (int, float)) isinstance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS513.html","text":"Forbids to have implicit elif conditions. Reasoning Nested if in else cases are bad for readability because of the nesting level. Solution Use elif on the same level. Example # Correct : if some : ... elif other : ... # Wrong : if some : ... else : if other : ... 0.12.0","title":"Found implicit elif condition"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS514.html","text":"Forbids to use multiple equality compare with the same variable name. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0 0.12.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS515.html","text":"Forbids to use open() with a context manager. Reasoning When you open() something, you need to close it. When using a context manager - it is automatically done for you. When not using it - you might find yourself in a situation when file is not closed and is not accessable anymore. Solution Refactor open() call to use with . Example # Correct: with open(filename) as file_obj: ... # Wrong: file_obj = open(filename) 0.12.0","title":"Found open() used without a context manager"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS516.html","text":"Forbids to compare types with type() function. Reasoning When you compare types with type() function call it means that you break polymorphism and dissallow child classes of a node to work here. That's incorrect. Solution Use isinstance to compare types. Example # Correct : print ( something , type ( something )) # Wrong : if type ( something ) == int : ... 0.12.0","title":"Found type() used to compare types"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS517.html","text":"Forbids to have useless starred expressions. Reasoning Using starred expression with constants is useless. This piece of code can be rewritten to be flat. Eg.: print(*[1, 2, 3]) is print(1, 2, 3) . Solution Refactor your code not to use starred expressions with list , dict , tuple , and set constants. Use regular argument passing instead. Example # Correct: my_list = [1, 2, 3, *other_iterable] # Wrong: print(*[1, 2, 3], ** {{}} ) 0.12.0","title":"Found pointless starred expression"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS518.html","text":"Forbids to have implicit enumerate() calls. Reasoning Using range(len(...)) is not pythonic. Python uses collection iterators, not index-based loops. Solution Use enumerate(...) instead of range(len(...)) . Example # Correct: for index , person in enumerate ( people ): ... # Wrong: for index in range ( len ( people )): ... See also https://docs.python.org/3/library/functions.html#enumerate 0.12.0","title":"Found implicit enumerate() call"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS519.html","text":"Forbids to have implicit sum() calls. When summing types different from numbers, you might need to provide the second argument to the sum function: sum([[1], [2], [3]], []) You might also use str.join to join iterable of strings. Reasoning Using for loops with += assign inside indicates that you iteratively sum things inside your collection. That's what sum() builtin function does. Solution Use sum(...) instead of a loop with += operation. Example # Correct : sum_result = sum ( get_elements ()) # Wrong : sum_result = 0 for to_sum in get_elements () : sum_result += to_sum See also https://docs.python.org/3/library/functions.html#sum https://docs.python.org/3/library/stdtypes.html#str.join 0.12.0","title":"Found implicit sum() call"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS520.html","text":"Forbids to compare with explicit falsy constants. We allow to compare with falsy numbers, strings, booleans, None . We disallow complex constants like tuple, dicts, and lists. Reasoning When comparing something with explicit falsy constants what we really mean is not something . Solution Use not with your variable. Fix your data types. Example # Correct : if not my_check : ... if some_other is None : ... if some_num == 0 : ... # Wrong : if my_check == []: ... 0.12.0","title":"Found compare with falsy constant"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS521.html","text":"Forbids to compare values with constants using is or is not . However, we allow to compare with None and booleans. Reasoning is compares might not do what you want them to do. Firstly, they check for the same object, not equality. Secondly, they behave unexpectedly even with the simple values like 257 . Solution Use == to compare with constants. Example # Correct : if my_check == [ 1 , 2 , 3 ]: ... # Wrong : if my_check is [ 1 , 2 , 3 ]: ... See also https://stackoverflow.com/a/33130014/4842742 0.12.0","title":"Found wrong is compare"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS522.html","text":"Forbids to use implicit primitives in a form of lambda functions. Reasoning When you use lambda that returns a primitive value and takes no arguments, it means that you should use a primitive type instead. Solution Replace lambda with int , float , list , or any other primitive. Example # Correct: defaultdict(int) # Wrong: defaultdict(lambda: 0) 0.13.0","title":"Found implicit primitive in a form of lambda"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS523.html","text":"Forbids unpythonic swap variables. We check for a = b; b = a sequences. Reasoning This looks like a failed attempt to swap. Solution Use standard way to swap two variables. Example # Correct: a, b = b, a # Wrong: a = b b = a temp = a a = b b = temp 0.13.0","title":"Found incorrectly swapped variables"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS524.html","text":"Forbids to use misrefactored self assignment. Reasoning Self assignment does not need to have the same operand on the left hand side and on the right hand side. Solution Refactor you code to use multiple self assignments or fix your code. Example # Correct: test += 1 test *= 2 # Wrong: test += test + 1 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. 0.13.0","title":"Found self assignment  with refactored assignment"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS525.html","text":"Forbids comparisons where in is compared with single item container. Reasoning in comparison with a container which contains only one item looks like overhead and unneeded complexity. Solution Refactor your code to use == instead in . Example # Correct: a == 's' # Wrong: a in {'s'} 0.13.0","title":"Found wrong in compare with single item container"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS526.html","text":"Forbids to use yield inside for loop instead of yield from . Reasoning It is known that yield from is a semantically identical to a for loop with a yield inside. But, it is way more readable. Solution Use yield from some iterable directly instead iterating over it inside a loop and yield it one by one. Example # Correct : yield from some () yield from ( value [ index : index + chunk_size ] for index in range ( 0 , len ( value ) , chunk_size ) ) # Wrong : for index in chunk : yield index 0.13.0","title":"Found implicit yield from usage"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS527.html","text":"Forces using tuples as arguments for some functions. Reasoning For some functions, it is better to use tuples instead of another iterable types (list, sets,...) as arguments. Solution Use tuples as arguments. Example # Correct: a = frozenset((2,)) # Wrong: a = frozenset([2]) See TUPLE_ARGUMENTS_METHODS for full list of methods that we check for. 0.13.0","title":"Found not a tuple used as an argument"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS528.html","text":"Forbids to use implicit .items() iterator. Reasoning When iterating over collection it is easy to forget to use .items() when you need to access both keys and values. So, when you access the iterable with the key inside a for loop, that's a sign to refactor your code. Solution Use .items() with direct keys and values when you need them. Example # Correct : for some_key , some_value in collection . items () : print ( some_key , some_value ) # Wrong : for some_key in collection : print ( some_key , collection [ some_key ] ) 0.13.0","title":"Found implicit .items() usage"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS529.html","text":"Forbids to use implicit .get() dict method. Reasoning When using in with a dict key it is hard to keep the code clean. It is more convinient to use .get() and check for None later. Solution Use .get() with the key you need. Check for None in case you need it, or just act with the default value of the same type. Example # Correct : value = collection . get ( key ) if value is not None : print ( value ) # Wrong : if key in collection : print ( collection [ key ] ) 0.13.0","title":"Found implicit .get() dict usage"},{"location":"wemake-python-styleguide/0.14.0/violations/refactoring/WPS530.html","text":"Forbids to use implicit negative indexes. Reasoning There's no need in getting the length of an iterable and then having a negative offset, when you can specify negative indexes in the first place. Solution Use negative indexes. Example # Correct: some_list[-1] # Wrong: some_list[len(some_list) - 1] 0.13.0","title":"Found implicit negative index"},{"location":"wemake-python-styleguide/0.14.0/violations/system/index.html","text":"These checks ensures that our internal checks passes. For example, we can report violations from this group when some exception occur during the linting process or some dependencies are missing.","title":"WPS0xx System"},{"location":"wemake-python-styleguide/0.14.0/violations/system/WPS000.html","text":"Happens when we get unhandled exception during the linting process. All this violations should be reported to the main issue tracker. We ideally should not produce these violations at all. See also https://github.com/wemake-services/wemake-python-styleguide/issues 0.13.0","title":"Internal error happened, see log. Please, take some time to report it"},{"location":"wemake-python-styleguide/0.15.0/index.html","text":"","title":"0.15.0"},{"location":"wemake-python-styleguide/0.15.0/configuration/ALLOWED_DOMAIN_NAMES.html","text":"Domain names that are removed from variable names' blacklist.","title":"ALLOWED_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.15.0/configuration/FORBIDDEN_DOMAIN_NAMES.html","text":"Domain names that extends variable names' blacklist.","title":"FORBIDDEN_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.15.0/configuration/FORBIDDEN_INLINE_IGNORE.html","text":"Violation codes that are forbidden to use.","title":"FORBIDDEN_INLINE_IGNORE"},{"location":"wemake-python-styleguide/0.15.0/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_ACCESS_LEVEL.html","text":"Maximum number of access level in an expression.","title":"MAX_ACCESS_LEVEL"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_ANN_COMPLEXITY.html","text":"Maximum number of nested annotations.","title":"MAX_ANN_COMPLEXITY"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_ASSERTS.html","text":"Maximum number of assert statements in a function.","title":"MAX_ASSERTS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_ATTRIBUTES.html","text":"Maximum number of public attributes in a single class.","title":"MAX_ATTRIBUTES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_AWAITS.html","text":"Maximum number of await expressions for functions or methods.","title":"MAX_AWAITS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_CALL_LEVEL.html","text":"Maximum number of call chains.","title":"MAX_CALL_LEVEL"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_COGNITIVE_AVERAGE.html","text":"Maximum amount of average cognitive complexity per module.","title":"MAX_COGNITIVE_AVERAGE"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_COGNITIVE_SCORE.html","text":"Maximum amount of cognitive complexity per function.","title":"MAX_COGNITIVE_SCORE"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_FUNCTION_EXPRESSIONS.html","text":"Maximum amount of same expressions per function.","title":"MAX_FUNCTION_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_IMPORTED_NAMES.html","text":"Maximum number of imported names in a single module.","title":"MAX_IMPORTED_NAMES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_IMPORT_FROM_MEMBERS.html","text":"Maximum number of names that can be imported from module.","title":"MAX_IMPORT_FROM_MEMBERS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_MODULE_EXPRESSIONS.html","text":"Maximum amount of same expressions per module.","title":"MAX_MODULE_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_RAISES.html","text":"Maximum number of raises in a function.","title":"MAX_RAISES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_TRY_BODY_LENGTH.html","text":"Maximum amount of try node body length.","title":"MAX_TRY_BODY_LENGTH"},{"location":"wemake-python-styleguide/0.15.0/configuration/MAX_TUPLE_UNPACK_LENGTH.html","text":"Maximum number of variables in a tuple unpacking statement.","title":"MAX_TUPLE_UNPACK_LENGTH"},{"location":"wemake-python-styleguide/0.15.0/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.15.0/configuration/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/ALIAS_NAMES_WHITELIST.html","text":"List of commonly used aliases","title":"ALIAS_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.15.0/constants/ALLOWED_NESTED_IMPORTS_CONDITIONS.html","text":"Conditions that can appear in the if statement to allow nested imports.","title":"ALLOWED_NESTED_IMPORTS_CONDITIONS"},{"location":"wemake-python-styleguide/0.15.0/constants/ALL_MAGIC_METHODS.html","text":"List of all magic methods from the python docs.","title":"ALL_MAGIC_METHODS"},{"location":"wemake-python-styleguide/0.15.0/constants/ASYNC_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be async.","title":"ASYNC_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/BUILTINS_WHITELIST.html","text":"List of builtins that we allow to shadow.","title":"BUILTINS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/LITERALS_BLACKLIST.html","text":"List of literals without arguments we forbid to use.","title":"LITERALS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MATH_APPROXIMATE_CONSTANTS.html","text":"Approximate constants which real values should be imported from math module.","title":"MATH_APPROXIMATE_CONSTANTS"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_COMPARES.html","text":"Maximum number of compare nodes in a single expression.","title":"MAX_COMPARES"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_CONDITIONS.html","text":"Maximum number of conditions in a single if or while statement.","title":"MAX_CONDITIONS"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_ELIFS.html","text":"Maximum number of elif blocks in a single if condition:","title":"MAX_ELIFS"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_EXCEPT_CASES.html","text":"Maximum number of except cases in a single try clause.","title":"MAX_EXCEPT_CASES"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.15.0/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.15.0/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.15.0/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.0/constants/TUPLE_ARGUMENTS_METHODS.html","text":"List of functions in which arguments must be tuples.","title":"TUPLE_ARGUMENTS_METHODS"},{"location":"wemake-python-styleguide/0.15.0/constants/UNREADABLE_CHARACTER_COMBINATIONS.html","text":"List of character sequences that are hard to read.","title":"UNREADABLE_CHARACTER_COMBINATIONS"},{"location":"wemake-python-styleguide/0.15.0/constants/VAGUE_IMPORTS_BLACKLIST.html","text":"List of vague method names that may cause confusion if imported as is:","title":"VAGUE_IMPORTS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/constants/YIELD_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be generators.","title":"YIELD_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits, then we forbid the use of code like it forever.","title":"WPS4xx Best Practices"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS400.html","text":"Restrict various control (such as magic) comments. We do not allow: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast This violation is reported at the top of the module, so it cannot be locally ignored. Reasoning We cover several use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow using # type: ignore comment, since sometimes it is required. Example # Correct : type = MyClass . get_type () # noqa : WPS125 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS401.html","text":"Forbid empty doc comments ( #: ). Reasoning Doc comments are used to provide documentation but supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS402.html","text":"Forbid too many # noqa comments. We count them on a per-module basis. Reasoning Having too many # noqa comments makes your code less readable and indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. Configuration This rule is configurable with --max-noqa-comments . Default: MAX_NOQA_COMMENTS 0.7.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS403.html","text":"Forbid too many # pragma: no cover comments. We count them on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments indicates that there's something wrong with the code. Moreover, it makes your tests useless, since they do not cover a big portion of your code. Solution Refactor your code to match the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS404.html","text":"Forbid complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or HTTP requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS405.html","text":"Forbid anything other than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' person ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS406.html","text":"Forbid anything other than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS407.html","text":"Forbid mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS408.html","text":"Forbid using the same logical conditions in one expression. Reasoning Using the same name in a logical condition more than once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicated condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0 0.13.0","title":"Found duplicate logical condition"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS409.html","text":"Forbid heterogeneous operators in one comparison. Note, that we do allow mixing > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogeneous compare"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS410.html","text":"Forbid some module-level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use importlib.metadata (or importlib_metadata on python \\< 3.8) if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS411.html","text":"Forbid empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS412.html","text":"Forbid logic inside __init__ module. Reasoning If you have logic inside the __init__ module It means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic in the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow some contents inside the __init__ module: comments, since they are dropped before AST comes in play docstrings are used sometimes when required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case, this rule can be configured. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE When using --i-dont-control-code it is still recommended to only have imports in your __init__.py . 0.1.0","title":"Found __init__.py module with logic"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS413.html","text":"Forbid __getattr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS414.html","text":"Forbid tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique so do not use it. This includes assigning to attributes, as this results in modifying the instance. Every modification should be explicit on it's own line. Solution Use unpacking only with variables, not any other entities. Example # Correct: reader, writter = call() self.reader = reader self.writer = writer # Wrong: first, some_dict['alias'] = some() self.reader, self.writer = call() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS415.html","text":"Forbid the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Another one will always be ignored. So, that is an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS416.html","text":"Forbid yield keyword inside comprehensions. This is a SyntaxError starting from python3.8 . Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in the foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS417.html","text":"Forbid duplicate items in hashes. Reasoning When you explicitly put duplicate items in set literals or in dict keys it just does not make any sense since hashes cannot contain duplicate items and they will be removed anyway. Solution Remove duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations 0.7.0 0.11.0 0.12.0","title":"Found non-unique item in hash: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS418.html","text":"Forbid exceptions inherited from BaseException . Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS419.html","text":"Forbid multiple returning paths with try / except case. Note, that we check for any return , break , or raise nodes. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Correct : try : return 1 except YourException : ... finally : clear_things_up () # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0 0.12.0","title":"Found try/else/finally with multiple return paths"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS420.html","text":"Forbid some python keywords. Reasoning Using some keywords generally causes more pain than it relieves. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no use-case for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale and leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS421.html","text":"Forbid calling some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid the use of them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS422.html","text":"Forbid __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS423.html","text":"Forbid NotImplemented exception. Reasoning NotImplemented and NotImplementedError look similar but they have different use cases. Use cases of NotImplemented are too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS424.html","text":"Forbid BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS425.html","text":"Forbid booleans as non-keyword parameters. Reasoning Passing booleans as regular positional parameters is very non-descriptive. It is almost impossible to tell what this parameter means and you almost always have to look up the implementation to tell what is going on. The only exception from this rule is passing a boolean as a non-keyword argument when it is the only passed argument. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UserRepository.update(True) UsersRepository.add(user, cache=True) # Wrong: UsersRepository.add(user, True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS426.html","text":"Forbid lambda inside loops. We check while , for , and async for loop bodies. We also check comprehension value parts. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 0.14.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS427.html","text":"Forbid unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we cannot cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your codebase at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS428.html","text":"Forbid statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS429.html","text":"Forbid multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grow pretty long and you might not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS430.html","text":"Forbid nested functions. Reasoning Nesting functions is bad practice. It is hard to test them and it is hard to separate them later. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures until you need them for decorators or factories. We also forbid nesting lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS431.html","text":"Forbid nested classes. Reasoning Nested classes are really hard to manage. You cannot even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need to nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use a different design (or metaclasses). Configuration This rule is configurable with --nested-classes-whitelist . Default: NESTED_CLASSES_WHITELIST Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0 0.13.0","title":"Found nested class: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS432.html","text":"Forbid magic numbers. What do we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are the numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS433.html","text":"Forbid imports nested in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS434.html","text":"Forbid assigning a variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS435.html","text":"Forbid multiplying lists. Reasoning When you multiply lists - it does not create new values, it creates references to the existing value. It is not what people mean in 99.9% of cases. Solution Use list comprehension or loop instead. Example # Wrong: my_list = [1, 2, 3] * 3 See also https://github.com/satwikkansal/wtfPython#-explanation-8 0.12.0","title":"Found list multiply"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS436.html","text":"Forbid importing protected modules. Related to WPS450 Found protected object import: _ . Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import protected modules. Respect the encapsulation. Example # Correct: import public_module from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass 0.3.0 0.11.0 0.14.0","title":"Found protected module import: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS437.html","text":"Forbid protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS438.html","text":"Forbid raising StopIteration inside generators. Reasoning StopIteration should not be raised explicitly in generators. Solution Use a return statement to get out of a generator. Example # Correct : def some_generator () : if some_value : return yield 1 # Wrong : def some_generator () : if some_value : raise StopIteration yield 1 See also https://docs.python.org/3/library/exceptions.html#StopIteration 0.12.0","title":"Found StopIteration raising inside generator"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS439.html","text":"Forbid Unicode escape sequences in binary strings. Reasoning Binary strings do not work with Unicode. Having Unicode escape characters in there means that you have an error in your code. Solution Use regular strings when escaping Unicode strings. Example # Correct: escaped = '\\u0041' # equals to 'A' # Wrong: escaped = b'\\u0040' # equals to b'\\\\u0040' 0.12.0","title":"Found unicode escape in a binary string: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS440.html","text":"Forbid overlapping local and block variables. What we call local variables: Assigns and annotations Function arguments (they are local to the function body) What we call block variables: Imports Functions and async functions definitions Classes, methods, and async methods definitions For and async for loops variables Except for block exception aliases We allow local variables to overlap themselves, we forbid block variables to overlap themselves. Example # Correct: my_value = 1 my_value = my_value + 1 # Wrong: import my_value my_value = 1 # overlaps with import See also https://github.com/satwikkansal/wtfPython#-explanation-20 0.12.0","title":"Found block variables overlap: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS441.html","text":"Forbid control variables after the block body. What we call block control variables: for loop unpacked variables with context variables Reasoning Variables leaking from the blocks can damage your logic. It might not contain what you think they contain. Solution Use names inside the scope they are defined. Create new functions to return values in case you need to use block variables: when searching for a value, etc. Example # Correct : for my_item in collection : print ( my_item ) # Wrong : for my_item in collection : ... print ( my_item ) See also https://github.com/satwikkansal/wtfPython#-explanation-32 0.12.0 0.14.0","title":"Found control variable used after block: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS442.html","text":"Forbid shadowing variables from outer scopes. We check the function, method, and module scopes. While we do not check the class scope. Because class level constants are not available via regular name, and they are scope to ClassName.var_name . Reasoning Shadowing can lead you to a big pile of storage and unexpected bugs. Solution Use different names and do not allow scoping. Example # Correct: def test(): ... def other(): test1 = 1 # Wrong: def test(): ... def other(): test = 1 # shadows ``test()` function 0.12.0","title":"Found outer scope names shadowing: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS443.html","text":"Forbid explicit unhashable types of asset items and dict keys. Reasoning This will resolve in TypeError in runtime. Solution Use hashable types to define set items and dict keys. Example # Correct: my_dict = {1: {}, (1, 2): [], (2, 3): {1, 2}} # Wrong: my_dict = {[1, 2]: [], {2, 3}: {1, 2}} 0.12.0","title":"Found unhashable item"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS444.html","text":"Forbid explicit falsely-evaluated conditions with several keywords. We check: ast.While ast.Assert We do not check variables, attributes, calls, bool and bin operators, etc. We forbid constants and some expressions. Reasoning Some conditions tell us that this node won't work correctly. So, we need to check if we can fix that. Solution Remove the unreachable node, or change the condition item. Example # Correct: assert some_variable while True : ... # Wrong: assert [] while False : ... 0.12.0 0.13.0","title":"Found incorrect keyword condition"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS445.html","text":"Forbid incorrectly named keywords in starred dicts. Reasoning Using the incorrect keywords in a starred dict. Eg.: print(**{'@': 1}) . Solution Don't use incorrect identifiers as keywords. Example # Correct : print ( ** { ' end ' : ' | ' } ) # Wrong : print ( ** { ' 3end ' : ' | ' } ) 0.13.0","title":"Found incorrectly named keyword in the starred dict"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS446.html","text":"Forbid approximate constants. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare numbers as strings and raise this violation when they start with the same chars. Solution Use pre-defined constants. Example # Correct: from math import pi random_number = 3.15 too_short = 3.1 # Wrong: pi = 3.14 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. See also https://docs.python.org/3/library/math.html#constants 0.13.0","title":"Found approximate constant: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS447.html","text":"Forbid using the alphabet as a string. Reasoning Some constants are already defined. No need to write to them again, use existing values. We just compare strings and raise this violation when they have the same chars. Solution Use pre-defined constants. Example # Correct: import string UPPERCASE_ALPH = string . ascii_uppercase LOWERCASE_ALPH = string . ascii_lowercase # Wrong: GUESS_MY_NAME = \"abcde...WXYZ\" UPPERCASE_ALPH = \"ABCD...WXYZ\" LOWERCASE_ALPH = \"abcd...wxyz\" 0.13.0","title":"Found alphabet as strings: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS448.html","text":"Forbid incorrect order of except . Note, we only check for built-in exceptions because we cannot statically identify the inheritance order of custom ones. Reasoning Using incorrect order of exceptions is error-prone, since you end up with some unreachable exception clauses. Solution Use the correct order of exceptions. Example # Correct: try: ... except ValueError: ... except Exception: ... # Wrong: try: ... except Exception: ... except ValueError: ... See also https://bit.ly/36MHlzw 0.13.0","title":"Found incorrect exception order"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS449.html","text":"Forbid float keys. Reasoning float is a very ugly data type. It has a lot of \"precision\" errors. When we use float as keys we can hit this wall. Moreover, we cannot use float keys with lists, by design. Solution Use other data types: integers, decimals, or use fuzzy logic. Example # Correct: some = {1: 'a'} some[1] # Wrong: some = {1.0: 'a'} some[1.0] 0.13.0","title":"Found float used as a key"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS450.html","text":"Forbid importing protected objects from modules. Related to WPS436 Found protected module import: _ . Reasoning When importing a protected modules' members, we break the contract which the authors of this module enforce. By disrespecting encapsulation, we may break the code at any moment. Solution Do not import protected objects from modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: from some.module import _protected from some.module import _protected as not_protected 0.14.0","title":"Found protected object import: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS451.html","text":"Forbid positional only or / arguments. This violation is only raised for python3.8+ , earlier versions do not have this concept. Reasoning This is a very rare case. Almost exclusively used by C code and stdlib. There's no point in declaring your own parameters as positional only. It will break your code! Solution Use regular arguments. In case you are working with C, then this violation can be ignored. Example # Correct: def my_function(first, second): ... # Wrong: def my_function(first, /, second): ... See also https://www.python.org/dev/peps/pep-0570/ 0.14.0","title":"Found positional-only argument"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS452.html","text":"Forbid break and continue in a finally block. Related to WPS419 Found try/else/finally with multiple return paths . Reasoning Putting any control statements in finally` is a terrible practice, because finally` is implicitly called and can cause damage to your logic with its implicitness. It should not be allowed. Solution Remove break and continue from finally blocks. Example # Correct : try : ... finally : ... # Wrong : try : ... finally : break try : ... finally : continue 0.14.0","title":"Found break or continue in finally block"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS453.html","text":"Forbid executing a file with shebang incorrectly set. A violation is raised in these cases : Shebang is present but the file is not executable. The file is executable but no shebang is present. Shebang is present but does not contain \"python\". Whitespace is present before the shebang. Presence of blank lines or commented lines before the shebang. Reasoning Setting the shebang incorrectly causes an executable mismatch. Solution Ensure that the shebang is present on the first line, and contains \"python\", and there is no leading whitespace. Example # Correct: #!/usr/bin/env python # Wrong: #!/usr/bin/env #!/usr/bin/env python 0.14.0","title":"Found executable mismatch: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS454.html","text":"Forbid raising Exception or BaseException . Reasoning Exception and BaseException are inconvenient to catch. And when you catch them you can accidentally suppress other exceptions. Solution Use a user-defined exception, subclassed from Exception . Example # Correct: raise UserNotFoundError raise UserNotFoundError(\"cannot find user with the given id\") # Wrong: raise Exception raise Exception(\"user not found\") raise BaseException raise BaseException(\"user not found\") See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions 0.15.0","title":"Found wrong raise exception type: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS455.html","text":"Forbids using non-trivial expressions as a parameter for except . Reasoning Expressions used as an argument for except could be hard to read and hide real list of exceptions being expected to occur in the outlined code block. Solution Use separate except blocks for each exception or provide a tuple of exception classes. Example # Correct: try: ... except ValueError: ... except TypeError: ... try: ... except (TypeError, ValueError): ... # Wrong: try: ... except TypeError or ValueError: ... 0.15.0","title":"Found non-trivial expression as an argument for \"except\""},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS456.html","text":"Forbids using float(\"NaN\") construct to generate NaN. Reasoning This method to generate NaN is really confusing and is a good way to catch a lot of unexpected bugs. Solution Even if you're 100% sure what you're doing, use math.nan instead. Example # Correct: min(math.nan, 3) # Wrong: min(float(\"NAN\"), 3) 0.15.0","title":"Found \"NaN\" as argument to float()"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS457.html","text":"Forbids use of infinite while True: loops. Reasoning Infinite loops will cause bugs in code. Solution Add either a return, raise, or break to handle the infinite loop. Example # Correct : while True : print ( ' forever ' ) break # Wrong : while True : print ( ' forever ' ) 0.15.0","title":"Found an infinite while loop"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS458.html","text":"Forbids to import from already imported modules. Reasoning Importing objects from already imported modules is inconsistent and error-prone. Solution Do not import objects from already imported modules or use aliases when it cannot be avoided. Example # Correct: import public from public.module import FooClass import hypothesis from hypothesis import strategies as st # Wrong: from public import utils from public.utils import something import hypothesis from hypothesis import strategies 0.15.0","title":"Found imports collision: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS459.html","text":"Forbids comparisons with float and complex . Reasoning This is a best practice rule, as float and complex suffer from representation error, leading to possibly incorrect results during comparison. Solution Use fuzzy operators. 1. abs(f1 - f2) <= allowed_error 2. math.isclose(f1, f2) (for float ) 3. cmath.isclose(c1, c2) (for complex ) 4. Custom logic, not using operators Example # Correct: math.isclose(3.0, 0.3 / 0.1) cmath.isclose(3 + 4j, (0.3 + 0.4j) / 0.1) # Wrong: 3.0 == 0.3 / 0.1 3 + 4j == (0.3 + 0.4j) / 0.1 0.15.0","title":"Found comparison with float or complex number"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS460.html","text":"Forbids to have single element destructuring. Reasoning Having single element destructuring is not readable. Solution Use access by index instead. Example # Correct: first = single_element_list[0] # Wrong: (first,) = [1] 0.15.0","title":"Found single element destructuring"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS461.html","text":"Forbids to use specific inline ignore violations. There can be forbidden a specific violation or whole class of violations. Reasoning There are violations important for specific project that must not be ignored, e.g. complexity or best practices violations. Solution Remove inline ignore for forbidden violations. Configuration This rule is configurable with --forbidden-inline-ignore . Default: FORBIDDEN_INLINE_IGNORE 0.15.0","title":"Forbidden inline ignore: _"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS462.html","text":"Frobids direct usage of multiline strings. Multiline strings are only allowed in docstrings or assignments to variables. Reasoning Direct usage of multiline strings is not readable. One should not depend on the current indentation, e.g. in comparisons or function calls. Solution Assign a multiline string to a variable. Example # Correct: multiline = \"\"\" abc abc \"\"\" # Wrong: function(\"\"\" abc abc \"\"\") 0.15.0","title":"Wrong multiline string usage"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS463.html","text":"Forbids to have functions starting with get_ without returning a value. Applies to both methods and functions. Reasoning A get_ function is generally expected to return a value. Otherwise, it is most likely either an error or bad naming. Solution Make sure getter functions return or yield a value on all execution paths, or rename the function. Example # Correct : def get_random_number () : return random . randint ( 1 , 10 ) # Wrong : def get_random_number () : print ( ' I do not return a value! ' ) 0.15.0","title":"Found a getter without a return value"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS464.html","text":"Forbid empty comments. Empty comments are only allowed in between valid comments. Reasoning Empty comments that do not help formatting should be excluded. Solution Remove the empty comments. Example # Correct: # First line # # Samples: # One # Two my_var = 1 # Wrong: # my_var = 1 0.15.0","title":"Found empty comment"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS465.html","text":"Forbid comparisons between bitwise and boolean expressions. Empty comments are only allowed in between valid comments. Reasoning This case indicates that a person confused & with and and | with or . This can be the case if a person is coming from another language. Solution Change bitwise operator to boolean operators. Example # Correct: first | 10 # Wrong: result = ((first > 0) & False) 0.15.0","title":"Found likely bitwise and boolean operation mixup"},{"location":"wemake-python-styleguide/0.15.0/violations/best_practices/WPS466.html","text":"Forbid using complex grammar for using decorators. This violation is only raised for python3.9+ , earlier versions do not have this concept. Reasoning New grammar allows to use decorators in a more liberal way. It is probably not a good idea. Because decorators should be simple and easy to read. Solution Use names, attributes, and calls as decorators only. You are free to pass any args to function calls, however. Example # Correct : @some . decorator ( args ) def my_function () : ... # Wrong : @some . decorator [ 'method' ] + other def my_function () : ... 0.15.0","title":"Found new-styled decorator"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated. See also: https://sobolevn.me/2019/10/complexity-waterfall","title":"WPS2xx Complexity"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS200.html","text":"Forbid modules with complex lines. We are using the Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measure the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS201.html","text":"Forbid modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports and sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why would a single module have so many dependencies? So, the module becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several modules. We do not make any distinction between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS202.html","text":"Forbid too many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any distinctions between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS203.html","text":"Forbid modules with too many imported names. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imported names without prefixes is quite expensive. You have to memorize all the source locations of the imports and sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why would a single module have so many dependencies? So, the module becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several modules. Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imported-names . Default: MAX_IMPORTED_NAMES 0.12.0","title":"Found module with too many imported names: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS204.html","text":"Forbid overused expressions in a module, function or method. What do we call an \"overused expression\"? When you use any expression (like user_dict['age'] for example) inside your code, you always have to track that you are not using it \"too much\" because if that expression is everywhere inside your code, it is a sign of a problem. It means that you are missing an abstraction. We check for overused expressions on two levels: per each function per all module Related to WPS213 Found too many expressions: _ . Reasoning Overusing expressions leads to losing the parts that can and should be refactored into variables, methods, and properties of objects. Solution Refactor expressions to be an attribute, a method, or a new variable. Configuration This rule is configurable with --max-module-expressions . Default: MAX_MODULE_EXPRESSIONS And with --max-function-expressions . Default: MAX_FUNCTION_EXPRESSIONS 0.12.0 0.14.0","title":"Found overused expression: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS210.html","text":"Forbid too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will have trouble understanding what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count a variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS211.html","text":"Forbid too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it is a sign that it should be refactored. It also indicates that the function does too many things at once. Solution Split the function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS212.html","text":"Forbid placing too many return statements in a function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split the function into multiple functions. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS213.html","text":"Forbid putting too many expressions in a single function. This rule is quite similar to \"max lines\" in a function, but is much nicer because we don't count lines, we count real code entities. This way adding just several extra empty lines for readability will never trigger this violation. Related to WPS204 Found overused expression: _ . Reasoning When there are too many expressions it means that this function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0 See also https://en.wikipedia.org/wiki/Expression_(computer_science)","title":"Found too many expressions: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS214.html","text":"Forbid too many methods in a single class. Reasoning Having too many methods might lead to the \"God object\" anti-pattern. This kind of object can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes, then use composition or inheritance to refactor your code. This will protect you from the \"God object\" anti-pattern. We do not make any distinctions between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS215.html","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS216.html","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you are trying to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you are trying to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into smaller ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS217.html","text":"Forbid placing too many await expressions in a function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where we are and what is going on. Solution Change your design. Split functions into smaller ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS218.html","text":"Forbid placing too many assert statements into a function. Reasoning When there are too many assert keywords, functions are starting to get really complex. It might indicate that your tests or contracts are too big. Solution Create rich assert statements, use higher-level contracts, or create special guard functions. Configuration This rule is configurable with --max-asserts . Default: MAX_ASSERTS 0.12.0","title":"Found too many assert statements: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS219.html","text":"Forbid consecutive expressions with too deep access level. We consider only these expressions as accesses: ast.Subscript ast.Attribute We do not treat ast.Call as an access, since there are a lot of call-based APIs like Django ORM, builder patterns, etc. Reasoning Having too deep access level indicates a bad design and overcomplicated data without proper API. Solution Split the expression into variables, functions or classes. Refactor the API for your data layout. Example # Correct: access level = 4 self . attr . inner . wrapper [ 1 ] # Correct: access level = 1 manager . filter (). exclude (). annotate (). values (). first () # Wrong: access level = 5 self . attr . inner . wrapper . method . call () # Wrong: access level = 5 # ``obj` has access level of 2: # ``.attr`, ``.call` # ``call()` has access level of 5: # ``.other`, ``[0]`, ``.field`, ``.type`, ``.boom` obj . attr . call (). other [ 0 ] . field . type . boom Configuration This rule is configurable with --max-access-level . Default: MAX_ACCESS_LEVEL 0.12.0","title":"Found too deep access level: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS220.html","text":"Forbid nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS221.html","text":"Forbid complex lines. We are using the Jones Complexity algorithm to count complexity. What is the Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS222.html","text":"Forbid conditions with too many logical operators. We use MAX_CONDITIONS as a default value. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS223.html","text":"Forbid too many elif branches. We use MAX_ELIFS as a default value. Reasoning This rule is specifically important because many elif branches indicates a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use an interface that just calls a specific method without if . Another option is to separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS224.html","text":"Forbid too many for statements within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of the comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS225.html","text":"Forbid too many except cases in a single try clause. We use MAX_EXCEPT_CASES as a default value. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design since one controlling structure will become too complex. Also, you will need to test a lot of logic paths in your application. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS226.html","text":"Forbid the overuse of string constants. We allow to use strings without any restrictions as annotations for variables, arguments, return values, and class attributes. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant and should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS227.html","text":"Forbid yielding tuples that are too long. Reasoning Long yield tuples complicate generator usage. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS228.html","text":"Forbid compare expressions that are too long. Reasoning Compare expressions that are too long indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, separate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS229.html","text":"Forbid try blocks with bodies that are too long. Reasoning Having too many statements inside your try block can lead to situations when a statement raises an exception and you are not aware of it since it is not expected. Solution Move things out of the try block or create new functions. The fewer lines you have in your try block - the safer you are from accidental errors. Configuration This rule is configurable with --max-try-body-length . Default: MAX_TRY_BODY_LENGTH See also https://adamj.eu/tech/2019/10/02/limit-your-try-clauses-in-python/ 0.12.0","title":"Found too long try body length: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS230.html","text":"Forbid instances with too many public attributes. We only check static definitions in a form of self.public = ... . We do not count parent attributes. We do not count properties. We do not count annotations. We do not count class attributes. We do not count duplicates. Reasoning Having too many public instance attributes means that your class is too complex in terms of coupling. Other classes and functions will rely on these concrete fields instead of better abstraction layers. Solution Make some attributes protected. Split this class into several. If the class is a Data Transfer Object, then use @dataclass decorator. Configuration This rule is configurable with --max-attributes . Default: MAX_ATTRIBUTES See also https://en.wikipedia.org/wiki/Coupling_(computer_programming) 0.12.0","title":"Found too many public instance attributes: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS231.html","text":"Forbid functions with too much cognitive complexity. Reasoning People are not great at reading and interpreting code in their heads. That's why code with a lot of nested loops, conditions, exceptions handlers, and context managers is hard to read and understand. Solution Rewrite your code to be simpler. Use flat structures and conditions, remove nested loops. Configuration This rule is configurable with --max-cognitive-score . Default: MAX_COGNITIVE_SCORE See also https://en.wikipedia.org/wiki/Cognitive_complexity https://pypi.org/project/cognitive-complexity/ https://github.com/Melevir/flake8-cognitive-complexity 0.13.0","title":"Found function with too much cognitive complexity: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS232.html","text":"Forbid modules with average cognitive complexity that is too high. Reasoning Modules with lots of functions might hide cognitive complexity inside many small and relatively simple functions. Solution Rewrite your code to be simpler or use several modules. Configuration This rule is configurable with --max-cognitive-average . Default: MAX_COGNITIVE_AVERAGE See also https://en.wikipedia.org/wiki/Cognitive_complexity 0.13.0","title":"Found module cognitive complexity that is too high: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS233.html","text":"Forbid call chains that are too long. Reasoning Call chains that are too long are overcomplicated and indicators of bad API design. Solution Split the expression into variables, functions or classes. Refactor the API to allow higher-level access to functions. Configuration This rule is configurable with --max-call-level . Default: MAX_CALL_LEVEL 0.13.0","title":"Found call chain that is too long: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS234.html","text":"Forbid overly complex annotations. Annotation complexity is maximum annotation nesting level. ## Example List[int] has complexity of 2 and Tuple[List[Optional[str]], int] has complexity of 4. Reasoning Overly complex annotations make your types unreadable. And make developers afraid of types. Solution Create type aliases. And use them a lot! Configuration This rule is configurable with --max-annotation-complexity . Default: MAX_ANN_COMPLEXITY See also https://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases https://github.com/best-doctor/flake8-annotations-complexity 0.14.0","title":"Found overly complex annotation: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS235.html","text":"Forbid from ... import ... with too many imported names. Reasoning Importing too many names from one import is an easy way to cause the violation WPS203 - too many imported names. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names Configuration This rule is configurable with --max-import-from-members . Default: MAX_IMPORT_FROM_MEMBERS 0.15.0","title":"Found too many imported names from a module: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS236.html","text":"Forbid using too many variables to unpack a tuple. Reasoning The order and meaning are hard to remember. Solution If you have more than 2 values in a tuple, consider using typing.NamedTuple or a dataclass instead. Example # Correct: result = foo() # Wrong: a, b, c, d, e = foo() Configuration This rule is configurable with --max-tuple-unpack-length . Default: MAX_TUPLE_UNPACK_LENGTH 0.15.0","title":"Found too many variables used to unpack a tuple: _"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS237.html","text":"Forbids f strings that are too complex. A complex format string is defined as use of any formatted value that is not: the value of a variable the value of a collection through lookup with a variable, number, or string as the key the return value of a procedure call without arguments Related to WPS305 Found f string . Reasoning Complex f strings are often difficult to understand, making the code less readable. Generally we don't allow f strings but this violation exists in case the user decides to ignore the general violation. Solution Use .format() or assign complex expressions to variables before formatting. Example # Correct : f ' smth {user.get_full_name()} ' # Wrong : f ' {reverse(\"url-name\")}?{\"&\".join(\"user=\"+uid for uid in user_ids)} ' 0.15.0","title":"Found a too complex f string"},{"location":"wemake-python-styleguide/0.15.0/violations/complexity/WPS238.html","text":"Forbids too many raise statements in a function. Reasoning Too many raise statements in a function make the code untraceable and overcomplicated. Solution Split the function into smaller functions, such that each of them can raise less errors. Create more standard errors, or use alternative ways to raise them. Configuration This rule is configurable with --max-raises . Default: MAX_RAISES 0.15.0","title":"Found too many raises in a function: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/index.html","text":"These checks limit Python's inconsistencies. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to work with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right and we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective, but we love them.","title":"WPS3xx Consistency"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS300.html","text":"Forbid imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS301.html","text":"Forbid imports like import os.path . Reasoning There are too many ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS302.html","text":"Forbid u string prefix. Reasoning We haven't needed this prefix since python2 , but it is still possible to find it in a codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS303.html","text":"Forbid underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS304.html","text":"Forbid partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and trailing zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS305.html","text":"Forbid f strings. Reasoning f strings implicitly rely on the context around them. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Moreover, they do two things at once: declare a template and format it in a single action. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS306.html","text":"Forbid writing classes without base classes. Please, note that this rule has nothing to do with python2 . We care only about consistency here. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Why? Because it is consistent with other use-cases. When we have a base class A , we write class MyClass(A): . When we have no base class, we have an implicit object base class. So, we still use the same syntax: class MyClass(object): . Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... 0.1.0","title":"Found class without a base class: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS307.html","text":"Forbid multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS308.html","text":"Forbid comparing between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the comparison, will always be the same. Solution Remove the constant comparison and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant comparison"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS309.html","text":"Forbid comparisons where the argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle the ordering of the arguments all the time. Bring consistency to the comparison! Solution Refactor your comparison expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS310.html","text":"Forbid uppercase X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written in lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS311.html","text":"Forbid comparisons with multiple in checks. Reasoning Using multiple in checks is unreadable. Solution Refactor your comparison expression to use several and conditions or separate if statements in cases where it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS312.html","text":"Forbid comparisons of a variable to itself. Reasoning When a variable is compared to itself, it is typically an indication of a mistake since the Boolean value of the comparison will always be the same. Solution Remove the comparison and any associated dead code. Example # Correct : do_something () # Wrong : if a < a : do_something () else : do_something_else () 0.3.0","title":"Found comparison of a variable to itself"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS313.html","text":"Enforce separation of parenthesis from keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between the keyword and opening parenthesis. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parenthesis immediately after a keyword"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS314.html","text":"Forbid using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Found conditional that always evaluates the same"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS315.html","text":"Forbid extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Found extra object in parent classes list"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS316.html","text":"Forbid multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into a tuple or if we are just using two context managers. Solution Use several context managers or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS317.html","text":"Forbid incorrect indentation for parameters. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) # Correct complex case: @ pytest . mark . parametrize (( 'boolean_arg' , 'string_arg' ), [ ( True , \"string\" ), ( False , \"another string\" ), ]) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS318.html","text":"Forbid extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you want to keep the indentation level equal for this specific node, but that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block level should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') This rule is consistent with the \"Vertical Hanging Indent\" option for multi_line_output setting of isort . To avoid conflicting rules, you should set multi_line_output = 3 in the isort settings. See also https://github.com/timothycrosley/isort#multi-line-output-modes https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/isort.toml 0.6.0","title":"Found extra indentation"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS319.html","text":"Forbid brackets in the wrong position. Reasoning You can do bizarre things with bracket positioning in python. We require all brackets to be consistent. Solution Place bracket on the same line, in case of a single line expression. Or place the bracket on a new line in case of a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS320.html","text":"Forbid multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS321.html","text":"Forbid uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase string modifiers. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS322.html","text":"Forbid triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS323.html","text":"Forbid % formatting on strings. We check for string formatting. We try not to issue false positives. It is better for us to ignore a real (but hard to detect) case, then marking a valid one as incorrect. Internally we check for this pattern in string definitions: %[ (name) ] [ flags ] [ width ] [ .precision ] [ {h | l} ] type This is a C format specification. Related to WPS305 Found f string and solves the same problem. Reasoning You must use a single formatting method across your project. Solution We enforce to use string .format() method for this task. Example # Correct: 'some string', 'your name: {0}', 'data: {data}' # Wrong: 'my name is: %s', 'data: %(data)d' It might be a good idea to disable this rule and switch to flake8-pep3101 in case your project has a lot of false-positives due to some specific string chars that uses % a lot. See also https://github.com/gforcada/flake8-pep3101 https://msdn.microsoft.com/en-us/library/56e442dc.aspx https://docs.python.org/3/library/stdtypes.html#old-string-formatting https://pyformat.info/ 0.14.0","title":"Found % string formatting"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS324.html","text":"Enforce consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without a value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 0.7.0","title":"Found inconsistent return statement"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS325.html","text":"Enforce consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS326.html","text":"Forbid implicit string concatenation. Reasoning This is error-prone, since you can possibly miss a comma in a collection of strings and get an implicit concatenation. And because there are safer ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS327.html","text":"Forbid meaningless continue in loops. Reasoning Placing this keyword at the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) for number in [ 1 , 2 , 3 ]: with suppress ( Exception ) : do_smth ( some_obj ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue for number in [ 1 , 2 , 3 ]: try : do_smth ( some_obj ) except Exception : continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS328.html","text":"Forbid meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by accident. This might be also an overuse of syntax. Solution Remove node or make sure it makes sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS329.html","text":"Forbid meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() try: ... except ValueError as exc: raise CustomReadableException from exc # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS330.html","text":"Forbid unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS331.html","text":"Forbid local variables that are only used in return statements. We also allow cases when a variable is assigned, then there are some other statements without direct variable access and the variable is returned. We reserve this use-case to be able to do some extra work before the function returns. We also allow the return of partial, sorted, or modified tuple items that are defined just above. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 def other_function () : some_value = 1 do_something ( some_value ) return some_value # Wrong : def some_function () : some_value = 1 return some_value 0.9.0 0.14.0","title":"Found variables that are only used for return: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS332.html","text":"Forbid local variable that are only used in return statements. This violation can only be thrown on python3.8+ . Reasoning Code with := is hardly readable. It has big problems with scoping and reading order. And it can lead to a huge mess inside your code. Python is not expression-based. Solution Don't use fancy stuff, use good old assignments. Example # Correct : some = call () if some : print ( some ) # Wrong : if some : = call () : print ( some ) 0.14.0","title":"Found walrus operator"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS333.html","text":"Forbid implicit complex comparison expressions. Reasoning Two comparisons in python that are joined with and operator mean that you have a complex comparison with tree operators. Solution Refactor your comparison without and but with the third operator. Notice that you might have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS334.html","text":"Forbid reversed order complex comparison expressions. Reasoning Comparisons where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is inconsistent. Solution Reverse the order, so the smallest element comes first and the biggest one comes last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex comparison"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS335.html","text":"Forbid wrong for loop iter targets. We forbid to use: Lists and list comprehensions Sets and set comprehensions Dicts and dict comprehensions Generator expressions Empty tuples Reasoning Using lists, dicts, and sets do not make much sense. You can use tuples instead. Using comprehensions implicitly creates a two level loop, that is hard to read and deal with. Solution Use tuples to create explicit iterables for for loops. In case you are using a comprehension, create a new variable. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0 0.12.0","title":"Found incorrect for loop iter type"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS336.html","text":"Forbid explicit string concatanation in favour of .format method. However, we still allow multiline string concatanation as a way to write long strings that does not fit the 80-chars rule. Reasoning When formatting strings one must use .format and not any other formatting methods like % , + , or f . This is done for consistency reasons. Solution Join strings together if you can, or use .format method. Example # Correct: x = 'ab: {0}'.format(some_data) # Wrong: x = 'a' + 'b: ' + some_data 0.12.0","title":"Found explicit string concatanation"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS337.html","text":"Forbid multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has and it decreases readability of the code. Solution Divide multiline conditions to some if condition or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS338.html","text":"Forbid incorrect order of methods inside a class. We follow the same ordering: __new__ __init__ __call__ __await__ public and magic methods protected methods private methods (we discourage using them) We follow \"Newspaper order\" where the most important things come first. Reasoning It is hard to read classes where API declarations are bloated with implementation details. We need to see the important stuff first, then we can go deeper in case we are interested. Solution Reorder methods inside your class to match our format. 0.12.0","title":"Found incorrect order of methods in a class"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS339.html","text":"Forbid meaningless zeros. We discourage using meaningless zeros in float, binary, octal, hex, and exponential numbers. Reasoning There are \\~infinite ways to write these numbers by adding meaningless leading zeros to the number itself. 0b1 is the same as 0b01 and 0b001 . How can a language be called consistent if you can write numbers in an infinite ways? It hurts readability and understanding of your code. Solution Remove meaningless leading zeros. Example # Correct: numbers = [1.5, 0b1, 0o2, 0x5, 10e10] # Wrong: numbers = [1.50, 0b00000001, 0o0002, 0x05, 10e010] 0.12.0","title":"Found number with meaningless zeros: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS340.html","text":"Forbid extra + signs in the exponent. Reasoning Positive exponent is positive by default, there's no need to write an extra + sign. We enforce consistency with this rule. Solution Remove meaningless + sign from the exponent. Example # Correct: number = 1e1 + 1e-1 # Wrong: number = 1e+1 0.12.0","title":"Found exponent number with positive exponent: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS341.html","text":"Forbid letters as hex numbers. Reasoning One can write 0xA and 0xa which is inconsistent. This rule enforces upper-case letters in hex numbers. Solution Use uppercase letters in hex numbers. Example # Correct: number = 0xABCDEF # Wrong: number = 0xabcdef 0.12.0","title":"Found wrong hex number case: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS342.html","text":"Forbid \\\\ escape sequences inside regular strings. Reasoning It is hard to read escape sequences inside regular strings, because they use \\\\ double backslash for a single character escape. Solution Use raw strings r'' to rewrite the escape sequence with a \\ single backslash. Example # Correct: escaped = [r'\\n', '\\n'] # Wrong: escaped = '\\\\n' 0.12.0","title":"Found implicit raw string: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS343.html","text":"Forbid uppercase complex number suffix. Reasoning Numbers should be consistent. Solution Use lowercase suffix for imaginary part. Example # Correct: complex_number = 1j # Wrong: complex_number = 1J 0.12.0","title":"Found wrong complex number suffix: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS344.html","text":"Forbid explicit division (or modulo) by zero. Reasoning This will just throw ZeroDivisionError . If that's what you need: just throw it. No need to use undefined math behaviours. Or it might be just a typo / mistake, then fix it. Solution Use ZeroDivisionError or make your number something besides 0 . Example # Correct: raise ZeroDivisionError() # Wrong: 1 / 0 1 % 0 0.12.0","title":"Found explicit zero division"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS345.html","text":"Forbid meaningless math operations with 0 and 1 . Reasoning Adding and subtracting zero does not change the value. There's no need to do that. Multiplying by zero is also redundant: it can be replaced with explicit 0 assign. Multiplying and dividing by 1 is also meaningless. Likewise, using | or ^ with 0 , and using the % operator with 1 are unnecessary. Solution Remove useless operations. Example # Correct: number = 1 zero = 0 one = 1 three = 3 # Wrong: number = 1 + 0 * 1 zero = some * 0 / 1 one = some ** 0 ** 1 three = 3 ^ 0 three = 3 | 0 three = 3 % 1 0.12.0 0.15.0","title":"Found meaningless number operation"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS346.html","text":"Forbid double minus operations. Reasoning Having two operations is harder than having just one. Two negations are harder than one positive expression. Two negations equal to one positive expression. Positive and negative equal to one negative. Solution Replace double minus operation to a single one with plus. Replace 'plus-minus' operation to a single one with minus. Example # Correct: number = 3 + 1 number += 6 number -= 2 # Wrong: number = 3 - -1 number -= -6 number += -2 0.12.0","title":"Found wrong operation sign"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS347.html","text":"Forbid imports that may cause confusion outside of the module. Names that we forbid to import: Common names like dumps and loads Names starting with to_ and from_ Too short names like Q or F , but we are fine with _ Reasoning See datetime.* in code? You know that it's from datetime. See BaseView in a Django project? You know where it is from. See loads ? It can be anything: yaml , toml , json , etc. We are also enforcing consistency with our naming too-short rules here. Solution Use package level imports or import aliases. See VAGUE_IMPORTS_BLACKLIST for the full list of bad import names. Example # Correct: import json import dumps # package names are not checked from json import loads as json_loads # Wrong: from json import loads 0.13.0 0.14.0","title":"Found vague import that may cause confusion: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS348.html","text":"Forbid starting lines with a dot. Reasoning We enforce strict consistency rules about how to break lines. We also enforce strict rules about multi-line parameters. Starting new lines with the dot means that this rule is broken. Solution Use () to break lines in a complex expression. Example # Correct: some = MyModel.objects.filter( ..., ).exclude( ..., ).annotate( ..., ) # Wrong some = ( MyModel.objects.filter(...) .exclude(...) .annotate(...) ) 0.13.0","title":"Found a line that starts with a dot"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS349.html","text":"Forbid redundant components in a subscript's slice. Reasoning We do it for consistency reasons. Example # Correct: array[:7] array[3:] # Wrong: x[0:7] x[3:None] 0.13.0","title":"Found redundant subscript slice"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS350.html","text":"Enforce using augmented assign pattern. Reasoning a += b is short and correct version of a = a + b . Why not using the short version? Example # Correct: a += b # Wrong: a = a + b 0.13.0","title":"Found usable augmented assign pattern"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS351.html","text":"Forbid unnecessary literals in your code. Reasoning We discourage using primitive calls to get default type values. There are better ways to get these values. Solution Use direct default values of the given type Example # Correct: default = 0 # Wrong: default = int() 0.13.0","title":"Found unnecessary literals"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS352.html","text":"Forbid multiline loops. Reasoning It decreased the readability of the code. Solution Use single line loops and create new variables in case you need to fit too many logic inside the loop definition. Example # Correct : for num in some_function ( arg1 , arg2 ) : ... # Wrong : for num in range ( arg1 , arg2 , ) : ... 0.13.0","title":"Found multiline loop"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS353.html","text":"Forbid yield from with several nodes. We allow to yield from tuples, names, attributes, calls, and subscripts. Reasoning We enforce consistency when yielding values from tuple instead of any other types. It also might be an error when you try to yield from something that is not iterable. Solution Use allowed node types with yield from . Example # Correct: yield from (1, 2, 3) yield from some # Wrong: yield from [1, 2, 3] 0.13.0","title":"Found incorrect yield from target"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS354.html","text":"Forbid consecutive yield expressions. We raise this violation when we find at least two consecutive yield expressions. Reasoning One can write multiple yield nodes in a row. That's inconsistent. Because we have yield from form. Solution It can be easily changed to yield from (...) format. 0.13.0","title":"Found consecutive yield expressions"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS355.html","text":"Forbid useless blank lines before and after brackets. Reasoning We do this for consistency. Solution Remove blank lines from the start and from the end of a collection. Example # Correct: arr = [ 1, 2, ] # Wrong: arr = [ 1, 2, ] 0.13.0","title":"Found an unnecessary blank line before a bracket"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS356.html","text":"Forbid unnecessary iterable unpacking. Reasoning We do this for consistency. Solution Do not use iterable unpacking when it's not necessary. Example # Correct: [1, *numbers, 99] {*iterable, *other_iterable} list(iterable) first, *iterable = other_iterable # Wrong: [*iterable] *iterable, = other_iterable 0.13.0","title":"Found an unnecessary iterable unpacking"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS357.html","text":"Forbid using \\r (carriage return) in line breaks. Reasoning We enforce Unix-style newlines. We only use newlines ( \\n ), not carriage returns. So \\r line breaks not allowed in code. Solution Use only \\n (not \\r\\n or \\r ) to break lines. 0.14.0","title":"Found a \\r (carriage return) line break"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS358.html","text":"Forbid using float zeros: 0.0 . Reasoning Float zeros can be used as variable values which may lead to typing bugs when trying to perform an operation between an int number and the float zero. Solution Use int zeros (0). If a float is needed, it should be cast explicitly. Example # Correct: zero = 0 # Wrong: zero = 0.0 0.15.0","title":"Found a float zero (0.0)"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS359.html","text":"Forbids to unpack iterable objects to lists. Reasoning We do this for consistency. Solution Do not unpack iterables to lists, use tuples for that. Example # Correct: first, second = (7, 4) first, *iterable = other_iterable # Wrong: [first, second] = (7, 4) [first, *iterable] = other_iterable 0.15.0","title":"Found an iterable unpacking to list"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS360.html","text":"Forbid the use of raw strings when there is no backslash in the string. Reasoning Raw string are only needed when dealing with \\ in the string. Solution Do not prefix the string with r . Use a normal string instead. Example # Correct: r'This is a correct use \\n' # Wrong: r'This string should not be prefixed with r.' 0.15.0","title":"Found an unnecessary use of a raw string: _"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS361.html","text":"Forbids inconsistent newlines in comprehensions. Reasoning We do this for consistency. Solution Either place comprehension on a single line or ensure that action, for loops, and condition are all on different lines. Example # Correct : list = [ some ( number ) for number in numbers ] list = [ some ( number ) for numbers in matrix for number in numbers if number > 0 ] # Wrong : list = [ some ( number ) for number in numbers if number > 0 ] 0.15.0","title":"Found an inconsistently structured comprehension"},{"location":"wemake-python-styleguide/0.15.0/violations/consistency/WPS362.html","text":"Forbid assignment to a subscript slice. Reasoning Assingment to a slice may lead to a list changing its size implicitly and strangely which makes it hard to spot bugs. Solution Use explicit index assignment in place of slice assignment. Why you may disable or inline-ignore this rule? The quite common and useful example which violates this rule is inplace list replacement via [:] - this helps to keep the same object reference while it content could be completely erased or replaced with the new one. One more thing: slice assignment is the only way for inplace array multiple replacement when you need that. Example # Correct: a[5] = 1 # Wrong: a[1:3] = [1, 2] a[slice(1)] = [1, 3] 0.15.0","title":"Found assignment to a subscript slice"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII characters for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Do not mask builtins Do not use unreadable character sequences like O0 and Il Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Do not define unused variables unless you are unpacking other values as well Do not use multiple underscores ( __ ) to create unused variables Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Enum fields also must use snake_case Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called clearly and properly, not just TT or KT or VT","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS100.html","text":"Forbid blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py See also https://tonsky.me/blog/utils/ 0.1.0","title":"Found wrong module name"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS101.html","text":"Forbid magic names (except some whitelisted ones). Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS102.html","text":"Forbid module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS110.html","text":"Forbid blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the base list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None Configuration This rule is configurable with --allowed-domain-names . Default: ALLOWED_DOMAIN_NAMES And with --forbidden-domain-names . Default: FORBIDDEN_DOMAIN_NAMES The options listed above are used to create new variable names' blacklist starting from VARIABLE_NAMES_BLACKLIST . 0.1.0","title":"Found wrong variable name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS111.html","text":"Forbid short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. We do not count trailing and leading underscores when calculating length. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0 0.12.0","title":"Found too short name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS112.html","text":"Forbid private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0 0.14.0","title":"Found private name pattern: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS113.html","text":"Forbid using the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path When --i-control-code` is set to False you can reexport things with as , because mypy might require it with implicit_reexport = False setting turned on. Configuration: This rule is configurable with --i-control-code and --i-dont-control-code` . Default: :str:`wemake_python_styleguide.options.defaults.I_CONTROL_CODE 0.1.0 0.13.0 0.14.0","title":"Found same alias import: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS114.html","text":"Forbid names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored number name pattern: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS115.html","text":"Require snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS116.html","text":"Forbid using more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS117.html","text":"Forbid naming variables self , cls , or mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS118.html","text":"Forbid long variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS119.html","text":"Forbid unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS120.html","text":"Forbid trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS121.html","text":"Forbid using variables that are marked as unused. We discourage using variables that start with _ only inside functions and methods as local variables. However, we allow to use _ because tools like ipython , babel , and django enforce it. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. This way it is declared to be used. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0 0.12.0 0.14.0","title":"Found usage of a variable marked as unused: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS122.html","text":"Forbid explicit unused variables. Reasoning While it is ok to define unused variables when you have to, like when unpacking a tuple, it is totally not ok to define explicit unusued variables in cases like assignment, function return, exception handling, or context managers. Why do you need this explicitly unused variables? Solution Remove all unused variables definition. Example # Correct: my_function() first, _second = some_tuple() print(first) # Wrong: _ = my_function() _first, _second = some_tuple() This rule checks: assigns, context managers, except clauses. 0.12.0","title":"Found all unused variables definition: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS123.html","text":"Forbid unused variables with multiple underscores. Reasoning We only use _ as a special definition for an unused variable. Other variables are hard to read. It is unclear why would one use it. Solution Rename unused variables to _ or give it some more context with an explicit name: _context . Example # Correct: some_element, _next_element, _ = some_tuple() some_element, _, _ = some_tuple() some_element, _ = some_tuple() # Wrong: some_element, _, __ = some_tuple() 0.12.0","title":"Found wrong unused variable name: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS124.html","text":"Forbid variable or module names which could be difficult to read. Reasoning Currently one can name your classes like so: ZerO0 Inside it is just O and 0 , but we cannot tell it from the word. There are a lot other combinations which are unreadable. Solution Rename your entity not to contain unreadable sequences. This rule checks: modules, variables, attributes, functions, methods, and classes. See UNREADABLE_CHARACTER_COMBINATIONS for full list of unreadable combinations. Example # Correct: ControlStatement AveragePrice # Wrong: Memo0Output 0.14","title":"Found unreadable characters combination: _"},{"location":"wemake-python-styleguide/0.15.0/violations/naming/WPS125.html","text":"Forbid variable or module names which shadow builtin names. Reasoning Your code simply breaks Python. After you create list = 1 , you cannot not call builtin function list and what can be worse than that? Solution Rename your entity to not shadow Python builtins. Example # Correct: my_list = list(some_other) # Wrong: str = '' list = [1, 2, 3] This can also cause problems when defining class attributes, for example: class A: min = 5 max = min ( 10 , 20 ) # TypeError: 'int' object is not callable If you feel it is still necessary to use such a class attribute, consider using a `noqa comment with caution. See BUILTINS_WHITELIST for full list of builtins we allow to shadow. 0.14 0.15","title":"Found builtin shadowing: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beautiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS600.html","text":"Forbid subclassing lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS601.html","text":"Forbid shadowing class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Also, if you ever want to optimise your code with a tool like `mypyc _, this rule is a requirement. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0 0.14.0","title":"Found shadowed class attribute: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS602.html","text":"Forbid @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0","title":"Found using @staticmethod"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS603.html","text":"Forbid certain magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS604.html","text":"Forbid incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS605.html","text":"Forbid methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so cannot access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS606.html","text":"Forbid anything other than a class as a base class. We only check base classes and not keywords. They can be anything you need. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Use annotation future import in case you use strings in base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0 0.12.0","title":"Found incorrect base class"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS607.html","text":"Forbid incorrect __slots__ definition. Things that this rule checks: That __slots__ is a tuple, name, attribute, star, or call That __slots__ do not have duplicates That __slots__ do not have empty strings or invalid python names Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Use snake_case to define attributes in __slots__ . Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = (* Test . __slots__ , 'child' ) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0 0.12.0","title":"Found incorrect __slots__ syntax"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS608.html","text":"Forbid super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS609.html","text":"Forbid direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS610.html","text":"Forbid certain async magic methods. We allow to make __anext__ , __aenter__ , __aexit__ async. We also allow custom magic methods to be async. See ASYNC_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted async magic methods. Reasoning Defining the magic methods as async which are not supposed to be async would not work as expected. Solution Do not make this magic method async. Example # Correct: class Test ( object ): def __lt__ ( self , other ): ... # Wrong: class Test ( object ): async def __lt__ ( self , other ): ... See also https://docs.python.org/3/reference/datamodel.html 0.12.0","title":"Found forbidden async magic method usage: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS611.html","text":"Forbid yield inside of certain magic methods. We allow to make __iter__ a generator. See YIELD_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted generator magic methods. Reasoning Python's datamodel is strict. You cannot make generators from random magic methods. This rule enforces it. Solution Remove yield from a magic method or rename it to be a custom method. Example # Correct: class Example(object): def __init__(self): ... # Wrong: class Example(object): def __init__(self): yield 10 See also https://docs.python.org/3/reference/datamodel.html 0.3.0 0.11.0 0.12.0","title":"Found forbidden yield magic method usage"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS612.html","text":"Forbid useless overwritten methods. Reasoning Overwriting method without any changes does not have any positive impact. Solution Do not overwrite method in case you do not want to do any changes inside it. Example # Correct: class Test ( Base ): def method ( self , argument ): super (). method ( argument ) return argument # or None, or anything! # Wrong: class Test ( object ): def method ( self , argument ): return super (). method ( argument ) 0.12.0","title":"Found useless overwritten method: _"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS613.html","text":"Forbid super() with incorrect method or property access. Reasoning Can only use super() method that matches the following context. super().some() and super().some in Child.some() , and super().prop and super().prop() in Child.prop Solution Use super() methods and properties with the correct context. Example # Correct: class Child ( Parent ): def some_method ( self ): original = super (). some_method () # Wrong: class Child ( Parent ): def some_method ( self ): other = super (). other_method () 0.13.0","title":"Found incorrect super() call context: incorrect name access"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS614.html","text":"Forbids descriptors in regular functions. Forbids using @staticmethod`, @classmethod and @property`` for functions not in class. Reasoning Descriptors like @staticmethod, @classmethod and @property do magic only as methods. We would want to warn users if the descriptors are used on regular functions. Solution Do not use @staticmethod, @classmethod and @property on regular functions or wrap the functions into a Class. Example # Correct : class TestClass ( object ) : @property def my_method () : ... # Wrong : @property def my_function () : ... 0.15.0","title":"Found descriptor applied on a function"},{"location":"wemake-python-styleguide/0.15.0/violations/oop/WPS615.html","text":"Forbids to use getters and setters in objects. Reasoning Python does not need this abstraction. Solution Either use @property or make the attribute public and change it directly. Example # Correct: class Example ( object ): def __init__ ( self ): self . _attribute = None # Wrong: class Example ( object ): def __init__ ( self ): self . attribute = None def set_attribute ( self ): ... def get_attribute ( self , value ): ... 0.15.0","title":"Found unpythonic getter or setter"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS500.html","text":"Forbid else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS501.html","text":"Forbid finally in try block without except block. However, we allow to use try with just finally block when function or method is decorated. Because we cannot control what is going on in this decorator. It might be @contextmanager or similar thing that requires this API. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0 0.14.0","title":"Found finally in try block without except"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS502.html","text":"Forbid simplifiable if conditions. Reasoning These complex constructions can cause frustration among other developers. They are longer, more verbose, and more complex. Solution Either use bool() to convert test values to boolean values, or just leave it as it is in case your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS503.html","text":"Forbid useless else cases in returning functions. We check single if statements that all contain return or raise or break statements with this rule. We do not check if statements with elif cases. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0","title":"Found useless returning else statement"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS504.html","text":"Forbid negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... if not some : ... elif other : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS505.html","text":"Forbid nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS506.html","text":"Forbid useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS507.html","text":"Forbid unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS508.html","text":"Forbid not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS509.html","text":"Forbid nesting ternary expressions in certain places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS510.html","text":"Forbid in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0 0.14.0","title":"Found in used with a non-set container"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS511.html","text":"Forbid multiple isinstance calls on the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS512.html","text":"Forbid multiple isinstance calls with single-item tuples. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single variable. Example # Correct: isinstance(some, (int, float)) isinstance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS513.html","text":"Forbid implicit elif conditions. Reasoning Nested if in else cases are bad for readability because of the nesting level. Solution Use elif on the same level. Example # Correct : if some : ... elif other : ... # Wrong : if some : ... else : if other : ... 0.12.0","title":"Found implicit elif condition"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS514.html","text":"Forbid multiple equality comparisons with the same variable. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0 0.12.0","title":"Found implicit in condition"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS515.html","text":"Forbid open() without a context manager. Reasoning When you open() something, you need to close it. When using a context manager - it is automatically done for you. When not using it - you might find yourself in a situation when file is not closed and is not accessible anymore. Solution Refactor open() call to use with . Example # Correct: with open(filename) as file_obj: ... # Wrong: file_obj = open(filename) 0.12.0","title":"Found open() used without a context manager"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS516.html","text":"Forbid comparing types with type() function. Reasoning When you compare types with type() function call it means that you break polymorphism and disallow child classes of a node to work here. That's incorrect. Solution Use isinstance to compare types. Example # Correct : print ( something , type ( something )) # Wrong : if type ( something ) == int : ... 0.12.0","title":"Found type() used to compare types"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS517.html","text":"Forbid useless starred expressions. Reasoning Using starred expression with constants is useless. This piece of code can be rewritten to be flat. Eg.: print(*[1, 2, 3]) is print(1, 2, 3) . Solution Refactor your code not to use starred expressions with list , dict , tuple , and set constants. Use regular argument passing instead. Example # Correct: my_list = [1, 2, 3, *other_iterable] # Wrong: print(*[1, 2, 3], ** {{}} ) 0.12.0","title":"Found pointless starred expression"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS518.html","text":"Forbid implicit enumerate() calls. Reasoning Using range(len(...)) is not pythonic. Python uses collection iterators, not index-based loops. Solution Use enumerate(...) instead of range(len(...)) . Example # Correct: for index , person in enumerate ( people ): ... # Wrong: for index in range ( len ( people )): ... See also https://docs.python.org/3/library/functions.html#enumerate 0.12.0","title":"Found implicit enumerate() call"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS519.html","text":"Forbid implicit sum() calls. When summing types different from numbers, you might need to provide the second argument to the sum function: sum([[1], [2], [3]], []) You might also use str.join to join iterable of strings. Reasoning Using for loops with += assign inside indicates that you iteratively sum things inside your collection. That's what sum() builtin function does. Solution Use sum(...) instead of a loop with += operation. Example # Correct : sum_result = sum ( get_elements ()) # Wrong : sum_result = 0 for to_sum in get_elements () : sum_result += to_sum See also https://docs.python.org/3/library/functions.html#sum https://docs.python.org/3/library/stdtypes.html#str.join 0.12.0","title":"Found implicit sum() call"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS520.html","text":"Forbid comparing with explicit falsy constants. We allow to compare with falsy numbers, strings, booleans, None . We disallow complex constants like tuple, dicts, and lists. Reasoning When comparing something with explicit falsy constants what we really mean is not something . Solution Use not with your variable. Fix your data types. Example # Correct : if not my_check : ... if some_other is None : ... if some_num == 0 : ... # Wrong : if my_check == []: ... 0.12.0","title":"Found compare with falsy constant"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS521.html","text":"Forbid comparing values with constants using is or is not . However, we allow to compare with None and booleans. Reasoning is compares might not do what you want them to do. Firstly, they check for the same object, not equality. Secondly, they behave unexpectedly even with the simple values like 257 . Solution Use == to compare with constants. Example # Correct : if my_check == [ 1 , 2 , 3 ]: ... # Wrong : if my_check is [ 1 , 2 , 3 ]: ... See also https://stackoverflow.com/a/33130014/4842742 0.12.0","title":"Found wrong is compare"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS522.html","text":"Forbid implicit primitives in the form of lambda functions. Reasoning When you use lambda that returns a primitive value and takes no arguments, it means that you should use a primitive type instead. Solution Replace lambda with int , float , list , or any other primitive. Example # Correct: defaultdict(int) # Wrong: defaultdict(lambda: 0) 0.13.0","title":"Found implicit primitive in a form of lambda"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS523.html","text":"Forbid unpythonic variable swaps. We check for a = b; b = a sequences. Reasoning This looks like a failed attempt to swap. Solution Use standard way to swap two variables. Example # Correct: a, b = b, a # Wrong: a = b b = a temp = a a = b b = temp 0.13.0","title":"Found incorrectly swapped variables"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS524.html","text":"Forbid misrefactored self assignment. Reasoning Self assignment does not need to have the same operand on the left hand side and on the right hand side. Solution Refactor you code to use multiple self assignments or fix your code. Example # Correct: test += 1 test *= 2 # Wrong: test += test + 1 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. 0.13.0","title":"Found self assignment  with refactored assignment"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS525.html","text":"Forbid comparisons where in is compared with single item container. Reasoning in comparison with a container which contains only one item looks like overhead and unneeded complexity. Solution Refactor your code to use == instead in . Example # Correct: a == 's' # Wrong: a in {'s'} 0.13.0","title":"Found wrong in compare with single item container"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS526.html","text":"Forbid yield inside for loop instead of yield from . Reasoning It is known that yield from is a semantically identical to a for loop with a yield inside. But, it is way more readable. Solution Use yield from some iterable directly instead iterating over it inside a loop and yield it one by one. Example # Correct : yield from some () yield from ( value [ index : index + chunk_size ] for index in range ( 0 , len ( value ) , chunk_size ) ) # Wrong : for index in chunk : yield index 0.13.0","title":"Found implicit yield from usage"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS527.html","text":"Require tuples as arguments for certain functions. Reasoning For some functions, it is better to use tuples instead of another iterable types (list, sets,...) as arguments. Solution Use tuples as arguments. Example # Correct: a = frozenset((2,)) # Wrong: a = frozenset([2]) See TUPLE_ARGUMENTS_METHODS for full list of methods that we check for. 0.13.0","title":"Found not a tuple used as an argument"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS528.html","text":"Forbid implicit .items() iterator. Reasoning When iterating over collection it is easy to forget to use .items() when you need to access both keys and values. So, when you access the iterable with the key inside a for loop, that's a sign to refactor your code. Solution Use .items() with direct keys and values when you need them. Example # Correct : for some_key , some_value in collection . items () : print ( some_key , some_value ) # Wrong : for some_key in collection : print ( some_key , collection [ some_key ] ) 0.13.0","title":"Found implicit .items() usage"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS529.html","text":"Forbid implicit .get() dict method. Reasoning When using in with a dict key it is hard to keep the code clean. It is more convenient to use .get() and check for None later. Solution Use .get() with the key you need. Check for None in case you need it, or just act with the default value of the same type. Example # Correct : value = collection . get ( key ) if value is not None : print ( value ) # Wrong : if key in collection : print ( collection [ key ] ) 0.13.0","title":"Found implicit .get() dict usage"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS530.html","text":"Forbid implicit negative indexes. Reasoning There's no need in getting the length of an iterable and then having a negative offset, when you can specify negative indexes in the first place. Solution Use negative indexes. Example # Correct: some_list[-1] # Wrong: some_list[len(some_list) - 1] 0.13.0","title":"Found implicit negative index"},{"location":"wemake-python-styleguide/0.15.0/violations/refactoring/WPS531.html","text":"Forbid if statements that simply return booleans in functions or methods. Reasoning There is no need to test a condition and simply return a boolean depending on its outcome if there is not going to be any additional code. Solution Instead of testing the condition and returning a boolean, return the condition itself. This applies to early returning ifs too. Example # Correct : def some_function () : return some_condition # Wrong : def some_function () : if some_condition : return True else : return False 0.15.0","title":"Found simplifiable returning if condition in a function"},{"location":"wemake-python-styleguide/0.15.0/violations/system/index.html","text":"These checks ensures that our internal checks passes. For example, we can report violations from this group when some exception occur during the linting process or some dependencies are missing.","title":"WPS0xx System"},{"location":"wemake-python-styleguide/0.15.0/violations/system/WPS000.html","text":"Happens when we get unhandled exception during the linting process. All this violations should be reported to the main issue tracker. We ideally should not produce these violations at all. See also https://github.com/wemake-services/wemake-python-styleguide/issues 0.13.0","title":"Internal error happened, see log. Please, take some time to report it"},{"location":"wemake-python-styleguide/0.15.3/index.html","text":"","title":"0.15.3"},{"location":"wemake-python-styleguide/0.15.3/configuration/ALLOWED_DOMAIN_NAMES.html","text":"Domain names that are removed from variable names' blacklist.","title":"ALLOWED_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.15.3/configuration/FORBIDDEN_DOMAIN_NAMES.html","text":"Domain names that extends variable names' blacklist.","title":"FORBIDDEN_DOMAIN_NAMES"},{"location":"wemake-python-styleguide/0.15.3/configuration/FORBIDDEN_INLINE_IGNORE.html","text":"Violation codes that are forbidden to use.","title":"FORBIDDEN_INLINE_IGNORE"},{"location":"wemake-python-styleguide/0.15.3/configuration/I_CONTROL_CODE.html","text":"Whether you control ones who use your code.","title":"I_CONTROL_CODE"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_ACCESS_LEVEL.html","text":"Maximum number of access level in an expression.","title":"MAX_ACCESS_LEVEL"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_ANN_COMPLEXITY.html","text":"Maximum number of nested annotations.","title":"MAX_ANN_COMPLEXITY"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_ARGUMENTS.html","text":"Maximum number of arguments for functions or methods.","title":"MAX_ARGUMENTS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_ASSERTS.html","text":"Maximum number of assert statements in a function.","title":"MAX_ASSERTS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_ATTRIBUTES.html","text":"Maximum number of public attributes in a single class.","title":"MAX_ATTRIBUTES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_AWAITS.html","text":"Maximum number of await expressions for functions or methods.","title":"MAX_AWAITS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_BASE_CLASSES.html","text":"Maximum number of base classes.","title":"MAX_BASE_CLASSES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_CALL_LEVEL.html","text":"Maximum number of call chains.","title":"MAX_CALL_LEVEL"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_COGNITIVE_AVERAGE.html","text":"Maximum amount of average cognitive complexity per module.","title":"MAX_COGNITIVE_AVERAGE"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_COGNITIVE_SCORE.html","text":"Maximum amount of cognitive complexity per function.","title":"MAX_COGNITIVE_SCORE"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_DECORATORS.html","text":"Maximum number of decorators.","title":"MAX_DECORATORS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_EXPRESSIONS.html","text":"Maximum number of expressions in a single function.","title":"MAX_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_FUNCTION_EXPRESSIONS.html","text":"Maximum amount of same expressions per function.","title":"MAX_FUNCTION_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_IMPORTED_NAMES.html","text":"Maximum number of imported names in a single module.","title":"MAX_IMPORTED_NAMES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_IMPORTS.html","text":"Maximum number of imports in a single module.","title":"MAX_IMPORTS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_IMPORT_FROM_MEMBERS.html","text":"Maximum number of names that can be imported from module.","title":"MAX_IMPORT_FROM_MEMBERS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_JONES_SCORE.html","text":"Maximum median module Jones complexity.","title":"MAX_JONES_SCORE"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_LINE_COMPLEXITY.html","text":"Maximum line complexity.","title":"MAX_LINE_COMPLEXITY"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_LOCAL_VARIABLES.html","text":"Maximum number of local variables in a function.","title":"MAX_LOCAL_VARIABLES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_METHODS.html","text":"Maximum number of methods in a single class.","title":"MAX_METHODS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_MODULE_EXPRESSIONS.html","text":"Maximum amount of same expressions per module.","title":"MAX_MODULE_EXPRESSIONS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_MODULE_MEMBERS.html","text":"Maximum number of classes and functions in a single module.","title":"MAX_MODULE_MEMBERS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_NAME_LENGTH.html","text":"Maximum variable and module name length:","title":"MAX_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_NOQA_COMMENTS.html","text":"Maximum amount of noqa comments per module.","title":"MAX_NOQA_COMMENTS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_RAISES.html","text":"Maximum number of raises in a function.","title":"MAX_RAISES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_RETURNS.html","text":"Maximum number of return statements allowed in a single function.","title":"MAX_RETURNS"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_STRING_USAGES.html","text":"Maximum number of same string usage in code.","title":"MAX_STRING_USAGES"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_TRY_BODY_LENGTH.html","text":"Maximum amount of try node body length.","title":"MAX_TRY_BODY_LENGTH"},{"location":"wemake-python-styleguide/0.15.3/configuration/MAX_TUPLE_UNPACK_LENGTH.html","text":"Maximum number of variables in a tuple unpacking statement.","title":"MAX_TUPLE_UNPACK_LENGTH"},{"location":"wemake-python-styleguide/0.15.3/configuration/MIN_NAME_LENGTH.html","text":"Minimum variable's name length.","title":"MIN_NAME_LENGTH"},{"location":"wemake-python-styleguide/0.15.3/configuration/NESTED_CLASSES_WHITELIST.html","text":"List of nested classes' names we allow to use.","title":"NESTED_CLASSES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/ALIAS_NAMES_WHITELIST.html","text":"List of commonly used aliases","title":"ALIAS_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/ALLOWED_BUILTIN_CLASSES.html","text":"List of builtin classes that are allowed to subclass.","title":"ALLOWED_BUILTIN_CLASSES"},{"location":"wemake-python-styleguide/0.15.3/constants/ALLOWED_NESTED_IMPORTS_CONDITIONS.html","text":"Conditions that can appear in the if statement to allow nested imports.","title":"ALLOWED_NESTED_IMPORTS_CONDITIONS"},{"location":"wemake-python-styleguide/0.15.3/constants/ALL_MAGIC_METHODS.html","text":"List of all magic methods from the python docs.","title":"ALL_MAGIC_METHODS"},{"location":"wemake-python-styleguide/0.15.3/constants/ASYNC_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be async.","title":"ASYNC_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/BUILTINS_WHITELIST.html","text":"List of builtins that we allow to shadow.","title":"BUILTINS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/FUNCTIONS_BLACKLIST.html","text":"List of functions we forbid to use.","title":"FUNCTIONS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/FUTURE_IMPORTS_WHITELIST.html","text":"List of allowed __future__ imports.","title":"FUTURE_IMPORTS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/LITERALS_BLACKLIST.html","text":"List of literals without arguments we forbid to use.","title":"LITERALS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are forbidden to use.","title":"MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MAGIC_MODULE_NAMES_BLACKLIST.html","text":"List of bad magic module functions.","title":"MAGIC_MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MAGIC_MODULE_NAMES_WHITELIST.html","text":"List of allowed module magic names.","title":"MAGIC_MODULE_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MAGIC_NUMBERS_WHITELIST.html","text":"Common numbers that are allowed to be used without being called \"magic\".","title":"MAGIC_NUMBERS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MATH_APPROXIMATE_CONSTANTS.html","text":"Approximate constants which real values should be imported from math module.","title":"MATH_APPROXIMATE_CONSTANTS"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_COMPARES.html","text":"Maximum number of compare nodes in a single expression.","title":"MAX_COMPARES"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_CONDITIONS.html","text":"Maximum number of conditions in a single if or while statement.","title":"MAX_CONDITIONS"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_ELIFS.html","text":"Maximum number of elif blocks in a single if condition:","title":"MAX_ELIFS"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_EXCEPT_CASES.html","text":"Maximum number of except cases in a single try clause.","title":"MAX_EXCEPT_CASES"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_LEN_YIELD_TUPLE.html","text":"Maximum length of yield tuple expressions.","title":"MAX_LEN_YIELD_TUPLE"},{"location":"wemake-python-styleguide/0.15.3/constants/MAX_NO_COVER_COMMENTS.html","text":"Maximum amount of pragma no-cover comments per module.","title":"MAX_NO_COVER_COMMENTS"},{"location":"wemake-python-styleguide/0.15.3/constants/MODULE_METADATA_VARIABLES_BLACKLIST.html","text":"List of module metadata we forbid to use.","title":"MODULE_METADATA_VARIABLES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MODULE_NAMES_BLACKLIST.html","text":"List of blacklisted module names.","title":"MODULE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/MODULE_NAME_PATTERN.html","text":"Regex pattern to name modules.","title":"MODULE_NAME_PATTERN"},{"location":"wemake-python-styleguide/0.15.3/constants/NESTED_FUNCTIONS_WHITELIST.html","text":"List of nested functions' names we allow to use.","title":"NESTED_FUNCTIONS_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/SPECIAL_ARGUMENT_NAMES_WHITELIST.html","text":"List of special names that are used only as first argument in methods.","title":"SPECIAL_ARGUMENT_NAMES_WHITELIST"},{"location":"wemake-python-styleguide/0.15.3/constants/TUPLE_ARGUMENTS_METHODS.html","text":"List of functions in which arguments must be tuples.","title":"TUPLE_ARGUMENTS_METHODS"},{"location":"wemake-python-styleguide/0.15.3/constants/UNREADABLE_CHARACTER_COMBINATIONS.html","text":"List of character sequences that are hard to read.","title":"UNREADABLE_CHARACTER_COMBINATIONS"},{"location":"wemake-python-styleguide/0.15.3/constants/VAGUE_IMPORTS_BLACKLIST.html","text":"List of vague method names that may cause confusion if imported as is:","title":"VAGUE_IMPORTS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/VARIABLE_NAMES_BLACKLIST.html","text":"List of variable names we forbid to use.","title":"VARIABLE_NAMES_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/constants/YIELD_MAGIC_METHODS_BLACKLIST.html","text":"List of magic methods that are not allowed to be generators.","title":"YIELD_MAGIC_METHODS_BLACKLIST"},{"location":"wemake-python-styleguide/0.15.3/violations/best_practices/index.html","text":"These checks ensure that you follow the best practices. The source for these best practices is countless hours we have spent debugging software or reviewing it. How do we find inspiration for new rules? We find some ugly code during code reviews and audits, then we forbid the use of code like it forever.","title":"WPS4xx Best Practices"},{"location":"WPS400/","text":"Restrict various control (such as magic) comments. We do not allow: # noqa comment without specified violations # type: some_type comments to specify a type for typed_ast This violation is reported at the top of the module, so it cannot be locally ignored. Reasoning We cover several use-cases in a single rule. # noqa comment is restricted because it can hide other violations. # type: some_type comment is restricted because we can use type annotations instead. Solution Use # noqa comments with specified error types. Use type annotations to specify types. We still allow using # type: ignore comment, since sometimes it is required. Example # Correct : type = MyClass . get_type () # noqa : WPS125 coordinate : int = 10 some . int_field = ' text ' # type : ignore number : int for number in some_untyped_iterable () : ... # Wrong : type = MyClass . get_type () # noqa coordinate = 10 # type : int 0.1.0","title":"Found wrong magic comment: _"},{"location":"WPS401/","text":"Forbid empty doc comments ( #: ). Reasoning Doc comments are used to provide documentation but supplying empty doc comments breaks this use-case. It is unclear why they can be used with no contents. Solution Add some documentation to this comment or remove it. Empty doc comments are not caught by the default pycodestyle checks. Example # Correct: #: List of allowed names: NAMES_WHITELIST = ['feature', 'bug', 'research'] # Wrong: #: NAMES_WHITELIST = ['feature', 'bug', 'research'] 0.1.0","title":"Found wrong doc comment"},{"location":"WPS402/","text":"Forbid too many # noqa comments. We count them on a per-module basis. Reasoning Having too many # noqa comments makes your code less readable and indicates that there's something wrong with it. Solution Refactor your code to match our style. Or use a config file to switch off some checks. Configuration This rule is configurable with --max-noqa-comments . Default: MAX_NOQA_COMMENTS 0.7.0","title":"Found noqa comments overuse: _"},{"location":"WPS403/","text":"Forbid too many # pragma: no cover comments. We count them on a per-module basis. We use MAX_NO_COVER_COMMENTS as a default value. Reasoning Having too many # pragma: no cover comments indicates that there's something wrong with the code. Moreover, it makes your tests useless, since they do not cover a big portion of your code. Solution Refactor your code to match the style. Or use a config file to switch off some checks. 0.8.0","title":"Found noqa comments overuse: _"},{"location":"WPS404/","text":"Forbid complex defaults. Anything that is not a ast.Name , ast.Attribute , ast.Str , ast.NameConstant , ast.Tuple , ast.Bytes , ast.Num or ast.Ellipsis should be moved out from defaults. Reasoning It can be tricky. Nothing stops you from making database calls or HTTP requests in such expressions. It is also not readable for us. Solution Move the expression out from default value. Example # Correct: SHOULD_USE_DOCTEST = 'PYFLAKES_DOCTEST' in os.environ def __init__(self, with_doctest=SHOULD_USE_DOCTEST): # Wrong: def __init__(self, with_doctest='PYFLAKES_DOCTEST' in os.environ): 0.8.0 0.11.0","title":"Found complex default value"},{"location":"WPS405/","text":"Forbid anything other than ast.Name to define loop variables. Reasoning When defining a for loop with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct : for person in database . people () : ... # Wrong : for context [ ' person ' ] in database . people () : ... 0.8.0 0.11.0","title":"Found wrong for loop variable definition"},{"location":"WPS406/","text":"Forbid anything other than ast.Name to define contexts. Reasoning When defining a with context managers with attributes, indexes, calls, or any other nodes it does dirty things inside. Solution Use regular ast.Name variables. Or tuple of ast.Name variables. Star names are also fine. Example # Correct: with open('README.md') as readme: ... # Wrong: with open('README.md') as files['readme']: ... 0.8.0 0.11.0","title":"Found wrong context manager variable definition"},{"location":"WPS407/","text":"Forbid mutable constants on a module level. Reasoning Constants should be immutable. Solution Use immutable types for constants. We only treat ast.Set , ast.Dict , ast.List and comprehensions as mutable things. All other nodes are still fine. Example # Correct: import types CONST1 = frozenset (( 1 , 2 , 3 )) CONST2 = ( 1 , 2 , 3 ) CONST3 = types . MappingProxyType ({ 'key' : 'value' }) # Wrong: CONST1 = { 1 , 2 , 3 } CONST2 = [ x for x in some ()] CONST3 = { 'key' : 'value' } 0.10.0 0.11.0","title":"Found mutable module constant"},{"location":"WPS408/","text":"Forbid using the same logical conditions in one expression. Reasoning Using the same name in a logical condition more than once indicates that you are either making a logical mistake, or just over-complicating your design. Solution Remove the duplicated condition. Example # Correct : if some_value or other_value : ... # Wrong : if some_value or some_value : ... 0.10.0 0.11.0 0.13.0","title":"Found duplicate logical condition"},{"location":"WPS409/","text":"Forbid heterogeneous operators in one comparison. Note, that we do allow mixing > with >= and < with <= operators. Reasoning This is hard to read and understand. Solution Refactor the expression to have separate parts joined with and boolean operator. Example # Correct : if x == y == z : ... if x > y >= z : ... # Wrong : if x > y == 5 : ... if x == y != z : ... 0.10.0 0.11.0","title":"Found heterogeneous compare"},{"location":"WPS410/","text":"Forbid some module-level variables. Reasoning We discourage using module variables like __author__ , because code should not contain any metadata. Solution Place all the metadata in setup.py , setup.cfg , or pyproject.toml . Use proper docstrings and packaging classifiers. Use importlib.metadata (or importlib_metadata on python \\< 3.8) if you need to import this data into your app. See MODULE_METADATA_VARIABLES_BLACKLIST for full list of bad names. Example # Wrong: __author__ = 'Nikita Sobolev' __version__ = 0.1.2 0.1.0","title":"Found wrong metadata variable: _"},{"location":"WPS411/","text":"Forbid empty modules. Reasoning Why is it even there? Do not pollute your project with empty files. Solution If you have an empty module there are two ways to handle that: delete it drop some documentation in it, so you will explain why it is there 0.1.0","title":"Found empty module"},{"location":"WPS412/","text":"Forbid logic inside __init__ module. Reasoning If you have logic inside the __init__ module It means several things: you are keeping some outdated stuff there, you need to refactor you are placing this logic in the wrong file, just create another one you are doing some dark magic, and you should not do that Solution Put your code in other modules. However, we allow some contents inside the __init__ module: comments, since they are dropped before AST comes in play docstrings are used sometimes when required to state something It is also fine when you have different users that use your code. And you do not want to break everything for them. In this case, this rule can be configured. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE When using --i-dont-control-code it is still recommended to only have imports in your __init__.py . 0.1.0","title":"Found __init__.py module with logic"},{"location":"WPS413/","text":"Forbid __getattr__ and __dir__ module magic methods. Reasoning It does not bring any features, only making it harder to understand what is going on. Solution Refactor your code to use custom methods instead. Configuration This rule is configurable with --i-control-code and --i-dont-control-code . Default: I_CONTROL_CODE 0.9.0","title":"Found bad magic module function: _"},{"location":"WPS414/","text":"Forbid tuple unpacking with side-effects. Reasoning Having unpacking with side-effects is very dirty. You might get in serious and very hard-to-debug troubles because of this technique so do not use it. This includes assigning to attributes, as this results in modifying the instance. Every modification should be explicit on it's own line. Solution Use unpacking only with variables, not any other entities. Example # Correct: reader, writter = call() self.reader = reader self.writer = writer # Wrong: first, some_dict['alias'] = some() self.reader, self.writer = call() 0.6.0 0.11.0","title":"Found incorrect unpacking target"},{"location":"WPS415/","text":"Forbid the same exception class in multiple except blocks. Reasoning Having the same exception name in different blocks means that something is not right: since only one branch will work. Another one will always be ignored. So, that is an error. Solution Use unique exception handling rules. Example # Correct: try: ... except ValueError: ... # Wrong: try: ... except ValueError: ... except ValueError: ... 0.6.0 0.11.0","title":"Found duplicate exception: _"},{"location":"WPS416/","text":"Forbid yield keyword inside comprehensions. This is a SyntaxError starting from python3.8 . Reasoning Having the yield keyword inside comprehensions is error-prone. You can shoot yourself in the foot by an inaccurate usage of this feature. Solution Use regular for loops with yield keywords or create a separate generator function. Example # Wrong : list (( yield letter ) for letter in ' ab ' ) # Will resilt in : [ ' a ' , None , ' b ' , None ] list ( [ ( yield letter ) for letter in ' ab ' ] ) # Will result in : [ ' a ' , ' b ' ] See also https://github.com/satwikkansal/wtfPython#-yielding-none 0.7.0 0.11.0","title":"Found yield inside comprehension"},{"location":"WPS417/","text":"Forbid duplicate items in hashes. Reasoning When you explicitly put duplicate items in set literals or in dict keys it just does not make any sense since hashes cannot contain duplicate items and they will be removed anyway. Solution Remove duplicate items. Example # Correct: some_set = { 'a' , variable1 } some_set = { make_call (), make_call ()} # Wrong: some_set = { 'a' , 'a' , variable1 , variable1 } Things that we consider duplicates: builtins and variables. These nodes are not checked because they may return different results: function and method calls comprehensions attributes subscribe operations 0.7.0 0.11.0 0.12.0","title":"Found non-unique item in hash: _"},{"location":"WPS418/","text":"Forbid exceptions inherited from BaseException . Reasoning BaseException is a special case: it is not designed to be extended by users. A lot of your except Exception cases won't work. That's incorrect and dangerous. Solution Change the base class to Exception . Example # Correct: class MyException ( Exception ): ... # Wrong: class MyException ( BaseException ): ... See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy 0.7.0 0.11.0","title":"Found exception inherited from BaseException"},{"location":"WPS419/","text":"Forbid multiple returning paths with try / except case. Note, that we check for any return , break , or raise nodes. Reasoning The problem with return in else and finally is that it is impossible to say what value is going to be returned without looking up the implementation details. Why? Because return does not expect that some other code will be executed after it. But, finally is always executed, even after return . And else will not be executed when there are no exceptions in try case and a return statement. Solution Remove return from one of the cases. Example # Correct : try : return 1 except YourException : ... finally : clear_things_up () # Wrong : try : return 1 # this line will never return except Exception : ... finally : return 2 # this line will actually return try : return 1 # this line will actually return except ZeroDivisionError : ... else : return 0 # this line will never return 0.7.0 0.11.0 0.12.0","title":"Found try/else/finally with multiple return paths"},{"location":"WPS420/","text":"Forbid some python keywords. Reasoning Using some keywords generally causes more pain than it relieves. del keyword is not composable with other functions, you cannot pass it as a regular function. It is also quite error-prone due to __del__ magic method complexity and that del is actually used to nullify variables and delete them from the execution scope. Moreover, it has a lot of substitutions. You won't miss it! pass keyword is just useless by design. There's no use-case for it. Because it does literally nothing. global and nonlocal promote bad-practices of having an external mutable state somewhere. This solution does not scale and leads to multiple possible mistakes in the future. Solution Solutions differ from keyword to keyword. pass should be replaced with docstring or contextlib.suppress . del should be replaced with specialized methods like .pop() . global and nonlocal usages should be refactored. 0.1.0","title":"Found wrong keyword: _"},{"location":"WPS421/","text":"Forbid calling some built-in functions. Reasoning Some functions are only suitable for very specific use cases, we forbid the use of them in a free manner. See FUNCTIONS_BLACKLIST for the full list of blacklisted functions. See also https://www.youtube.com/watch?v=YjHsOrOOSuI 0.1.0","title":"Found wrong function call: _"},{"location":"WPS422/","text":"Forbid __future__ imports. Reasoning Almost all __future__ imports are legacy python2 compatibility tools that are no longer required. Solution Remove them. Drop python2 support. Except, there are some new ones for python4 support. See FUTURE_IMPORTS_WHITELIST for the full list of allowed future imports. Example # Correct: from __future__ import annotations # Wrong: from __future__ import print_function 0.1.0","title":"Found future import: _"},{"location":"WPS423/","text":"Forbid NotImplemented exception. Reasoning NotImplemented and NotImplementedError look similar but they have different use cases. Use cases of NotImplemented are too limited to be generally available. Solution Use NotImplementedError . Example # Correct: raise NotImplementedError('To be done') # Wrong: raise NotImplemented 0.1.0 See also https://stackoverflow.com/a/44575926/4842742","title":"Found raise NotImplemented"},{"location":"WPS424/","text":"Forbid BaseException exception. Reasoning We can silence system exit and keyboard interrupt with this exception handler. It is almost the same as raw except: block. Solution Handle Exception , KeyboardInterrupt , GeneratorExit , and SystemExit separately. Do not use the plain except: keyword. Example # Correct: except Exception as ex: ... # Wrong: except BaseException as ex: ... 0.3.0 See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://help.semmle.com/wiki/pages/viewpage.action?pageId=1608527","title":"Found except BaseException"},{"location":"WPS425/","text":"Forbid booleans as non-keyword parameters. Reasoning Passing booleans as regular positional parameters is very non-descriptive. It is almost impossible to tell what this parameter means and you almost always have to look up the implementation to tell what is going on. The only exception from this rule is passing a boolean as a non-keyword argument when it is the only passed argument. Solution Pass booleans as keywords only. This will help you to save extra context on what's going on. Example # Correct: UserRepository.update(True) UsersRepository.add(user, cache=True) # Wrong: UsersRepository.add(user, True) 0.6.0","title":"Found boolean non-keyword argument: _"},{"location":"WPS426/","text":"Forbid lambda inside loops. We check while , for , and async for loop bodies. We also check comprehension value parts. Reasoning It is error-prone to use lambda inside for and while loops due to the famous late-binding. Solution Use regular functions, factory functions, or partial functions. Save yourself from possible confusion. Example # Correct : for index in range ( 10 ) : some . append ( partial_function ( index )) # Wrong : for index in range ( 10 ) : some . append ( lambda index = index : index * 10 )) other . append ( lambda : index * 10 )) 0.5.0 0.11.0 0.14.0 See also https://docs.python-guide.org/writing/gotchas/#late-binding-closures","title":"Found lambda in loop's body"},{"location":"WPS427/","text":"Forbid unreachable code. What is unreachable code? It is some lines of code that cannot be executed by python's interpreter. This is probably caused by return or raise statements. However, we cannot cover 100% of truly unreachable code by this rule. This happens due to the dynamic nature of python. For example, detecting that 1 / some_value would sometimes raise an exception is too complicated and is out of the scope of this rule. Reasoning Having dead code in your project is an indicator that you do not care about your codebase at all. It dramatically reduces code quality and readability. It also demotivates team members. Solution Delete any unreachable code you have or refactor it, if this happens by your mistake. Example # Correct : def some_function () : print ( ' This line is reachable, all good ' ) return 5 # Wrong : def some_function () : return 5 print ( ' This line is unreachable ' ) 0.5.0 0.11.0","title":"Found unreachable code"},{"location":"WPS428/","text":"Forbid statements that do nothing. Reasoning Statements that just access the value or expressions used as statements indicate that your code contains deadlines. They just pollute your codebase and do nothing. Solution Refactor your code in case it was a typo or error or just delete this code. Example # Correct : def some_function () : price = 8 + 2 return price # Wrong : def some_function () : 8 + 2 print 0.5.0 0.11.0","title":"Found statement that has no effect"},{"location":"WPS429/","text":"Forbid multiple assignments on the same line. Reasoning Multiple assignments on the same line might not do what you think they do. They can also grow pretty long and you might not notice the rising complexity of your code. Solution Use separate lines for each assignment. Example # Correct: a = 1 b = 1 # Wrong: a = b = 1 0.6.0 0.11.0","title":"Found multiple assign targets"},{"location":"WPS430/","text":"Forbid nested functions. Reasoning Nesting functions is bad practice. It is hard to test them and it is hard to separate them later. People tend to overuse closures, so it's hard to manage the dataflow. Solution Just write flat functions, there's no need to nest them. Pass parameters as normal arguments, do not use closures until you need them for decorators or factories. We also forbid nesting lambda and async functions. See NESTED_FUNCTIONS_WHITELIST for the whole list of whitelisted names. Example # Correct: def do_some(): ... def other(): ... # Wrong: def do_some(): def inner(): ... 0.1.0","title":"Found nested function: _"},{"location":"WPS431/","text":"Forbid nested classes. Reasoning Nested classes are really hard to manage. You cannot even create an instance of this class in many cases. Testing them is also really hard. Solution Just write flat classes, there's no need to nest them. If you are nesting classes inside a function for parametrization, then you will probably need to use a different design (or metaclasses). Configuration This rule is configurable with --nested-classes-whitelist . Default: NESTED_CLASSES_WHITELIST Example # Correct: class Some ( object ): ... class Other ( object ): ... # Wrong: class Some ( object ): class Inner ( object ): ... 0.1.0 0.13.0","title":"Found nested class: _"},{"location":"WPS432/","text":"Forbid magic numbers. What do we call a \"magic number\"? Well, it is actually any number that appears in your code out of nowhere. Like 42 . Or 0.32 . Reasoning It is very hard to remember what these numbers mean. Why were they used? Should they ever be changed? Or are they eternal like 3.14 ? Solution Give these numbers a name! Move them to a separate variable, giving more context to the reader. And by moving things into new variables you will trigger other complexity checks. Example # Correct: price_in_euro = 3.33 # could be changed later total = get_items_from_cart() * price_in_euro # Wrong: total = get_items_from_cart() * 3.33 What are the numbers that we exclude from this check? Any numbers that are assigned to a variable, array, dictionary, or keyword arguments inside a function. int numbers that are in range [-10, 10] and some other common numbers, that are defined in MAGIC_NUMBERS_WHITELIST 0.1.0 See also https://en.wikipedia.org/wiki/Magic_number_(programming)","title":"Found magic number: _"},{"location":"WPS433/","text":"Forbid imports nested in functions. Reasoning Usually, nested imports are used to fix the import cycle. So, nested imports show that there's an issue with your design. Solution You don't need nested imports, you need to refactor your code. Introduce a new module or find another way to do what you want to do. Rethink how your layered architecture should look. Example # Correct: from my_module import some_function def some (): ... # Wrong: def some (): from my_module import some_function 0.1.0 0.11.0 See also https://github.com/seddonym/layer_linter","title":"Found nested import"},{"location":"WPS434/","text":"Forbid assigning a variable to itself. Reasoning There is no need to do that. Generally, it is an indication of some errors or just dead code. Example # Correct: some = some + 1 x_coord, y_coord = y_coord, x_coord # Wrong: some = some x_coord, y_coord = x_coord, y_coord 0.3.0 0.11.0","title":"Found reassigning variable to itself: _"},{"location":"WPS435/","text":"Forbid multiplying lists. Reasoning When you multiply lists - it does not create new values, it creates references to the existing value. It is not what people mean in 99.9% of cases. Solution Use list comprehension or loop instead. Example # Wrong: my_list = [1, 2, 3] * 3 See also https://github.com/satwikkansal/wtfPython#-explanation-8 0.12.0","title":"Found list multiply"},{"location":"WPS436/","text":"Forbid importing protected modules. Related to WPS450 Found protected object import: _ . Reasoning When importing protected modules we break a contract that authors of this module enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not import protected modules. Respect the encapsulation. Example # Correct: import public_module from some.public.module import FooClass # Wrong: import _compat from some._protected.module import BarClass 0.3.0 0.11.0 0.14.0","title":"Found protected module import: _"},{"location":"WPS437/","text":"Forbid protected attributes and methods. Reasoning When using protected attributes and method we break a contract that authors of this class enforce. This way we are not respecting encapsulation and it may break our code at any moment. Solution Do not use protected attributes and methods. Respect the encapsulation. Example # Correct: self._protected = 1 cls._hidden_method() some.public() super()._protected() # Wrong: print(some._protected) instance._hidden() self.container._internal = 10 Note, that it is possible to use protected attributes with self , cls , and super() as base names. We allow this so you can create and use protected attributes and methods inside the class context. This is how protected attributes should be used. 0.3.0 0.11.0","title":"Found protected attribute usage: _"},{"location":"WPS438/","text":"Forbid raising StopIteration inside generators. Reasoning StopIteration should not be raised explicitly in generators. Solution Use a return statement to get out of a generator. Example # Correct : def some_generator () : if some_value : return yield 1 # Wrong : def some_generator () : if some_value : raise StopIteration yield 1 See also https://docs.python.org/3/library/exceptions.html#StopIteration 0.12.0","title":"Found StopIteration raising inside generator"},{"location":"WPS439/","text":"Forbid Unicode escape sequences in binary strings. Reasoning Binary strings do not work with Unicode. Having Unicode escape characters in there means that you have an error in your code. Solution Use regular strings when escaping Unicode strings. Example # Correct: escaped = '\\u0041' # equals to 'A' # Wrong: escaped = b'\\u0040' # equals to b'\\\\u0040' 0.12.0","title":"Found unicode escape in a binary string: _"},{"location":"WPS440/","text":"Forbid overlapping local and block variables. What we call local variables: Assigns and annotations Function arguments (they are local to the function body) What we call block variables: Imports Functions and async functions definitions Classes, methods, and async methods definitions For and async for loops variables Except for block exception aliases We allow local variables to overlap themselves, we forbid block variables to overlap themselves. Example # Correct: my_value = 1 my_value = my_value + 1 # Wrong: import my_value my_value = 1 # overlaps with import See also https://github.com/satwikkansal/wtfPython#-explanation-20 0.12.0","title":"Found block variables overlap: _"},{"location":"WPS441/","text":"Forbid control variables after the block body. What we call block control variables: for loop unpacked variables with context variables Reasoning Variables leaking from the blocks can damage your logic. It might not contain what you think they contain. Solution Use names inside the scope they are defined. Create new functions to return values in case you need to use block variables: when searching for a value, etc. Example # Correct : for my_item in collection : print ( my_item ) # Wrong : for my_item in collection : ... print ( my_item ) See also https://github.com/satwikkansal/wtfPython#-explanation-32 0.12.0 0.14.0","title":"Found control variable used after block: _"},{"location":"WPS442/","text":"Forbid shadowing variables from outer scopes. We check the function, method, and module scopes. While we do not check the class scope. Because class level constants are not available via regular name, and they are scope to ClassName.var_name . Reasoning Shadowing can lead you to a big pile of storage and unexpected bugs. Solution Use different names and do not allow scoping. Example # Correct: def test(): ... def other(): test1 = 1 # Wrong: def test(): ... def other(): test = 1 # shadows ``test()` function 0.12.0","title":"Found outer scope names shadowing: _"},{"location":"WPS443/","text":"Forbid explicit unhashable types of asset items and dict keys. Reasoning This will resolve in TypeError in runtime. Solution Use hashable types to define set items and dict keys. Example # Correct: my_dict = {1: {}, (1, 2): [], (2, 3): {1, 2}} # Wrong: my_dict = {[1, 2]: [], {2, 3}: {1, 2}} 0.12.0","title":"Found unhashable item"},{"location":"WPS444/","text":"Forbid explicit falsely-evaluated conditions with several keywords. We check: ast.While ast.Assert We do not check variables, attributes, calls, bool and bin operators, etc. We forbid constants and some expressions. Reasoning Some conditions tell us that this node won't work correctly. So, we need to check if we can fix that. Solution Remove the unreachable node, or change the condition item. Example # Correct: assert some_variable while True : ... # Wrong: assert [] while False : ... 0.12.0 0.13.0","title":"Found incorrect keyword condition"},{"location":"WPS445/","text":"Forbid incorrectly named keywords in starred dicts. Reasoning Using the incorrect keywords in a starred dict. Eg.: print(**{'@': 1}) . Solution Don't use incorrect identifiers as keywords. Example # Correct : print ( ** { ' end ' : ' | ' } ) # Wrong : print ( ** { ' 3end ' : ' | ' } ) 0.13.0","title":"Found incorrectly named keyword in the starred dict"},{"location":"WPS446/","text":"Forbid approximate constants. Reasoning Some constants are already defined. No need to write them again, use existing values. We just compare numbers as strings and raise this violation when they start with the same chars. Solution Use pre-defined constants. Example # Correct: from math import pi random_number = 3.15 too_short = 3.1 # Wrong: pi = 3.14 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. See also https://docs.python.org/3/library/math.html#constants 0.13.0","title":"Found approximate constant: _"},{"location":"WPS447/","text":"Forbid using the alphabet as a string. Reasoning Some constants are already defined. No need to write to them again, use existing values. We just compare strings and raise this violation when they have the same chars. Solution Use pre-defined constants. Example # Correct: import string UPPERCASE_ALPH = string . ascii_uppercase LOWERCASE_ALPH = string . ascii_lowercase # Wrong: GUESS_MY_NAME = \"abcde...WXYZ\" UPPERCASE_ALPH = \"ABCD...WXYZ\" LOWERCASE_ALPH = \"abcd...wxyz\" 0.13.0","title":"Found alphabet as strings: _"},{"location":"WPS448/","text":"Forbid incorrect order of except . Note, we only check for built-in exceptions because we cannot statically identify the inheritance order of custom ones. Reasoning Using incorrect order of exceptions is error-prone, since you end up with some unreachable exception clauses. Solution Use the correct order of exceptions. Example # Correct: try: ... except ValueError: ... except Exception: ... # Wrong: try: ... except Exception: ... except ValueError: ... See also https://bit.ly/36MHlzw 0.13.0","title":"Found incorrect exception order"},{"location":"WPS449/","text":"Forbid float keys. Reasoning float is a very ugly data type. It has a lot of \"precision\" errors. When we use float as keys we can hit this wall. Moreover, we cannot use float keys with lists, by design. Solution Use other data types: integers, decimals, or use fuzzy logic. Example # Correct: some = {1: 'a'} some[1] # Wrong: some = {1.0: 'a'} some[1.0] 0.13.0","title":"Found float used as a key"},{"location":"WPS450/","text":"Forbid importing protected objects from modules. Related to WPS436 Found protected module import: _ . Reasoning When importing a protected modules' members, we break the contract which the authors of this module enforce. By disrespecting encapsulation, we may break the code at any moment. Solution Do not import protected objects from modules. Respect the encapsulation. Example # Correct: from some.public.module import FooClass # Wrong: from some.module import _protected from some.module import _protected as not_protected 0.14.0","title":"Found protected object import: _"},{"location":"WPS451/","text":"Forbid positional only or / arguments. This violation is only raised for python3.8+ , earlier versions do not have this concept. Reasoning This is a very rare case. Almost exclusively used by C code and stdlib. There's no point in declaring your own parameters as positional only. It will break your code! Solution Use regular arguments. In case you are working with C, then this violation can be ignored. Example # Correct: def my_function(first, second): ... # Wrong: def my_function(first, /, second): ... See also https://www.python.org/dev/peps/pep-0570/ 0.14.0","title":"Found positional-only argument"},{"location":"WPS452/","text":"Forbid break and continue in a finally block. Related to WPS419 Found try/else/finally with multiple return paths . Reasoning Putting any control statements in finally` is a terrible practice, because finally` is implicitly called and can cause damage to your logic with its implicitness. It should not be allowed. Solution Remove break and continue from finally blocks. Example # Correct : try : ... finally : ... # Wrong : try : ... finally : break try : ... finally : continue 0.14.0","title":"Found break or continue in finally block"},{"location":"WPS453/","text":"Forbid executing a file with shebang incorrectly set. A violation is raised in these cases : Shebang is present but the file is not executable. The file is executable but no shebang is present. Shebang is present but does not contain \"python\". Whitespace is present before the shebang. Presence of blank lines or commented lines before the shebang. Reasoning Setting the shebang incorrectly causes an executable mismatch. Solution Ensure that the shebang is present on the first line, and contains \"python\", and there is no leading whitespace. Example # Correct: #!/usr/bin/env python # Wrong: #!/usr/bin/env #!/usr/bin/env python 0.14.0","title":"Found executable mismatch: _"},{"location":"WPS454/","text":"Forbid raising Exception or BaseException . Reasoning Exception and BaseException are inconvenient to catch. And when you catch them you can accidentally suppress other exceptions. Solution Use a user-defined exception, subclassed from Exception . Example # Correct: raise UserNotFoundError raise UserNotFoundError(\"cannot find user with the given id\") # Wrong: raise Exception raise Exception(\"user not found\") raise BaseException raise BaseException(\"user not found\") See also https://docs.python.org/3/library/exceptions.html#exception-hierarchy https://docs.python.org/3/tutorial/errors.html#user-defined-exceptions 0.15.0","title":"Found wrong raise exception type: _"},{"location":"WPS455/","text":"Forbids using non-trivial expressions as a parameter for except . Reasoning Expressions used as an argument for except could be hard to read and hide real list of exceptions being expected to occur in the outlined code block. Solution Use separate except blocks for each exception or provide a tuple of exception classes. Example # Correct: try: ... except ValueError: ... except TypeError: ... try: ... except (TypeError, ValueError): ... # Wrong: try: ... except TypeError or ValueError: ... 0.15.0","title":"Found non-trivial expression as an argument for \"except\""},{"location":"WPS456/","text":"Forbids using float(\"NaN\") construct to generate NaN. Reasoning This method to generate NaN is really confusing and is a good way to catch a lot of unexpected bugs. Solution Even if you're 100% sure what you're doing, use math.nan instead. Example # Correct: min(math.nan, 3) # Wrong: min(float(\"NAN\"), 3) 0.15.0","title":"Found \"NaN\" as argument to float()"},{"location":"WPS457/","text":"Forbids use of infinite while True: loops. Reasoning Infinite loops will cause bugs in code. Solution Add either a return, raise, or break to handle the infinite loop. Example # Correct : while True : print ( ' forever ' ) break # Wrong : while True : print ( ' forever ' ) 0.15.0","title":"Found an infinite while loop"},{"location":"WPS458/","text":"Forbids to import from already imported modules. Reasoning Importing objects from already imported modules is inconsistent and error-prone. Solution Do not import objects from already imported modules or use aliases when it cannot be avoided. Example # Correct: import public from public.module import FooClass import hypothesis from hypothesis import strategies as st # Wrong: from public import utils from public.utils import something import hypothesis from hypothesis import strategies 0.15.0","title":"Found imports collision: _"},{"location":"WPS459/","text":"Forbids comparisons with float and complex . Reasoning This is a best practice rule, as float and complex suffer from representation error, leading to possibly incorrect results during comparison. Solution Use fuzzy operators. 1. abs(f1 - f2) <= allowed_error 2. math.isclose(f1, f2) (for float ) 3. cmath.isclose(c1, c2) (for complex ) 4. Custom logic, not using operators Example # Correct: math.isclose(3.0, 0.3 / 0.1) cmath.isclose(3 + 4j, (0.3 + 0.4j) / 0.1) # Wrong: 3.0 == 0.3 / 0.1 3 + 4j == (0.3 + 0.4j) / 0.1 0.15.0","title":"Found comparison with float or complex number"},{"location":"WPS460/","text":"Forbids to have single element destructuring. Reasoning Having single element destructuring is not readable. Solution Use access by index instead. Example # Correct: first = single_element_list[0] # Wrong: (first,) = [1] 0.15.0","title":"Found single element destructuring"},{"location":"WPS461/","text":"Forbids to use specific inline ignore violations. There can be forbidden a specific violation or whole class of violations. Reasoning There are violations important for specific project that must not be ignored, e.g. complexity or best practices violations. Solution Remove inline ignore for forbidden violations. Configuration This rule is configurable with --forbidden-inline-ignore . Default: FORBIDDEN_INLINE_IGNORE 0.15.0","title":"Forbidden inline ignore: _"},{"location":"WPS462/","text":"Frobids direct usage of multiline strings. Multiline strings are only allowed in docstrings or assignments to variables. Reasoning Direct usage of multiline strings is not readable. One should not depend on the current indentation, e.g. in comparisons or function calls. Solution Assign a multiline string to a variable. Example # Correct: multiline = \"\"\" abc abc \"\"\" # Wrong: function(\"\"\" abc abc \"\"\") 0.15.0","title":"Wrong multiline string usage"},{"location":"WPS463/","text":"Forbids to have functions starting with get_ without returning a value. Applies to both methods and functions. Reasoning A get_ function is generally expected to return a value. Otherwise, it is most likely either an error or bad naming. Solution Make sure getter functions return or yield a value on all execution paths, or rename the function. Example # Correct : def get_random_number () : return random . randint ( 1 , 10 ) # Wrong : def get_random_number () : print ( ' I do not return a value! ' ) 0.15.0","title":"Found a getter without a return value"},{"location":"WPS464/","text":"Forbid empty comments. Empty comments are only allowed in between valid comments. Reasoning Empty comments that do not help formatting should be excluded. Solution Remove the empty comments. Example # Correct: # First line # # Samples: # One # Two my_var = 1 # Wrong: # my_var = 1 0.15.0","title":"Found empty comment"},{"location":"WPS465/","text":"Forbid comparisons between bitwise and boolean expressions. Empty comments are only allowed in between valid comments. Reasoning This case indicates that a person confused & with and and | with or . This can be the case if a person is coming from another language. Solution Change bitwise operator to boolean operators. Example # Correct: first | 10 # Wrong: result = ((first > 0) & False) 0.15.0","title":"Found likely bitwise and boolean operation mixup"},{"location":"WPS466/","text":"Forbid using complex grammar for using decorators. This violation is only raised for python3.9+ , earlier versions do not have this concept. Reasoning New grammar allows to use decorators in a more liberal way. It is probably not a good idea. Because decorators should be simple and easy to read. Solution Use names, attributes, and calls as decorators only. You are free to pass any args to function calls, however. Example # Correct : @some . decorator ( args ) def my_function () : ... # Wrong : @some . decorator [ 'method' ] + other def my_function () : ... 0.15.0","title":"Found new-styled decorator"},{"location":"wemake-python-styleguide/0.15.3/violations/complexity/index.html","text":"These checks find flaws in your application design. We try to stick to \"the magical 7 \u00b1 2 number\" when counting things. https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two That's how many objects we can keep in our memory at a time. We try hard not to exceed the memory capacity limit. You can also find interesting reading about \"Cognitive complexity\": https://www.sonarsource.com/docs/CognitiveComplexity.pdf Note: Simple is better than complex. Complex is better than complicated. See also: https://sobolevn.me/2019/10/complexity-waterfall","title":"WPS2xx Complexity"},{"location":"WPS200/","text":"Forbid modules with complex lines. We are using the Jones Complexity algorithm to count module's score. See WPS221 Found line with high Jones Complexity: _ for details of per-line-complexity. How it is done: we count complexity per line, then measure the median complexity across the lines in the whole module. Reasoning Having complex modules will decrease your code maintainability. Solution Refactor the module contents. Configuration This rule is configurable with --max-jones-score . Default: MAX_JONES_SCORE 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found module with high Jones Complexity score: _"},{"location":"WPS201/","text":"Forbid modules with too many imports. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imports without prefixes is quite expensive. You have to memorize all the source locations of the imports and sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why would a single module have so many dependencies? So, the module becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several modules. We do not make any distinction between import and from ... import ... . Configuration This rule is configurable with --max-imports . Default: MAX_IMPORTS 0.1.0","title":"Found module with too many imports: _"},{"location":"WPS202/","text":"Forbid too many classes and functions in a single module. Reasoning Having many classes and functions in a single module is a bad thing. Soon it will be hard to read through this code and understand it. Solution It is better to split this module into several modules or a package. We do not make any distinctions between classes and functions in this check. They are treated as the same unit of logic. We also do not care about functions and classes being public or not. However, methods are counted separately on a per-class basis. Configuration This rule is configurable with --max-module-members . Default: MAX_MODULE_MEMBERS 0.1.0","title":"Found too many module members: _"},{"location":"WPS203/","text":"Forbid modules with too many imported names. Namespaces are one honking great idea -- let's do more of those! Reasoning Having too many imported names without prefixes is quite expensive. You have to memorize all the source locations of the imports and sometimes it is hard to remember what kind of functions and classes are already injected into your context. It is also a questionable design if a single module has a lot of imports. Why would a single module have so many dependencies? So, the module becomes too coupled. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Or refactor your code and split the complex module into several modules. Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names We do not make any differences between import and from ... import ... . Configuration This rule is configurable with --max-imported-names . Default: MAX_IMPORTED_NAMES 0.12.0","title":"Found module with too many imported names: _"},{"location":"WPS204/","text":"Forbid overused expressions in a module, function or method. What do we call an \"overused expression\"? When you use any expression (like user_dict['age'] for example) inside your code, you always have to track that you are not using it \"too much\" because if that expression is everywhere inside your code, it is a sign of a problem. It means that you are missing an abstraction. We check for overused expressions on two levels: per each function per all module Related to WPS213 Found too many expressions: _ . Reasoning Overusing expressions leads to losing the parts that can and should be refactored into variables, methods, and properties of objects. Solution Refactor expressions to be an attribute, a method, or a new variable. Configuration This rule is configurable with --max-module-expressions . Default: MAX_MODULE_EXPRESSIONS And with --max-function-expressions . Default: MAX_FUNCTION_EXPRESSIONS 0.12.0 0.14.0","title":"Found overused expression: _"},{"location":"WPS210/","text":"Forbid too many local variables in the unit of code. Reasoning Having too many variables in a single function is a bad thing. Soon, you will have trouble understanding what this variable means. It will also become hard to name new variables. Solution If you have too many variables in a function, you have to refactor it. What counts as a local variable? We only count a variable as local in the following case: it is assigned inside the function body. We do not count variables defined inside comprehensions as local variables, since it is impossible to use them outside of the comprehension. Example def first_function ( param ): first_var = 1 def second_function ( argument ): second_var = 1 argument = int ( argument ) third_var , _ = some_call () In this example we will count as locals only several variables: first_var , because it is assigned inside the function's body second_var , because it is assigned inside the function's body argument , because it is reassigned inside the function's body third_var , because it is assigned inside the function's body Please, note that _ is a special case. It is not counted as a local variable. Since by design it means: do not count me as a real variable. Configuration This rule is configurable with --max-local-variables . Default: MAX_LOCAL_VARIABLES 0.1.0","title":"Found too many local variables: _"},{"location":"WPS211/","text":"Forbid too many arguments for a function or method. Reasoning This is an indicator of a bad design. When a function requires many arguments it is a sign that it should be refactored. It also indicates that the function does too many things at once. Solution Split the function into several functions. Then it will be easier to use them. Configuration This rule is configurable with --max-arguments . Default: MAX_ARGUMENTS 0.1.0","title":"Found too many arguments: _"},{"location":"WPS212/","text":"Forbid placing too many return statements in a function. Reasoning When there are too many return keywords, functions are hard to test. They are also hard to read and hard to change and keep everything inside your head at once. Solution Change your design. Split the function into multiple functions. Configuration This rule is configurable with --max-returns . Default: MAX_RETURNS 0.1.0","title":"Found too many return statements: _"},{"location":"WPS213/","text":"Forbid putting too many expressions in a single function. This rule is quite similar to \"max lines\" in a function, but is much nicer because we don't count lines, we count real code entities. This way adding just several extra empty lines for readability will never trigger this violation. Related to WPS204 Found overused expression: _ . Reasoning When there are too many expressions it means that this function does too many things at once. It has too much logic. Solution Split function into several functions, refactor your API. Configuration This rule is configurable with --max-expressions . Default: MAX_EXPRESSIONS 0.1.0 See also https://en.wikipedia.org/wiki/Expression_(computer_science)","title":"Found too many expressions: _"},{"location":"WPS214/","text":"Forbid too many methods in a single class. Reasoning Having too many methods might lead to the \"God object\" anti-pattern. This kind of object can handle everything. So, in the end, your code becomes too hard to maintain and test. Solution What to do if you have too many methods in a single class? Split this class into several classes, then use composition or inheritance to refactor your code. This will protect you from the \"God object\" anti-pattern. We do not make any distinctions between instance and class methods. We also do not care about functions and classes being public or not. We also do not count inherited methods from parents. This rule does not count the attributes of a class. Configuration This rule is configurable with --max-methods . Default: MAX_METHODS 0.1.0 See also https://en.wikipedia.org/wiki/God_object","title":"Found too many methods: _"},{"location":"WPS215/","text":"Restrict the maximum number of base classes. Reasoning It is almost never possible to navigate to the desired method of a parent class when you need it with multiple mixins. It is hard to understand mro and super calls. Do not overuse this technique. Solution Reduce the number of base classes. Use composition over inheritance. Example # Correct: class SomeClassName ( First , Second , Mixin ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , ThirdParentClass , CustomClass , AddedClass , ): ... Configuration This rule is configurable with --max-base-classes . Default: MAX_BASE_CLASSES 0.3.0 0.5.0 See also https://en.wikipedia.org/wiki/Composition_over_inheritance","title":"Too many base classes: _"},{"location":"WPS216/","text":"Restrict the maximum number of decorators. Reasoning When you are using too many decorators it means that you are trying to overuse the magic. You have to ask yourself: do I really know what happens inside this decorator tree? Typically, the answer will be \"no\". Solution Using too many decorators typically means that you are trying to configure the behavior from outside of the class. Do not do that too much. Split functions or classes into smaller ones. Use higher order decorators. Configuration This rule is configurable with --max-decorators . Default: MAX_DECORATORS This rule checks: functions, methods, and classes. 0.5.0","title":"Too many decorators: _"},{"location":"WPS217/","text":"Forbid placing too many await expressions in a function. Reasoning When there are too many await keywords, functions are starting to get really complex. It is hard to tell where we are and what is going on. Solution Change your design. Split functions into smaller ones. Configuration This rule is configurable with --max-awaits . Default: MAX_AWAITS 0.10.0","title":"Found too many await expressions: _"},{"location":"WPS218/","text":"Forbid placing too many assert statements into a function. Reasoning When there are too many assert keywords, functions are starting to get really complex. It might indicate that your tests or contracts are too big. Solution Create rich assert statements, use higher-level contracts, or create special guard functions. Configuration This rule is configurable with --max-asserts . Default: MAX_ASSERTS 0.12.0","title":"Found too many assert statements: _"},{"location":"WPS219/","text":"Forbid consecutive expressions with too deep access level. We consider only these expressions as accesses: ast.Subscript ast.Attribute We do not treat ast.Call as an access, since there are a lot of call-based APIs like Django ORM, builder patterns, etc. Reasoning Having too deep access level indicates a bad design and overcomplicated data without proper API. Solution Split the expression into variables, functions or classes. Refactor the API for your data layout. Example # Correct: access level = 4 self . attr . inner . wrapper [ 1 ] # Correct: access level = 1 manager . filter (). exclude (). annotate (). values (). first () # Wrong: access level = 5 self . attr . inner . wrapper . method . call () # Wrong: access level = 5 # ``obj` has access level of 2: # ``.attr`, ``.call` # ``call()` has access level of 5: # ``.other`, ``[0]`, ``.field`, ``.type`, ``.boom` obj . attr . call (). other [ 0 ] . field . type . boom Configuration This rule is configurable with --max-access-level . Default: MAX_ACCESS_LEVEL 0.12.0","title":"Found too deep access level: _"},{"location":"WPS220/","text":"Forbid nesting blocks too deep. Reasoning If nesting is too deep that indicates usage of complex logic and language constructions. This means that our design is not suited to handle such construction. Solution We need to refactor our complex construction into simpler ones. We can use new functions or different constructions. 0.1.0 0.5.0","title":"Found too deep nesting: _"},{"location":"WPS221/","text":"Forbid complex lines. We are using the Jones Complexity algorithm to count complexity. What is the Jones Complexity? It is a simple yet powerful method to count the number of ast nodes per line. If the complexity of a single line is higher than a threshold, then an error is raised. What nodes do we count? All except the following: modules function and classes, since they are checked differently type annotations, since they do not increase the complexity Reasoning Having a complex line indicates that you somehow managed to put too much logic inside a single line. At some point in time, you will no longer be able to understand what this line means and what it does. Solution Split a single line into several lines: by creating new variables, statements or functions. Note, this might trigger new complexity issues. With this technique, a single new node in a line might trigger a complex refactoring process including several modules. Configuration This rule is configurable with --max-line-complexity . Default: MAX_LINE_COMPLEXITY 0.1.0 See also https://github.com/Miserlou/JonesComplexity","title":"Found line with high Jones Complexity: _"},{"location":"WPS222/","text":"Forbid conditions with too many logical operators. We use MAX_CONDITIONS as a default value. Reasoning When reading through the complex conditions you will fail to understand all the possible branches. And you will end up putting debug breakpoint on this line just to figure out how it works. Solution We can reduce the complexity of a single if by doing two things: creating new variables or creating nested if statements. Both of these actions will trigger other complexity checks. We count and and or keywords as conditions. 0.1.0 0.5.0","title":"Found a condition with too much logic: _"},{"location":"WPS223/","text":"Forbid too many elif branches. We use MAX_ELIFS as a default value. Reasoning This rule is specifically important because many elif branches indicates a complex flow in your design: you are reimplementing switch in python. Solution There are different design patterns to use instead. For example, you can use an interface that just calls a specific method without if . Another option is to separate your if into multiple functions. 0.1.0 0.5.0","title":"Found too many elif branches: _"},{"location":"WPS224/","text":"Forbid too many for statements within a comprehension. Reasoning When reading through the complex comprehension you will fail to understand it. Solution We can reduce the complexity of the comprehension by reducing the amount of for statements. Refactor your code to use several for loops, comprehensions, or different functions. Example # Wrong: ast_nodes = [ target for assignment in top_level_assigns for target in assignment . targets for _ in range ( 10 ) ] 0.3.0","title":"Found a comprehension with too many for statements"},{"location":"WPS225/","text":"Forbid too many except cases in a single try clause. We use MAX_EXCEPT_CASES as a default value. Reasoning Handling too many exceptions in a single place is a good indicator of a bad design since one controlling structure will become too complex. Also, you will need to test a lot of logic paths in your application. Solution We can reduce the complexity of this case by splitting it into multiple try cases, functions or using a decorator to handle different exceptions. 0.7.0","title":"Found too many except cases: _"},{"location":"WPS226/","text":"Forbid the overuse of string constants. We allow to use strings without any restrictions as annotations for variables, arguments, return values, and class attributes. Reasoning When some string is used more than several time in your code, it probably means that this string is a meaningful constant and should be treated like one. Solution Deduplicate you string usages by defining new functions or constants. Configuration This rule is configurable with --max-string-usages . Default: MAX_STRING_USAGES 0.10.0","title":"Found string constant over-use: _"},{"location":"WPS227/","text":"Forbid yielding tuples that are too long. Reasoning Long yield tuples complicate generator usage. This rule helps to reduce complication. Solution Use lists of similar type or wrapper objects. 0.10.0","title":"Found too long yield tuple: _"},{"location":"WPS228/","text":"Forbid compare expressions that are too long. Reasoning Compare expressions that are too long indicate that there's something wrong going on in the code. Compares should not be longer than 3 or 4 items. Solution Use several conditions, separate variables, or functions. 0.10.0","title":"Found too long compare"},{"location":"WPS229/","text":"Forbid try blocks with bodies that are too long. Reasoning Having too many statements inside your try block can lead to situations when a statement raises an exception and you are not aware of it since it is not expected. Solution Move things out of the try block or create new functions. The fewer lines you have in your try block - the safer you are from accidental errors. Configuration This rule is configurable with --max-try-body-length . Default: MAX_TRY_BODY_LENGTH See also https://adamj.eu/tech/2019/10/02/limit-your-try-clauses-in-python/ 0.12.0","title":"Found too long try body length: _"},{"location":"WPS230/","text":"Forbid instances with too many public attributes. We only check static definitions in a form of self.public = ... . We do not count parent attributes. We do not count properties. We do not count annotations. We do not count class attributes. We do not count duplicates. Reasoning Having too many public instance attributes means that your class is too complex in terms of coupling. Other classes and functions will rely on these concrete fields instead of better abstraction layers. Solution Make some attributes protected. Split this class into several. If the class is a Data Transfer Object, then use @dataclass decorator. Configuration This rule is configurable with --max-attributes . Default: MAX_ATTRIBUTES See also https://en.wikipedia.org/wiki/Coupling_(computer_programming) 0.12.0","title":"Found too many public instance attributes: _"},{"location":"WPS231/","text":"Forbid functions with too much cognitive complexity. Reasoning People are not great at reading and interpreting code in their heads. That's why code with a lot of nested loops, conditions, exceptions handlers, and context managers is hard to read and understand. Solution Rewrite your code to be simpler. Use flat structures and conditions, remove nested loops. Configuration This rule is configurable with --max-cognitive-score . Default: MAX_COGNITIVE_SCORE See also https://en.wikipedia.org/wiki/Cognitive_complexity https://pypi.org/project/cognitive-complexity/ https://github.com/Melevir/flake8-cognitive-complexity 0.13.0","title":"Found function with too much cognitive complexity: _"},{"location":"WPS232/","text":"Forbid modules with average cognitive complexity that is too high. Reasoning Modules with lots of functions might hide cognitive complexity inside many small and relatively simple functions. Solution Rewrite your code to be simpler or use several modules. Configuration This rule is configurable with --max-cognitive-average . Default: MAX_COGNITIVE_AVERAGE See also https://en.wikipedia.org/wiki/Cognitive_complexity 0.13.0","title":"Found module cognitive complexity that is too high: _"},{"location":"WPS233/","text":"Forbid call chains that are too long. Reasoning Call chains that are too long are overcomplicated and indicators of bad API design. Solution Split the expression into variables, functions or classes. Refactor the API to allow higher-level access to functions. Configuration This rule is configurable with --max-call-level . Default: MAX_CALL_LEVEL 0.13.0","title":"Found call chain that is too long: _"},{"location":"WPS234/","text":"Forbid overly complex annotations. Annotation complexity is maximum annotation nesting level. ## Example List[int] has complexity of 2 and Tuple[List[Optional[str]], int] has complexity of 4. Reasoning Overly complex annotations make your types unreadable. And make developers afraid of types. Solution Create type aliases. And use them a lot! Configuration This rule is configurable with --max-annotation-complexity . Default: MAX_ANN_COMPLEXITY See also https://mypy.readthedocs.io/en/stable/kinds_of_types.html#type-aliases https://github.com/best-doctor/flake8-annotations-complexity 0.14.0","title":"Found overly complex annotation: _"},{"location":"WPS235/","text":"Forbid from ... import ... with too many imported names. Reasoning Importing too many names from one import is an easy way to cause the violation WPS203 - too many imported names. Solution Refactor the imports to import a common namespace. Something like from package import module and then use it like module.function() . Example # Correct: import module # 1 imported name # Wrong: from module import func1 , func2 , ... , funcN # N imported names Configuration This rule is configurable with --max-import-from-members . Default: MAX_IMPORT_FROM_MEMBERS 0.15.0","title":"Found too many imported names from a module: _"},{"location":"WPS236/","text":"Forbid using too many variables to unpack a tuple. Reasoning The order and meaning are hard to remember. Solution If you have more than 2 values in a tuple, consider using typing.NamedTuple or a dataclass instead. Example # Correct: result = foo() # Wrong: a, b, c, d, e = foo() Configuration This rule is configurable with --max-tuple-unpack-length . Default: MAX_TUPLE_UNPACK_LENGTH 0.15.0","title":"Found too many variables used to unpack a tuple: _"},{"location":"WPS237/","text":"Forbids f strings that are too complex. A complex format string is defined as use of any formatted value that is not: the value of a variable the value of a collection through lookup with a variable, number, or string as the key the return value of a procedure call without arguments Related to WPS305 Found f string . Reasoning Complex f strings are often difficult to understand, making the code less readable. Generally we don't allow f strings but this violation exists in case the user decides to ignore the general violation. Solution Use .format() or assign complex expressions to variables before formatting. Example # Correct : f ' smth {user.get_full_name()} ' # Wrong : f ' {reverse(\"url-name\")}?{\"&\".join(\"user=\"+uid for uid in user_ids)} ' 0.15.0","title":"Found a too complex f string"},{"location":"WPS238/","text":"Forbids too many raise statements in a function. Reasoning Too many raise statements in a function make the code untraceable and overcomplicated. Solution Split the function into smaller functions, such that each of them can raise less errors. Create more standard errors, or use alternative ways to raise them. Configuration This rule is configurable with --max-raises . Default: MAX_RAISES 0.15.0","title":"Found too many raises in a function: _"},{"location":"wemake-python-styleguide/0.15.3/violations/consistency/index.html","text":"These checks limit Python's inconsistencies. We can do the same things differently in Python. For example, there are three ways to format a string. There are several ways to write the same number. We like our code to be consistent. It is easier to work with your code base if you follow these rules. So, we choose a single way to do things. It does not mean that we choose the best way to do it. But, we value consistency more than being 100% right and we are ready to suffer all trade-offs that might come. Once again, these rules are highly subjective, but we love them.","title":"WPS3xx Consistency"},{"location":"WPS300/","text":"Forbid imports relative to the current folder. Reasoning We should pick one style and stick to it. We have decided to use the explicit one. Solution Refactor your imports to use the absolute path. Example # Correct: from my_package.version import get_version # Wrong: from .version import get_version from ..drivers import MySQLDriver 0.1.0","title":"Found local folder import"},{"location":"WPS301/","text":"Forbid imports like import os.path . Reasoning There are too many ways to import something. We should pick one style and stick to it. We have decided to use the readable one. Solution Refactor your import statement. Example # Correct: from os import path # Wrong: import os.path 0.1.0","title":"Found dotted raw import: _"},{"location":"WPS302/","text":"Forbid u string prefix. Reasoning We haven't needed this prefix since python2 , but it is still possible to find it in a codebase. Solution Remove this prefix. Example # Correct: nickname = 'sobolevn' file_contents = b'aabbcc' # Wrong: nickname = u'sobolevn' 0.1.0","title":"Found unicode string prefix: _"},{"location":"WPS303/","text":"Forbid underscores ( _ ) in numbers. Reasoning It is possible to write 1000 in three different ways: 1_000 , 10_00 , and 100_0 . And it would be still the same number. Count how many ways there are to write bigger numbers. Currently, it all depends on the cultural habits of the author. We enforce a single way to write numbers: without the underscore. Solution Numbers should be written as numbers: 1000 . If you have a very big number with a lot of zeros, use multiplication. Example # Correct: phone = 88313443 million = 1000000 # Wrong: phone = 8_83_134_43 million = 100_00_00 0.1.0","title":"Found underscored number: _"},{"location":"WPS304/","text":"Forbid partial floats like .05 or 23. . Reasoning Partial numbers are hard to read and they can be confused with other numbers. For example, it is really easy to confuse 0.5 and .05 when reading through the source code. Solution Use full versions with leading and trailing zeros. Example # Correct: half = 0.5 ten_float = 10.0 # Wrong: half = .5 ten_float = 10. 0.1.0","title":"Found partial float: _"},{"location":"WPS305/","text":"Forbid f strings. Reasoning f strings implicitly rely on the context around them. Imagine that you have a string that breaks when you move it two lines above. That's not how a string should behave. Also, they promote a bad practice: putting your logic inside the template. Moreover, they do two things at once: declare a template and format it in a single action. Solution Use .format() with indexed params instead. See also https://github.com/xZise/flake8-string-format Example # Wrong: f'Result is: {2 + 2}' # Correct: 'Result is: {0}'.format(2 + 2) 'Hey {user}! How are you?'.format(user='sobolevn') 0.1.0","title":"Found f string"},{"location":"WPS306/","text":"Forbid writing classes without base classes. Please, note that this rule has nothing to do with python2 . We care only about consistency here. Reasoning We just need to decide how to do it. We need a single and unified rule about base classes. We have decided to stick to the explicit base class notation. Why? Because it is consistent with other use-cases. When we have a base class A , we write class MyClass(A): . When we have no base class, we have an implicit object base class. So, we still use the same syntax: class MyClass(object): . Solution Add a base class. Example # Correct: class Some ( object ): ... # Wrong: class Some: ... 0.1.0","title":"Found class without a base class: _"},{"location":"WPS307/","text":"Forbid multiple if statements inside list comprehensions. Reasoning It is very hard to read multiple if statements inside a list comprehension. Since it is even hard to tell all of them should pass or fail. Solution Use a single if statement inside list comprehensions. Use filter() if you have complicated logic. Example # Wrong : nodes = [ node for node in html if node != ' b ' if node != ' i ' ] # Correct : nodes = [ node for node in html if node not in ( ' b ' , ' i ' ) ] 0.1.0","title":"Found list comprehension with multiple ifs"},{"location":"WPS308/","text":"Forbid comparing between two literals. Reasoning When two constants are compared it is typically an indication of a mistake, since the Boolean value of the comparison, will always be the same. Solution Remove the constant comparison and any associated dead code. Example # Wrong : if 60 * 60 < 1000 : do_something () else : do_something_else () # Correct : do_something_else () 0.3.0","title":"Found constant comparison"},{"location":"WPS309/","text":"Forbid comparisons where the argument doesn't come first. Reasoning It is hard to read the code when you have to shuffle the ordering of the arguments all the time. Bring consistency to the comparison! Solution Refactor your comparison expression, place the argument first. Example # Correct : if some_x > 3 : if 3 < some_x < 10 : # Wrong : if 3 < some_x : 0.3.0","title":"Found reversed compare order"},{"location":"WPS310/","text":"Forbid uppercase X , O , B , and E in numbers. Reasoning Octal, hex, binary and scientific notation suffixes could be written in two possible notations: lowercase and uppercase which brings confusion and decreases code consistency and readability. We enforce a single way to write numbers with suffixes: suffix with lowercase chars. Solution Octal, hex, binary and scientific notation suffixes in numbers should be written in lowercase. Example # Correct: hex_number = 0xFF octal_number = 0o11 binary_number = 0b1001 number_with_scientific_notation = 1.5e+10 # Wrong: hex_number = 0XFF octal_number = 0O11 binary_number = 0B1001 number_with_scientific_notation = 1.5E+10 0.3.0","title":"Found bad number suffix: _"},{"location":"WPS311/","text":"Forbid comparisons with multiple in checks. Reasoning Using multiple in checks is unreadable. Solution Refactor your comparison expression to use several and conditions or separate if statements in cases where it is appropriate. Example # Correct : if item in bucket and bucket in master_list_of_buckets : if x_coord not in line and line not in square : # Wrong : if item in bucket in master_list_of_buckets : if x_cord not in line not in square : 0.3.0 0.10.0","title":"Found multiple in compares"},{"location":"WPS312/","text":"Forbid comparisons of a variable to itself. Reasoning When a variable is compared to itself, it is typically an indication of a mistake since the Boolean value of the comparison will always be the same. Solution Remove the comparison and any associated dead code. Example # Correct : do_something () # Wrong : if a < a : do_something () else : do_something_else () 0.3.0","title":"Found comparison of a variable to itself"},{"location":"WPS313/","text":"Enforce separation of parenthesis from keywords with spaces. Reasoning Some people use return and yield keywords as functions. The same happened to good old print in Python2. Solution Insert space symbol between the keyword and opening parenthesis. Example # Wrong: def func(): a = 1 b = 2 del(a, b) yield(1, 2, 3) # Correct: def func(): a = 1 del (a, b) yield (1, 2, 3) 0.3.0","title":"Found parenthesis immediately after a keyword"},{"location":"WPS314/","text":"Forbid using if statements that use invalid conditionals. Reasoning When invalid conditional arguments are used it is typically an indication of a mistake, since the value of the conditional result will always be the same. Solution Remove the conditional and any associated dead code. Example # Correct : if value is True : ... # Wrong : if True : ... 0.3.0","title":"Found conditional that always evaluates the same"},{"location":"WPS315/","text":"Forbid extra object in parent classes list. Reasoning We should allow object only when we explicitly use it as a single parent class. When there is another class or there are multiple parents - we should not allow it for the consistency reasons. Solution Remove extra object parent class from the list. Example # Correct: class SomeClassName ( object ): ... class SomeClassName ( FirstParentClass , SecondParentClass ): ... # Wrong: class SomeClassName ( FirstParentClass , SecondParentClass , object ): ... 0.3.0","title":"Found extra object in parent classes list"},{"location":"WPS316/","text":"Forbid multiple assignment targets for context managers. Reasoning It is hard to distinguish whether as should unpack into a tuple or if we are just using two context managers. Solution Use several context managers or explicit brackets. Example # Correct: with open('') as first: with second: ... with some_context as (first, second): ... # Wrong: with open('') as first, second: ... 0.6.0","title":"Found context manager with too many assignments"},{"location":"WPS317/","text":"Forbid incorrect indentation for parameters. Reasoning It is really easy to spoil your perfect, readable code with incorrect multi-line parameters indentation. Since it is really easy to style them in any of 100 possible ways. We enforce a strict rule about how it is possible to write these multi-line parameters. Solution Use consistent multi-line parameters indentation. Example # Correct: def my_function ( arg1 , arg2 , arg3 ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( 1 , 2 , 3 , 4 , 5 , 6 , ) def my_function ( arg1 , arg2 , arg3 , ) -> None : return None print ( first_variable , 2 , third_value , 4 , 5 , last_item , ) # Special case: print ( 'some text' , 'description' , [ first_variable , second_variable , third_variable , last_item , ], end = '' ) # Correct complex case: @ pytest . mark . parametrize (( 'boolean_arg' , 'string_arg' ), [ ( True , \"string\" ), ( False , \"another string\" ), ]) Everything else is considered a violation. This rule checks: lists, sets, tuples, dicts, calls, functions, methods, and classes. 0.6.0","title":"Found incorrect multi-line parameters"},{"location":"WPS318/","text":"Forbid extra indentation. Reasoning You can use extra indentation for lines of code. Python allows you to do that in case you want to keep the indentation level equal for this specific node, but that's insane! Solution We should stick to 4 spaces for an indentation block. Each next block level should be indented by just 4 extra spaces. Example # Correct: def test(): print('test') # Wrong: def test(): print('test') This rule is consistent with the \"Vertical Hanging Indent\" option for multi_line_output setting of isort . To avoid conflicting rules, you should set multi_line_output = 3 in the isort settings. See also https://github.com/timothycrosley/isort#multi-line-output-modes https://github.com/wemake-services/wemake-python-styleguide/blob/master/styles/isort.toml 0.6.0","title":"Found extra indentation"},{"location":"WPS319/","text":"Forbid brackets in the wrong position. Reasoning You can do bizarre things with bracket positioning in python. We require all brackets to be consistent. Solution Place bracket on the same line, in case of a single line expression. Or place the bracket on a new line in case of a multi-line expression. Example # Correct: print ([ 1 , 2 , 3 , ]) print ( 1 , 2 , ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ], ) -> TokenLines : ... # Wrong: print ([ 1 , 2 , 3 ], ) print ( 1 , 2 ) def _annotate_brackets ( tokens : List [ tokenize . TokenInfo ]) -> TokenLines : ... We check round, square, and curly brackets. 0.6.0","title":"Found bracket in wrong position"},{"location":"WPS320/","text":"Forbid multi-line function type annotations. Reasoning Functions with multi-line type annotations are unreadable. Solution Use type annotations that fit into a single line to annotate functions. If your annotation is too long, then use type aliases. Example # Correct : def create_list ( length : int ) -> List [ int ] : ... # Wrong : def create_list ( length : int ) -> List [ int, ] : ... This rule checks argument and return type annotations. 0.6.0","title":"Found multi-line function type annotation"},{"location":"WPS321/","text":"Forbid uppercase string modifiers. Reasoning String modifiers should be consistent. Solution Use lowercase string modifiers. Example # Correct: some_string = r ' / regex / ' some_bytes = b '1 23 ' # Wrong: some_string = R ' / regex / ' some_bytes = B '1 23 ' 0.6.0","title":"Found uppercase string modifier: _"},{"location":"WPS322/","text":"Forbid triple quotes for singleline strings. Reasoning String quotes should be consistent. Solution Use single quotes for single-line strings. Triple quotes are only allowed for real multiline strings. Example # Correct: single_line = 'abc' multiline = \"\"\" one two \"\"\" # Wrong: some_string = \"\"\"abc\"\"\" some_bytes = b\"\"\"123\"\"\" Docstrings are ignored from this rule. You must use triple quotes strings for docstrings. 0.7.0","title":"Found incorrect multi-line string"},{"location":"WPS323/","text":"Forbid % formatting on strings. We check for string formatting. We try not to issue false positives. It is better for us to ignore a real (but hard to detect) case, then marking a valid one as incorrect. Internally we check for this pattern in string definitions: %[ (name) ] [ flags ] [ width ] [ .precision ] [ {h | l} ] type This is a C format specification. Related to WPS305 Found f string and solves the same problem. Reasoning You must use a single formatting method across your project. Solution We enforce to use string .format() method for this task. Example # Correct: 'some string', 'your name: {0}', 'data: {data}' # Wrong: 'my name is: %s', 'data: %(data)d' It might be a good idea to disable this rule and switch to flake8-pep3101 in case your project has a lot of false-positives due to some specific string chars that uses % a lot. See also https://github.com/gforcada/flake8-pep3101 https://msdn.microsoft.com/en-us/library/56e442dc.aspx https://docs.python.org/3/library/stdtypes.html#old-string-formatting https://pyformat.info/ 0.14.0","title":"Found % string formatting"},{"location":"WPS324/","text":"Enforce consistent return statements. Rules are: 1. if any return has a value, all return nodes should have a value 2. do not place return without a value at the end of a function This rule respects mypy style of placing return statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the return statements to make them consistent. Remove return statement from the function end. Example # Correct : def function () : if some : return 2 return 1 # Wrong : def function () : if some : return return 1 0.7.0","title":"Found inconsistent return statement"},{"location":"WPS325/","text":"Enforce consistent yield statements. Rules are: 1. if any yield has a value, all yield nodes should have a value This rule respects mypy style of placing yield statements. There should be no conflict with these two checks. Reasoning This is done for pure consistency and readability of your code. Eventually, this rule may also find some bugs in your code. Solution Add or remove values from the yield statements to make them consistent. Example # Correct : def function () : if some : yield 2 yield 1 # Wrong : def function () : if some : yield yield 1 0.7.0","title":"Found inconsistent yield statement"},{"location":"WPS326/","text":"Forbid implicit string concatenation. Reasoning This is error-prone, since you can possibly miss a comma in a collection of strings and get an implicit concatenation. And because there are safer ways to do the same thing it is better to use them instead. Solution Use + or .format() to join strings. Example # Correct: text = 'first' + 'second' # Wrong: text = 'first' 'second' 0.7.0","title":"Found implicit string concatenation"},{"location":"WPS327/","text":"Forbid meaningless continue in loops. Reasoning Placing this keyword at the end of any loop won't make any difference to your code. And we prefer not to have meaningless constructs in our code. Solution Remove useless continue from the loop. Example # Correct : for number in [ 1 , 2 , 3 ]: if number < 2 : continue print ( number ) for number in [ 1 , 2 , 3 ]: with suppress ( Exception ) : do_smth ( some_obj ) # Wrong : for number in [ 1 , 2 , 3 ]: print ( number ) continue for number in [ 1 , 2 , 3 ]: try : do_smth ( some_obj ) except Exception : continue 0.7.0","title":"Found useless continue at the end of the loop"},{"location":"WPS328/","text":"Forbid meaningless nodes. Reasoning Some nodes might be completely useless. They will literally do nothing. Sometimes they are hard to find, because this situation can be caused by a recent refactoring or just by accident. This might be also an overuse of syntax. Solution Remove node or make sure it makes sense. Example # Wrong : for number in [ 1 , 2 , 3 ]: break 0.7.0","title":"Found useless node: _"},{"location":"WPS329/","text":"Forbid meaningless except cases. Reasoning Using except cases that just reraise the same exception is error-prone. You can increase your stacktrace, silence some potential exceptions, and screw things up. It also does not make any sense to do so. Solution Remove except case or make sure it makes sense. Example # Correct: try: ... except IndexError: sentry.log() raise ValueError() try: ... except ValueError as exc: raise CustomReadableException from exc # Wrong: try: ... except TypeError: raise 0.7.0","title":"Found useless except case"},{"location":"WPS330/","text":"Forbid unnecessary operators in your code. You can write: 5.4 and +5.4 . There's no need to use the second version. Similarly --5.4 , ---5.4 , not not foo , and ~~42 contain unnecessary operators. Reasoning This is done for consistency reasons. Solution Omit unnecessary operators. Example # Correct: profit = 3.33 profit = -3.33 inverse = ~5 complement = not foo # Wrong: profit = +3.33 profit = --3.33 profit = ---3.33 number = ~~42 bar = not not foo 0.8.0","title":"Found unnecessary operator: _"},{"location":"WPS331/","text":"Forbid local variables that are only used in return statements. We also allow cases when a variable is assigned, then there are some other statements without direct variable access and the variable is returned. We reserve this use-case to be able to do some extra work before the function returns. We also allow the return of partial, sorted, or modified tuple items that are defined just above. Reasoning This is done for consistency and more readable source code. Solution Return the expression itself, instead of creating a temporary variable. Example # Correct : def some_function () : return 1 def other_function () : some_value = 1 do_something ( some_value ) return some_value # Wrong : def some_function () : some_value = 1 return some_value 0.9.0 0.14.0","title":"Found variables that are only used for return: _"},{"location":"WPS332/","text":"Forbid local variable that are only used in return statements. This violation can only be thrown on python3.8+ . Reasoning Code with := is hardly readable. It has big problems with scoping and reading order. And it can lead to a huge mess inside your code. Python is not expression-based. Solution Don't use fancy stuff, use good old assignments. Example # Correct : some = call () if some : print ( some ) # Wrong : if some : = call () : print ( some ) 0.14.0","title":"Found walrus operator"},{"location":"WPS333/","text":"Forbid implicit complex comparison expressions. Reasoning Two comparisons in python that are joined with and operator mean that you have a complex comparison with tree operators. Solution Refactor your comparison without and but with the third operator. Notice that you might have to change the ordering. Example # Correct : if three < two < one : ... # Wrong : if one > two and two > three : ... 0.10.0","title":"Found implicit complex compare"},{"location":"WPS334/","text":"Forbid reversed order complex comparison expressions. Reasoning Comparisons where comparators start from the lowest element are easier to read than one that start from the biggest one. It is also possible to write the same expression in two separate way, which is inconsistent. Solution Reverse the order, so the smallest element comes first and the biggest one comes last. Example # Correct : if three < two < one : ... # Wrong : if one > two > three : ... 0.10.0","title":"Found reversed complex comparison"},{"location":"WPS335/","text":"Forbid wrong for loop iter targets. We forbid to use: Lists and list comprehensions Sets and set comprehensions Dicts and dict comprehensions Generator expressions Empty tuples Reasoning Using lists, dicts, and sets do not make much sense. You can use tuples instead. Using comprehensions implicitly creates a two level loop, that is hard to read and deal with. Solution Use tuples to create explicit iterables for for loops. In case you are using a comprehension, create a new variable. Example # Correct : for person in ( ' Kim ' , ' Nick ' ) : ... # Wrong : for person in [ ' Kim ' , ' Nick ' ]: ... 0.10.0 0.12.0","title":"Found incorrect for loop iter type"},{"location":"WPS336/","text":"Forbid explicit string concatanation in favour of .format method. However, we still allow multiline string concatanation as a way to write long strings that does not fit the 80-chars rule. Reasoning When formatting strings one must use .format and not any other formatting methods like % , + , or f . This is done for consistency reasons. Solution Join strings together if you can, or use .format method. Example # Correct: x = 'ab: {0}'.format(some_data) # Wrong: x = 'a' + 'b: ' + some_data 0.12.0","title":"Found explicit string concatenation"},{"location":"WPS337/","text":"Forbid multiline conditions. Reasoning This way of writing conditions hides the inner complexity this line has and it decreases readability of the code. Solution Divide multiline conditions to some if condition or use variables. Example # Correct : if isinstance ( node . test , ast . UnaryOp ) : if isinstance ( node . test . op , ast . Not ) : ... # Wrong : if isinstance ( node . test , ast . UnaryOp ) and isinstance ( node . test . op , ast . Not , ) : ... 0.9.0 0.11.0","title":"Found multiline conditions"},{"location":"WPS338/","text":"Forbid incorrect order of methods inside a class. We follow the same ordering: __new__ __init__ __call__ __await__ public and magic methods protected methods private methods (we discourage using them) We follow \"Newspaper order\" where the most important things come first. Reasoning It is hard to read classes where API declarations are bloated with implementation details. We need to see the important stuff first, then we can go deeper in case we are interested. Solution Reorder methods inside your class to match our format. 0.12.0","title":"Found incorrect order of methods in a class"},{"location":"WPS339/","text":"Forbid meaningless zeros. We discourage using meaningless zeros in float, binary, octal, hex, and exponential numbers. Reasoning There are \\~infinite ways to write these numbers by adding meaningless leading zeros to the number itself. 0b1 is the same as 0b01 and 0b001 . How can a language be called consistent if you can write numbers in an infinite ways? It hurts readability and understanding of your code. Solution Remove meaningless leading zeros. Example # Correct: numbers = [1.5, 0b1, 0o2, 0x5, 10e10] # Wrong: numbers = [1.50, 0b00000001, 0o0002, 0x05, 10e010] 0.12.0","title":"Found number with meaningless zeros: _"},{"location":"WPS340/","text":"Forbid extra + signs in the exponent. Reasoning Positive exponent is positive by default, there's no need to write an extra + sign. We enforce consistency with this rule. Solution Remove meaningless + sign from the exponent. Example # Correct: number = 1e1 + 1e-1 # Wrong: number = 1e+1 0.12.0","title":"Found exponent number with positive exponent: _"},{"location":"WPS341/","text":"Forbid letters as hex numbers. Reasoning One can write 0xA and 0xa which is inconsistent. This rule enforces upper-case letters in hex numbers. Solution Use uppercase letters in hex numbers. Example # Correct: number = 0xABCDEF # Wrong: number = 0xabcdef 0.12.0","title":"Found wrong hex number case: _"},{"location":"WPS342/","text":"Forbid \\\\ escape sequences inside regular strings. Reasoning It is hard to read escape sequences inside regular strings, because they use \\\\ double backslash for a single character escape. Solution Use raw strings r'' to rewrite the escape sequence with a \\ single backslash. Example # Correct: escaped = [r'\\n', '\\n'] # Wrong: escaped = '\\\\n' 0.12.0","title":"Found implicit raw string: _"},{"location":"WPS343/","text":"Forbid uppercase complex number suffix. Reasoning Numbers should be consistent. Solution Use lowercase suffix for imaginary part. Example # Correct: complex_number = 1j # Wrong: complex_number = 1J 0.12.0","title":"Found wrong complex number suffix: _"},{"location":"WPS344/","text":"Forbid explicit division (or modulo) by zero. Reasoning This will just throw ZeroDivisionError . If that's what you need: just throw it. No need to use undefined math behaviours. Or it might be just a typo / mistake, then fix it. Solution Use ZeroDivisionError or make your number something besides 0 . Example # Correct: raise ZeroDivisionError() # Wrong: 1 / 0 1 % 0 0.12.0","title":"Found explicit zero division"},{"location":"WPS345/","text":"Forbid meaningless math operations with 0 and 1 . Reasoning Adding and subtracting zero does not change the value. There's no need to do that. Multiplying by zero is also redundant: it can be replaced with explicit 0 assign. Multiplying and dividing by 1 is also meaningless. Likewise, using | or ^ with 0 , and using the % operator with 1 are unnecessary. Solution Remove useless operations. Example # Correct: number = 1 zero = 0 one = 1 three = 3 # Wrong: number = 1 + 0 * 1 zero = some * 0 / 1 one = some ** 0 ** 1 three = 3 ^ 0 three = 3 | 0 three = 3 % 1 0.12.0 0.15.0","title":"Found meaningless number operation"},{"location":"WPS346/","text":"Forbid double minus operations. Reasoning Having two operations is harder than having just one. Two negations are harder than one positive expression. Two negations equal to one positive expression. Positive and negative equal to one negative. Solution Replace double minus operation to a single one with plus. Replace 'plus-minus' operation to a single one with minus. Example # Correct: number = 3 + 1 number += 6 number -= 2 # Wrong: number = 3 - -1 number -= -6 number += -2 0.12.0","title":"Found wrong operation sign"},{"location":"WPS347/","text":"Forbid imports that may cause confusion outside of the module. Names that we forbid to import: Common names like dumps and loads Names starting with to_ and from_ Too short names like Q or F , but we are fine with _ Reasoning See datetime.* in code? You know that it's from datetime. See BaseView in a Django project? You know where it is from. See loads ? It can be anything: yaml , toml , json , etc. We are also enforcing consistency with our naming too-short rules here. Solution Use package level imports or import aliases. See VAGUE_IMPORTS_BLACKLIST for the full list of bad import names. Example # Correct: import json import dumps # package names are not checked from json import loads as json_loads # Wrong: from json import loads 0.13.0 0.14.0","title":"Found vague import that may cause confusion: _"},{"location":"WPS348/","text":"Forbid starting lines with a dot. Reasoning We enforce strict consistency rules about how to break lines. We also enforce strict rules about multi-line parameters. Starting new lines with the dot means that this rule is broken. Solution Use () to break lines in a complex expression. Example # Correct: some = MyModel.objects.filter( ..., ).exclude( ..., ).annotate( ..., ) # Wrong some = ( MyModel.objects.filter(...) .exclude(...) .annotate(...) ) 0.13.0","title":"Found a line that starts with a dot"},{"location":"WPS349/","text":"Forbid redundant components in a subscript's slice. Reasoning We do it for consistency reasons. Example # Correct: array[:7] array[3:] # Wrong: x[0:7] x[3:None] 0.13.0","title":"Found redundant subscript slice"},{"location":"WPS350/","text":"Enforce using augmented assign pattern. Reasoning a += b is short and correct version of a = a + b . Why not using the short version? Example # Correct: a += b # Wrong: a = a + b 0.13.0","title":"Found usable augmented assign pattern"},{"location":"WPS351/","text":"Forbid unnecessary literals in your code. Reasoning We discourage using primitive calls to get default type values. There are better ways to get these values. Solution Use direct default values of the given type Example # Correct: default = 0 # Wrong: default = int() 0.13.0","title":"Found unnecessary literals"},{"location":"WPS352/","text":"Forbid multiline loops. Reasoning It decreased the readability of the code. Solution Use single line loops and create new variables in case you need to fit too many logic inside the loop definition. Example # Correct : for num in some_function ( arg1 , arg2 ) : ... # Wrong : for num in range ( arg1 , arg2 , ) : ... 0.13.0","title":"Found multiline loop"},{"location":"WPS353/","text":"Forbid yield from with several nodes. We allow to yield from tuples, names, attributes, calls, and subscripts. Reasoning We enforce consistency when yielding values from tuple instead of any other types. It also might be an error when you try to yield from something that is not iterable. Solution Use allowed node types with yield from . Example # Correct: yield from (1, 2, 3) yield from some # Wrong: yield from [1, 2, 3] 0.13.0","title":"Found incorrect yield from target"},{"location":"WPS354/","text":"Forbid consecutive yield expressions. We raise this violation when we find at least two consecutive yield expressions. Reasoning One can write multiple yield nodes in a row. That's inconsistent. Because we have yield from form. Solution It can be easily changed to yield from (...) format. 0.13.0","title":"Found consecutive yield expressions"},{"location":"WPS355/","text":"Forbid useless blank lines before and after brackets. Reasoning We do this for consistency. Solution Remove blank lines from the start and from the end of a collection. Example # Correct: arr = [ 1, 2, ] # Wrong: arr = [ 1, 2, ] 0.13.0","title":"Found an unnecessary blank line before a bracket"},{"location":"WPS356/","text":"Forbid unnecessary iterable unpacking. Reasoning We do this for consistency. Solution Do not use iterable unpacking when it's not necessary. Example # Correct: [1, *numbers, 99] {*iterable, *other_iterable} list(iterable) first, *iterable = other_iterable # Wrong: [*iterable] *iterable, = other_iterable 0.13.0","title":"Found an unnecessary iterable unpacking"},{"location":"WPS357/","text":"Forbid using \\r (carriage return) in line breaks. Reasoning We enforce Unix-style newlines. We only use newlines ( \\n ), not carriage returns. So \\r line breaks not allowed in code. Solution Use only \\n (not \\r\\n or \\r ) to break lines. 0.14.0","title":"Found a \\r (carriage return) line break"},{"location":"WPS358/","text":"Forbid using float zeros: 0.0 . Reasoning Float zeros can be used as variable values which may lead to typing bugs when trying to perform an operation between an int number and the float zero. Solution Use int zeros (0). If a float is needed, it should be cast explicitly. Example # Correct: zero = 0 # Wrong: zero = 0.0 0.15.0","title":"Found a float zero (0.0)"},{"location":"WPS359/","text":"Forbids to unpack iterable objects to lists. Reasoning We do this for consistency. Solution Do not unpack iterables to lists, use tuples for that. Example # Correct: first, second = (7, 4) first, *iterable = other_iterable # Wrong: [first, second] = (7, 4) [first, *iterable] = other_iterable 0.15.0","title":"Found an iterable unpacking to list"},{"location":"WPS360/","text":"Forbid the use of raw strings when there is no backslash in the string. Reasoning Raw string are only needed when dealing with \\ in the string. Solution Do not prefix the string with r . Use a normal string instead. Example # Correct: r'This is a correct use \\n' # Wrong: r'This string should not be prefixed with r.' 0.15.0","title":"Found an unnecessary use of a raw string: _"},{"location":"WPS361/","text":"Forbids inconsistent newlines in comprehensions. Reasoning We do this for consistency. Solution Either place comprehension on a single line or ensure that action, for loops, and condition are all on different lines. Example # Correct : list = [ some ( number ) for number in numbers ] list = [ some ( number ) for numbers in matrix for number in numbers if number > 0 ] # Wrong : list = [ some ( number ) for number in numbers if number > 0 ] 0.15.0","title":"Found an inconsistently structured comprehension"},{"location":"WPS362/","text":"Forbid assignment to a subscript slice. Reasoning Assignment to a slice may lead to a list changing its size implicitly and strangely which makes it hard to spot bugs. Solution Use explicit index assignment in place of slice assignment. Why you may disable or inline-ignore this rule? The quite common and useful example which violates this rule is inplace list replacement via [:] - this helps to keep the same object reference while it content could be completely erased or replaced with the new one. One more thing: slice assignment is the only way for inplace array multiple replacement when you need that. Example # Correct: a[5] = 1 # Wrong: a[1:3] = [1, 2] a[slice(1)] = [1, 3] 0.15.0","title":"Found assignment to a subscript slice"},{"location":"wemake-python-styleguide/0.15.3/violations/naming/index.html","text":"Naming is hard! It is, in fact, one of the two hardest problems. These checks are required to make your application easier to read and understand by multiple people over the long period of time. Naming convention Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue! General Use only ASCII characters for names Do not use transliteration from any other languages, translate names instead Use clear names, do not use words that do not mean anything like obj Use names of an appropriate length: not too short, not too long Do not mask builtins Do not use unreadable character sequences like O0 and Il Protected members should use underscore as the first char Private names with two leading underscores are not allowed If you need to explicitly state that the variable is unused, prefix it with _ or just use _ as a name Do not use variables that are stated to be unused, rename them when actually using them Do not define unused variables unless you are unpacking other values as well Do not use multiple underscores ( __ ) to create unused variables Whenever you want to name your variable similar to a keyword or builtin, use trailing _ Do not use consecutive underscores When writing abbreviations in UpperCase capitalize all letters: HTTPAddress When writing abbreviations in snake_case use lowercase: http_address When writing numbers in snake_case do not use extra _ before numbers as in http2_protocol Packages Packages must use snake_case One word for a package is the most preferable name Modules Modules must use snake_case Module names must not overuse magic names Module names must be valid Python identifiers Classes Classes must use UpperCase Python's built-in classes, however, are typically lowercase words Exception classes must end with Error Instance attributes Instance attributes must use snake_case with no exceptions Class attributes Class attributes must use snake_case with no exceptions Enum fields also must use snake_case Functions and methods Functions and methods must use snake_case with no exceptions Method and function arguments Instance methods must have their first argument named self Class methods must have their first argument named cls Metaclass methods must have their first argument named mcs Python's *args and **kwargs should be default names when just passing these values to some other method/function, unless you want to use these values in place, then name them explicitly Global (module level) variables Global variables must use CONSTANT_CASE Unless other is required by the API, example: urlpatterns in Django Variables Variables must use snake_case with no exceptions When a variable is unused it must be prefixed with an underscore: _user Type aliases Must use UpperCase as real classes Must not contain word type in its name Generic types should be called clearly and properly, not just TT or KT or VT","title":"WPS1xx Naming"},{"location":"wemake-python-styleguide/0.15.3/violations/naming/index.html#naming-convention","text":"Our naming convention tries to cover all possible cases. It is partially automated with this linter, but: Some rules are still WIP Some rules will never be automated, code reviews to the rescue!","title":"Naming convention"},{"location":"WPS100/","text":"Forbid blacklisted module names. Reasoning Some module names are not expressive enough. It is hard to tell what you can find inside the utils.py module. Solution Rename your module, reorganize the contents. See MODULE_NAMES_BLACKLIST for the full list of bad module names. Example # Correct: github.py views.py # Wrong: utils.py helpers.py See also https://tonsky.me/blog/utils/ 0.1.0","title":"Found wrong module name"},{"location":"WPS101/","text":"Forbid magic names (except some whitelisted ones). Reasoning Do not fall in love with magic. There's no good reason to use magic names when you can use regular names. See MAGIC_MODULE_NAMES_WHITELIST for the full list of allowed magic module names. Example # Correct: __init__.py __main__.py # Wrong: __version__.py 0.1.0","title":"Found wrong module magic name"},{"location":"WPS102/","text":"Forbid module names that do not match our pattern. Reasoning Module names must be valid python identifiers. And just like the variable names - module names should be consistent. Ideally, they should follow the same rules. For python world it is common to use snake_case notation. We use MODULE_NAME_PATTERN to validate the module names. Example # Correct: __init__.py some_module_name.py test12.py # Wrong: _some.py MyModule.py 0001_migration.py 0.1.0","title":"Found incorrect module name pattern"},{"location":"WPS110/","text":"Forbid blacklisted variable names. Reasoning We have found some names that are not expressive enough. However, they appear in the code more than often. All names that we forbid to use could be improved. Solution Try to use a more specific name instead. If you really want to use any of the names from the list, add a prefix or suffix to it. It will serve you well. See VARIABLE_NAMES_BLACKLIST for the base list of blacklisted variable names. Example # Correct: html_node_item = None # Wrong: item = None Configuration This rule is configurable with --allowed-domain-names . Default: ALLOWED_DOMAIN_NAMES And with --forbidden-domain-names . Default: FORBIDDEN_DOMAIN_NAMES The options listed above are used to create new variable names' blacklist starting from VARIABLE_NAMES_BLACKLIST . 0.1.0","title":"Found wrong variable name: _"},{"location":"WPS111/","text":"Forbid short variable or module names. Reasoning It is hard to understand what the variable means and why it is used, if its name is too short. Solution Think of another name. Give more context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. We do not count trailing and leading underscores when calculating length. Example # Correct: x_coordinate = 1 abscissa = 2 # Wrong: x = 1 y = 2 Configuration This rule is configurable with --min-name-length . Default: MIN_NAME_LENGTH 0.1.0 0.4.0 0.12.0","title":"Found too short name: _"},{"location":"WPS112/","text":"Forbid private name pattern. Reasoning Private is not private in python . So, why should we pretend it is? This might lead to some serious design flaws. Solution Rename your variable or method to be protected. Think about your design, why do you want to make it private? Are there any other ways to achieve what you want? This rule checks: modules, variables, attributes, functions, and methods. Example # Correct: def _collect_coverage(self): ... # Wrong: def __collect_coverage(self): ... 0.1.0 0.4.0 0.14.0","title":"Found private name pattern: _"},{"location":"WPS113/","text":"Forbid using the same alias as the original name in imports. Reasoning Why would you even do this in the first place? Example # Correct: from os import path # Wrong: from os import path as path When --i-control-code` is set to False you can reexport things with as , because mypy might require it with implicit_reexport = False setting turned on. Configuration: This rule is configurable with --i-control-code and --i-dont-control-code` . Default: :str:`wemake_python_styleguide.options.defaults.I_CONTROL_CODE 0.1.0 0.13.0 0.14.0","title":"Found same alias import: _"},{"location":"WPS114/","text":"Forbid names with underscored numbers pattern. Reasoning This is done for consistency in naming. Solution Do not put an underscore between text and numbers, that is confusing. Rename your variable or modules do not include underscored numbers. This rule checks: modules, variables, attributes, functions, method, and classes. Please, note that putting an underscore that replaces - in some names between numbers are fine, example: ISO-123-456 would become iso123_456 . Example # Correct: star_wars_episode2 = 'awesome!' iso123_456 = 'some data' # Wrong: star_wars_episode_2 = 'not so awesome' iso_123_456 = 'some data' 0.3.0 0.4.0","title":"Found underscored number name pattern: _"},{"location":"WPS115/","text":"Require snake_case for naming class attributes. Reasoning Constants with upper-case names belong on a module level. Solution Move your constants to the module level. Rename your variables so that they conform to snake_case convention. Example # Correct: MY_MODULE_CONSTANT = 1 class A(object): my_attribute = 42 # Wrong: class A(object): MY_CONSTANT = 42 0.3.0","title":"Found upper-case constant in a class: _"},{"location":"WPS116/","text":"Forbid using more than one consecutive underscore in variable names. Reasoning This is done to gain extra readability. This naming rule already exists for module names. Example # Correct: some_value = 5 __magic__ = 5 # Wrong: some__value = 5 This rule checks: modules, variables, attributes, functions, and methods. 0.3.0 0.4.0","title":"Found consecutive underscores name: _"},{"location":"WPS117/","text":"Forbid naming variables self , cls , or mcs . Reasoning These names are special, they should only be used as first arguments inside methods. Example # Correct: class Test ( object ): def __init__ ( self ): ... # Wrong: cls = 5 lambda self: self + 12 This rule checks: functions and methods. Having any reserved names in lambda functions is not allowed. 0.5.0","title":"Found name reserved for first argument: _"},{"location":"WPS118/","text":"Forbid long variable or module names. Reasoning Too long names are unreadable. It is better to use a shorter alternative. Long names also indicate that this variable is too complex, maybe it may require some documentation. Solution Think of another name. Give less context to it. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: total_price = 25 average_age = 45 # Wrong: final_price_after_fifteen_percent_sales_tax_and_gratuity = 30 total_age_of_all_participants_in_the_survey_divided_by_twelve = 2 Configuration This rule is configurable with --max-name-length . Default: MAX_NAME_LENGTH 0.5.0","title":"Found too long name: _"},{"location":"WPS119/","text":"Forbid unicode names. Reasoning This should be forbidden for sanity, readability, and writability. Solution Rename your entities so that they contain only ASCII symbols. This rule checks: modules, variables, attributes, functions, methods, and classes. Example # Correct: some_variable = 'Text with russian: \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a' # Wrong: \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f = 42 some_\u8b8a\u91cf = '' 0.5.0","title":"Found unicode name: _"},{"location":"WPS120/","text":"Forbid trailing _ for names that do not need it. Reasoning We use trailing underscore for a reason: to indicate that this name shadows a built-in or keyword. So, when overusing this feature for general names: it just harms readability of your program. Solution Rename your variable not to contain trailing underscores. This rule checks: variables, attributes, functions, methods, and classes. Example # Correct: class_ = SomeClass list_ = [] # Wrong: some_variable_ = 1 0.7.0","title":"Found regular name with trailing underscore: _"},{"location":"WPS121/","text":"Forbid using variables that are marked as unused. We discourage using variables that start with _ only inside functions and methods as local variables. However, we allow to use _ because tools like ipython , babel , and django enforce it. Reasoning Sometimes you start to use new logic in your functions, and you start to use variables that once were marked as unused. But, you have not renamed them for some reason. And now you have a lot of confusion: the variable is marked as unused, but you are using it. Why? What's going on? Solution Rename your variable to be a regular variable without a leading underscore. This way it is declared to be used. Example # Correct : def function () : first = 15 return first + 10 # Wrong : def function () : _first = 15 return _first + 10 This rule checks: functions, methods, and lambda functions. 0.7.0 0.12.0 0.14.0","title":"Found usage of a variable marked as unused: _"},{"location":"WPS122/","text":"Forbid explicit unused variables. Reasoning While it is ok to define unused variables when you have to, like when unpacking a tuple, it is totally not ok to define explicit unusued variables in cases like assignment, function return, exception handling, or context managers. Why do you need this explicitly unused variables? Solution Remove all unused variables definition. Example # Correct: my_function() first, _second = some_tuple() print(first) # Wrong: _ = my_function() _first, _second = some_tuple() This rule checks: assigns, context managers, except clauses. 0.12.0","title":"Found all unused variables definition: _"},{"location":"WPS123/","text":"Forbid unused variables with multiple underscores. Reasoning We only use _ as a special definition for an unused variable. Other variables are hard to read. It is unclear why would one use it. Solution Rename unused variables to _ or give it some more context with an explicit name: _context . Example # Correct: some_element, _next_element, _ = some_tuple() some_element, _, _ = some_tuple() some_element, _ = some_tuple() # Wrong: some_element, _, __ = some_tuple() 0.12.0","title":"Found wrong unused variable name: _"},{"location":"WPS124/","text":"Forbid variable or module names which could be difficult to read. Reasoning Currently one can name your classes like so: ZerO0 Inside it is just O and 0 , but we cannot tell it from the word. There are a lot other combinations which are unreadable. Solution Rename your entity not to contain unreadable sequences. This rule checks: modules, variables, attributes, functions, methods, and classes. See UNREADABLE_CHARACTER_COMBINATIONS for full list of unreadable combinations. Example # Correct: ControlStatement AveragePrice # Wrong: Memo0Output 0.14","title":"Found unreadable characters combination: _"},{"location":"WPS125/","text":"Forbid variable or module names which shadow builtin names. Reasoning Your code simply breaks Python. After you create list = 1 , you cannot not call builtin function list and what can be worse than that? Solution Rename your entity to not shadow Python builtins. Example # Correct: my_list = list(some_other) # Wrong: str = '' list = [1, 2, 3] This can also cause problems when defining class attributes, for example: class A: min = 5 max = min ( 10 , 20 ) # TypeError: 'int' object is not callable If you feel it is still necessary to use such a class attribute, consider using a `noqa comment with caution. See BUILTINS_WHITELIST for full list of builtins we allow to shadow. 0.14 0.15","title":"Found builtin shadowing: _"},{"location":"wemake-python-styleguide/0.15.3/violations/oop/index.html","text":"These checks ensures that you use Python's version of OOP correctly. There are different gotchas in Python to write beautiful classes and using objects correctly. That's the place we collect these kind of rules.","title":"WPS6xx OOP"},{"location":"WPS600/","text":"Forbid subclassing lowercase builtins. We forbid to subclass builtins like int , str , bool , etc. We allow to subclass object and type , warnings, and exceptions. See ALLOWED_BUILTIN_CLASSES for the whole list of whitelisted names. Reasoning It is almost never a good idea (unless you do something sneaky) to subclass primitive builtins. Solution Use custom objects around some wrapper. Use magic methods to emulate the desired behaviour. Example # Correct: class Some ( object ): ... class MyValueException ( ValueError ): ... # Wrong: class MyInt ( int ): ... 0.10.0 0.11.0","title":"Found subclassing a builtin: _"},{"location":"WPS601/","text":"Forbid shadowing class level attributes with instance level attributes. Reasoning This way you will have two attributes inside your __mro__ chain: one from instance and one from class. It might cause errors. Needless to say, that this is just pointless to do so. Also, if you ever want to optimise your code with a tool like `mypyc _, this rule is a requirement. Solution Use either class attributes or instance attributes. Use ClassVar type on fields that are declared as class attributes. Note, that we cannot find shadowed attributes that are defined in parent classes. That's where ClassVar is required for mypy to check it for you. Example # Correct: from typing import ClassVar class First ( object ): field : ClassVar [ int ] = 1 class Second ( object ): field : int def __init__ ( self ) -> None : self . field = 1 # Wrong: class Some ( object ): field = 1 def __init__ ( self ) -> None : self . field = 1 0.10.0 0.11.0 0.14.0","title":"Found shadowed class attribute: _"},{"location":"WPS602/","text":"Forbid @staticmethod decorator. Reasoning Static methods are not required to be inside the class. Because they even do not have access to the current instance. Solution Use instance methods, @classmethod , or functions instead. 0.1.0 0.11.0 See also webucator.com/blog/2016/05/when-to-use-static-methods-in-python-never","title":"Found using @staticmethod"},{"location":"WPS603/","text":"Forbid certain magic methods. Reasoning We forbid to use magic methods related to the forbidden language parts. Likewise, we forbid to use del keyword, so we forbid to use all magic methods related to it. Solution Refactor your code to use custom methods instead. It will give more context to your app. See MAGIC_METHODS_BLACKLIST for the full blacklist of the magic methods. 0.1.0 0.11.0 See also https://www.youtube.com/watch?v=F6u5rhUQ6dU","title":"Found using restricted magic method: _"},{"location":"WPS604/","text":"Forbid incorrect nodes inside class definitions. Reasoning Python allows us to have conditions, context managers, and even infinite loops inside class definitions. On the other hand, only methods, attributes, and docstrings make sense. So, we discourage using anything except these nodes in class bodies. Solution If you have complex logic inside your class definition, most likely that you do something wrong. There are different options to refactor this mess. You can try metaclasses, decorators, builders, and other patterns. Example # Wrong: class Test ( object ): for _ in range ( 10 ): print ( 'What?!' ) We also allow some nested classes, check out NestedClassViolation for more information. 0.7.0 0.11.0","title":"Found incorrect node inside class body"},{"location":"WPS605/","text":"Forbid methods without any arguments. Reasoning Methods without arguments are allowed to be defined, but almost impossible to use. Furthermore, they don't have an access to self , so cannot access the inner state of the object. It might be an intentional design or just a typo. Solution Move any methods with arguments to raw functions. Or just add an argument if it is actually required. Example # Correct: class Test ( object ): def method ( self ): ... # Wrong: class Test ( object ): def method (): ... 0.7.0 0.11.0","title":"Found method without arguments: _"},{"location":"WPS606/","text":"Forbid anything other than a class as a base class. We only check base classes and not keywords. They can be anything you need. Reasoning In Python you can specify anything in the base classes slot. In runtime this expression will be evaluated and executed. We need to prevent dirty hacks in this field. Solution Use only attributes, names, and types to be your base classes. Use annotation future import in case you use strings in base classes. Example # Correct : class Test ( module . ObjectName , MixinName , keyword = True ) : ... class GenericClass ( Generic [ ValueType ] ) : ... # Wrong : class Test (( lambda : object )()) : ... 0.7.0 0.7.1 0.11.0 0.12.0","title":"Found incorrect base class"},{"location":"WPS607/","text":"Forbid incorrect __slots__ definition. Things that this rule checks: That __slots__ is a tuple, name, attribute, star, or call That __slots__ do not have duplicates That __slots__ do not have empty strings or invalid python names Reasoning __slots__ is a very special attribute. It completely changes your class. So, we need to be careful with it. We should not allow anything rather than tuples to define slots, we also need to check that fields defined in __slots__ are unique. Solution Use tuples with unique elements to define __slots__ attribute. Use snake_case to define attributes in __slots__ . Example # Correct: class Test ( object ): __slots__ = ( 'field1' , 'field2' ) class Other ( Test ): __slots__ = (* Test . __slots__ , 'child' ) # Wrong: class Test ( object ): __slots__ = [ 'field1' , 'field2' , 'field2' ] Note, that we do ignore all complex expressions for this field. So, we only check raw literals. 0.7.0 0.11.0 0.12.0","title":"Found incorrect __slots__ syntax"},{"location":"WPS608/","text":"Forbid super() with parameters or outside of methods. Reasoning super() is a very special function. It implicitly relies on the context where it is used and parameters passed to it. So, we should be very careful with parameters and context. Solution Use super() without arguments and only inside methods. Example # Correct: super().__init__() # Wrong: super(ClassName, self).__init__() 0.7.0 0.11.0","title":"Found incorrect super() call: _"},{"location":"WPS609/","text":"Forbid direct magic attributes and methods. Reasoning When using direct magic attributes or method it means that you are doing something wrong. Magic methods are not suited to be directly called or accessed. Solution Use special syntax constructs that will call underlying magic methods. Example # Correct: super().__init__() # Wrong: 2..__truediv__(2) d.__delitem__('a') Note, that it is possible to use direct magic attributes with self , cls , and super() as base names. We allow this because a lot of internal logic relies on these methods. 0.8.0 0.11.0","title":"Found direct magic attribute usage: _"},{"location":"WPS610/","text":"Forbid certain async magic methods. We allow to make __anext__ , __aenter__ , __aexit__ async. We also allow custom magic methods to be async. See ASYNC_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted async magic methods. Reasoning Defining the magic methods as async which are not supposed to be async would not work as expected. Solution Do not make this magic method async. Example # Correct: class Test ( object ): def __lt__ ( self , other ): ... # Wrong: class Test ( object ): async def __lt__ ( self , other ): ... See also https://docs.python.org/3/reference/datamodel.html 0.12.0","title":"Found forbidden async magic method usage: _"},{"location":"WPS611/","text":"Forbid yield inside of certain magic methods. We allow to make __iter__ a generator. See YIELD_MAGIC_METHODS_BLACKLIST for the whole list of blacklisted generator magic methods. Reasoning Python's datamodel is strict. You cannot make generators from random magic methods. This rule enforces it. Solution Remove yield from a magic method or rename it to be a custom method. Example # Correct: class Example(object): def __init__(self): ... # Wrong: class Example(object): def __init__(self): yield 10 See also https://docs.python.org/3/reference/datamodel.html 0.3.0 0.11.0 0.12.0","title":"Found forbidden yield magic method usage"},{"location":"WPS612/","text":"Forbid useless overwritten methods. Reasoning Overwriting method without any changes does not have any positive impact. Solution Do not overwrite method in case you do not want to do any changes inside it. Example # Correct: class Test ( Base ): def method ( self , argument ): super (). method ( argument ) return argument # or None, or anything! # Wrong: class Test ( object ): def method ( self , argument ): return super (). method ( argument ) 0.12.0","title":"Found useless overwritten method: _"},{"location":"WPS613/","text":"Forbid super() with incorrect method or property access. Reasoning Can only use super() method that matches the following context. super().some() and super().some in Child.some() , and super().prop and super().prop() in Child.prop Solution Use super() methods and properties with the correct context. Example # Correct: class Child ( Parent ): def some_method ( self ): original = super (). some_method () # Wrong: class Child ( Parent ): def some_method ( self ): other = super (). other_method () 0.13.0","title":"Found incorrect super() call context: incorrect name access"},{"location":"WPS614/","text":"Forbids descriptors in regular functions. Forbids using @staticmethod`, @classmethod and @property`` for functions not in class. Reasoning Descriptors like @staticmethod, @classmethod and @property do magic only as methods. We would want to warn users if the descriptors are used on regular functions. Solution Do not use @staticmethod, @classmethod and @property on regular functions or wrap the functions into a Class. Example # Correct : class TestClass ( object ) : @property def my_method () : ... # Wrong : @property def my_function () : ... 0.15.0","title":"Found descriptor applied on a function"},{"location":"WPS615/","text":"Forbids to use getters and setters in objects. Reasoning Python does not need this abstraction. Solution Either use @property or make the attribute public and change it directly. Example # Correct: class Example ( object ): def __init__ ( self ): self . _attribute = None # Wrong: class Example ( object ): def __init__ ( self ): self . attribute = None def set_attribute ( self ): ... def get_attribute ( self , value ): ... 0.15.0","title":"Found unpythonic getter or setter"},{"location":"wemake-python-styleguide/0.15.3/violations/refactoring/index.html","text":"These checks ensure that you don't have patterns that can be refactored. There are so many ways of doing the same thing in Python. Here we collect know patterns that can be rewritten into much easier or just more pythonic version.","title":"WPS5xx Refactoring"},{"location":"WPS500/","text":"Forbid else without break in a loop. We use the same logic for for and while loops. Reasoning When there's no break keyword in loop's body it means that else will always be called. This rule will reduce complexity, improve readability, and protect from possible errors. Solution Refactor your else case logic to be inside the loop's body. Or right after it. Example # Correct : for letter in ' abc ' : if letter == ' b ' : break else : print ( ' \"b\" is not found ' ) for letter in ' abc ' : print ( letter ) print ( ' always called ' ) # Wrong : for letter in ' abc ' : print ( letter ) else : print ( ' always called ' ) 0.3.0 0.11.0","title":"Found else in a loop without break"},{"location":"WPS501/","text":"Forbid finally in try block without except block. However, we allow to use try with just finally block when function or method is decorated. Because we cannot control what is going on in this decorator. It might be @contextmanager or similar thing that requires this API. Reasoning This rule will reduce complexity and improve readability. Solution Refactor your try logic. Replace the try-finally statement with a with statement. Example # Correct: with open(\"filename\") as f: f.write(...) # Wrong: try: f = open(\"filename\") f.write(...) finally: f.close() 0.3.0 0.11.0 0.14.0","title":"Found finally in try block without except"},{"location":"WPS502/","text":"Forbid simplifiable if conditions. Reasoning These complex constructions can cause frustration among other developers. They are longer, more verbose, and more complex. Solution Either use bool() to convert test values to boolean values, or just leave it as it is in case your test already returns a boolean value. Use can also use not keyword to switch boolean values. Example # Correct : my_bool = bool ( some_call ()) other_value = 8 if some_call () else None # Wrong : my_bool = True if some_call () else False We only check if nodes where True and False values are used. We check both if nodes and if expressions. 0.7.0 0.11.0","title":"Found simplifiable if condition"},{"location":"WPS503/","text":"Forbid useless else cases in returning functions. We check single if , for , while , and try statements that all contain return , raise , continue , or break statements with this rule. Reasoning Using extra else creates a situation when the whole node could and should be dropped without any changes in logic. So, we prefer to have less code than more code. Solution Remove useless else case. Example # Correct : def some_function () : if some_call () : return ' yeap ' return ' nope ' # Wrong : def some_function () : if some_call () : raise ValueError ( ' yeap ' ) else : raise ValueError ( ' nope ' ) 0.7.0 0.11.0 0.15.1","title":"Found useless returning else statement"},{"location":"WPS504/","text":"Forbid negated conditions together with else clause. Reasoning It easier to read and name regular conditions. Not negated ones. Solution Move actions from the negated if condition to the else condition. Example # Correct : if some == 1 : ... else : ... if not some : ... if not some : ... elif other : ... # Wrong : if not some : ... else : ... 0.8.0 0.11.0","title":"Found negated condition"},{"location":"WPS505/","text":"Forbid nested try blocks. Notice, we check all possible slots for try block: 1. the try block itself 2. all except cases 3. else case 4. and finally case Reasoning Nesting try blocks indicates that something really bad happens to your logic. Why does it require two separate exception handlers? It is a perfect case to refactor your code. Solution Collapse two exception handlers together. Or create a separate function that will handle this second nested case. Example # Wrong: try: try: ... except SomeException: ... except SomeOtherException: ... try: ... except SomeOtherException: try: ... except SomeException: ... 0.8.0 0.11.0","title":"Found nested try block"},{"location":"WPS506/","text":"Forbid useless proxy lambda expressions. Reasoning Sometimes developers tend to overuse lambda expressions and they wrap code that can be passed as is, without extra wrapping. The code without extra lambda is easier to read and is more performant. Solution Remove wrapping lambda declaration, use just the internal function. Example # Correct: numbers = map(int, ['1', '2']) # Wrong: numbers = map(lambda string: int(string), ['1', '2']) 0.10.0 0.11.0","title":"Found useless lambda declaration"},{"location":"WPS507/","text":"Forbid unpythonic zero-length compare. Note, that we allow to check arbitrary length, like len(arr) == 3 . Reasoning Python's structures like dicts, lists, sets, and tuples all have __bool__ method to checks their length. So, there's no point in wrapping them into len(...) and checking that it is bigger that 0 or less then 1 , etc. Solution Remove extra len() call. Example # Correct : if some_array or not other_array or len ( third_array ) == 1 : ... # Wrong : if len ( some_array ) > 0 or len ( other_array ) < 1 : ... 0.10.0 0.11.0","title":"Found useless len() compare"},{"location":"WPS508/","text":"Forbid not with compare expressions. Reasoning This version of not operator is unreadable. Solution Refactor the expression without not operator. Change the compare signs. Example # Correct : if x <= 5 : ... # Wrong : if not x > 5 : ... 0.10.0 0.11.0","title":"Found incorrect not with compare usage"},{"location":"WPS509/","text":"Forbid nesting ternary expressions in certain places. Note, that we restrict to nest ternary expressions inside: if conditions boolean and binary operations like and or + unary operators Reasoning Nesting ternary in random places can lead to very hard debug and testing problems. Solution Refactor the ternary expression to be either a new variable, or nested if statement, or a new function. Example # Correct : some = x if cond () else y # Wrong : if x if cond () else y : ... 0.10.0 0.11.0","title":"Found incorrectly nested ternary"},{"location":"WPS510/","text":"Forbid in with static containers except set nodes. We enforce people to use sets as a static containers. You can also use variables, calls, methods, etc. Dynamic values are not checked. Reasoning Using static list , tuple , or dict elements to check that some element is inside the container is a bad practice. Because we need to iterate all over the container to find the element. Sets are the best suit for this task. Moreover, it makes your code consistent. Solution Use set elements or comprehensions to check that something is contained in a container. Example # Correct: print(needle in {'one', 'two'}) # Wrong: print(needle in ['one', 'two']) 0.10.0 0.11.0 0.14.0","title":"Found in used with a non-set container"},{"location":"WPS511/","text":"Forbid multiple isinstance calls on the same variable. Reasoning The best practice is to use isinstance with tuple as the second argument, instead of multiple conditions joined with or . Solution Use tuple of types as the second argument. Example # Correct: isinstance(some, (int, float)) # Wrong: isinstance(some, int) or isinstance(some, float) See also https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found separate isinstance calls that can be merged for: _"},{"location":"WPS512/","text":"Forbid multiple isinstance calls with single-item tuples. Reasoning There's no need to use tuples with single elements. You can use single variables or tuples with multiple elements. Solution Use tuples with multiple elements or a single variable. Example # Correct: isinstance(some, (int, float)) isinstance(some, int) # Wrong: isinstance(some, (int, )) See: https://docs.python.org/3/library/functions.html#isinstance 0.10.0 0.11.0","title":"Found isinstance call with a single element tuple"},{"location":"WPS513/","text":"Forbid implicit elif conditions. Reasoning Nested if in else cases are bad for readability because of the nesting level. Solution Use elif on the same level. Example # Correct : if some : ... elif other : ... # Wrong : if some : ... else : if other : ... 0.12.0","title":"Found implicit elif condition"},{"location":"WPS514/","text":"Forbid multiple equality comparisons with the same variable. Reasoning Using double+ equality compare with or or double+ non-equality compare with and indicates that you have implicit in or not in condition. It is just hidden from you. Solution Refactor compares to use in or not in clauses. Example # Correct: print(some in {'first', 'second'}) print(some not in {'first', 'second'}) # Wrong: print(some == 'first' or some == 'second') print(some != 'first' and some != 'second') 0.10.0 0.12.0","title":"Found implicit in condition"},{"location":"WPS515/","text":"Forbid open() without a context manager. Reasoning When you open() something, you need to close it. When using a context manager - it is automatically done for you. When not using it - you might find yourself in a situation when file is not closed and is not accessible anymore. Solution Refactor open() call to use with . Example # Correct: with open(filename) as file_obj: ... # Wrong: file_obj = open(filename) 0.12.0","title":"Found open() used without a context manager"},{"location":"WPS516/","text":"Forbid comparing types with type() function. Reasoning When you compare types with type() function call it means that you break polymorphism and disallow child classes of a node to work here. That's incorrect. Solution Use isinstance to compare types. Example # Correct : print ( something , type ( something )) if isinstance ( something , int ) : ... # Wrong : if type ( something ) == int : ... 0.12.0","title":"Found type() used to compare types"},{"location":"WPS517/","text":"Forbid useless starred expressions. Reasoning Using starred expression with constants is useless. This piece of code can be rewritten to be flat. Eg.: print(*[1, 2, 3]) is print(1, 2, 3) . Solution Refactor your code not to use starred expressions with list , dict , tuple , and set constants. Use regular argument passing instead. Example # Correct: my_list = [1, 2, 3, *other_iterable] # Wrong: print(*[1, 2, 3], ** {{}} ) 0.12.0","title":"Found pointless starred expression"},{"location":"WPS518/","text":"Forbid implicit enumerate() calls. Reasoning Using range(len(...)) is not pythonic. Python uses collection iterators, not index-based loops. Solution Use enumerate(...) instead of range(len(...)) . Example # Correct: for index , person in enumerate ( people ): ... # Wrong: for index in range ( len ( people )): ... See also https://docs.python.org/3/library/functions.html#enumerate 0.12.0","title":"Found implicit enumerate() call"},{"location":"WPS519/","text":"Forbid implicit sum() calls. When summing types different from numbers, you might need to provide the second argument to the sum function: sum([[1], [2], [3]], []) You might also use str.join to join iterable of strings. Reasoning Using for loops with += assign inside indicates that you iteratively sum things inside your collection. That's what sum() builtin function does. Solution Use sum(...) instead of a loop with += operation. Example # Correct : sum_result = sum ( get_elements ()) # Wrong : sum_result = 0 for to_sum in get_elements () : sum_result += to_sum See also https://docs.python.org/3/library/functions.html#sum https://docs.python.org/3/library/stdtypes.html#str.join 0.12.0","title":"Found implicit sum() call"},{"location":"WPS520/","text":"Forbid comparing with explicit falsy constants. We allow to compare with falsy numbers, strings, booleans, None . We disallow complex constants like tuple, dicts, and lists. Reasoning When comparing something with explicit falsy constants what we really mean is not something . Solution Use not with your variable. Fix your data types. Example # Correct : if not my_check : ... if some_other is None : ... if some_num == 0 : ... # Wrong : if my_check == []: ... 0.12.0","title":"Found compare with falsy constant"},{"location":"WPS521/","text":"Forbid comparing values with constants using is or is not . However, we allow to compare with None and booleans. Reasoning is compares might not do what you want them to do. Firstly, they check for the same object, not equality. Secondly, they behave unexpectedly even with the simple values like 257 . Solution Use == to compare with constants. Example # Correct : if my_check == [ 1 , 2 , 3 ]: ... # Wrong : if my_check is [ 1 , 2 , 3 ]: ... See also https://stackoverflow.com/a/33130014/4842742 0.12.0","title":"Found wrong is compare"},{"location":"WPS522/","text":"Forbid implicit primitives in the form of lambda functions. Reasoning When you use lambda that returns a primitive value and takes no arguments, it means that you should use a primitive type instead. Solution Replace lambda with int , float , list , or any other primitive. Example # Correct: defaultdict(int) # Wrong: defaultdict(lambda: 0) 0.13.0","title":"Found implicit primitive in a form of lambda"},{"location":"WPS523/","text":"Forbid unpythonic variable swaps. We check for a = b; b = a sequences. Reasoning This looks like a failed attempt to swap. Solution Use standard way to swap two variables. Example # Correct: a, b = b, a # Wrong: a = b b = a temp = a a = b b = temp 0.13.0","title":"Found incorrectly swapped variables"},{"location":"WPS524/","text":"Forbid misrefactored self assignment. Reasoning Self assignment does not need to have the same operand on the left hand side and on the right hand side. Solution Refactor you code to use multiple self assignments or fix your code. Example # Correct: test += 1 test *= 2 # Wrong: test += test + 1 See MATH_APPROXIMATE_CONSTANTS for full list of math constants that we check for. 0.13.0","title":"Found self assignment  with refactored assignment"},{"location":"WPS525/","text":"Forbid comparisons where in is compared with single item container. Reasoning in comparison with a container which contains only one item looks like overhead and unneeded complexity. Solution Refactor your code to use == instead in . Example # Correct: a == 's' # Wrong: a in {'s'} 0.13.0","title":"Found wrong in compare with single item container"},{"location":"WPS526/","text":"Forbid yield inside for loop instead of yield from . Reasoning It is known that yield from is a semantically identical to a for loop with a yield inside. But, it is way more readable. Solution Use yield from some iterable directly instead iterating over it inside a loop and yield it one by one. Example # Correct : yield from some () yield from ( value [ index : index + chunk_size ] for index in range ( 0 , len ( value ) , chunk_size ) ) # Wrong : for index in chunk : yield index 0.13.0","title":"Found implicit yield from usage"},{"location":"WPS527/","text":"Require tuples as arguments for certain functions. Reasoning For some functions, it is better to use tuples instead of another iterable types (list, sets,...) as arguments. Solution Use tuples as arguments. Example # Correct: a = frozenset((2,)) # Wrong: a = frozenset([2]) See TUPLE_ARGUMENTS_METHODS for full list of methods that we check for. 0.13.0","title":"Found not a tuple used as an argument"},{"location":"WPS528/","text":"Forbid implicit .items() iterator. Reasoning When iterating over collection it is easy to forget to use .items() when you need to access both keys and values. So, when you access the iterable with the key inside a for loop, that's a sign to refactor your code. Solution Use .items() with direct keys and values when you need them. Example # Correct : for some_key , some_value in collection . items () : print ( some_key , some_value ) # Wrong : for some_key in collection : print ( some_key , collection [ some_key ] ) 0.13.0","title":"Found implicit .items() usage"},{"location":"WPS529/","text":"Forbid implicit .get() dict method. Reasoning When using in with a dict key it is hard to keep the code clean. It is more convenient to use .get() and check for None later. Solution Use .get() with the key you need. Check for None in case you need it, or just act with the default value of the same type. Example # Correct : value = collection . get ( key ) if value is not None : print ( value ) # Wrong : if key in collection : print ( collection [ key ] ) 0.13.0","title":"Found implicit .get() dict usage"},{"location":"WPS530/","text":"Forbid implicit negative indexes. Reasoning There's no need in getting the length of an iterable and then having a negative offset, when you can specify negative indexes in the first place. Solution Use negative indexes. Example # Correct: some_list[-1] # Wrong: some_list[len(some_list) - 1] 0.13.0","title":"Found implicit negative index"},{"location":"WPS531/","text":"Forbid if statements that simply return booleans in functions or methods. Reasoning There is no need to test a condition and simply return a boolean depending on its outcome if there is not going to be any additional code. Solution Instead of testing the condition and returning a boolean, return the condition itself. This applies to early returning ifs too. Example # Correct : def some_function () : return some_condition # Wrong : def some_function () : if some_condition : return True else : return False 0.15.0","title":"Found simplifiable returning if condition in a function"},{"location":"wemake-python-styleguide/0.15.3/violations/system/index.html","text":"These checks ensures that our internal checks passes. For example, we can report violations from this group when some exception occur during the linting process or some dependencies are missing.","title":"WPS0xx System"},{"location":"WPS000/","text":"Happens when we get unhandled exception during the linting process. All this violations should be reported to the main issue tracker. We ideally should not produce these violations at all. See also https://github.com/wemake-services/wemake-python-styleguide/issues 0.13.0","title":"Internal error happened, see log. Please, take some time to report it"}]}